#include "led.h"
#include "delay.h"
#include "sys.h"
#include "usart.h"
#include "oled.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "scan.h"
extern u8 hum_set,Is_Ture;
u8 out_state[3];

/*
         1.ÏÔÊ¾ÈýÂ·³¬Éù²¨µÄ¾àÀë
         2.µÚ¶þÆÁÄ»ÉèÖÃ ±¨¾¯¾àÀë
*/
void Targ_GPIO()
{
    GPIO_InitTypeDef  GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_10|GPIO_Pin_1;	 //PD3,PD6ÍÆÍìÊä³ö  
 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //ÍÆÍìÊä³ö
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//ËÙ¶È50MHz
 	GPIO_Init(GPIOB, &GPIO_InitStructure);	  //³õÊ¼»¯GPIOD3,6
    
 	GPIO_ResetBits(GPIOB,GPIO_Pin_0|GPIO_Pin_10|GPIO_Pin_1);	//PD3,PD6 Êä³ö¸ß
}
extern volatile u8  TIM4_CAPTURE_STA,state;	//ÊäÈë²¶»ñ×´Ì¬		    				
extern volatile u16 TIM4_CAPTURE_VAL;	//ÊäÈë²¶»ñÖµ
float distance_circulate(u32 date,u8 state) //¼ÆËã¾àÀë,dis=340m/s*Ê±¼ä/2
{
    float dis;
    if(state>0xc1) //³¬³ö·¶Î§,²»¼ÆËã
        state=0xc1;
    date+=(state-0xc0)*65535; //¼ÆËãÒç³öµÄÊ±¼ä,³¬³ö·¶Î§,²»¼ÆËã
    date/=2;
    dis=(date*340)/10000.0;
    return dis;
}
u8 dis_warn(float warn,u8 dis)
{
  if((u8)warn<dis)
  {
    TIM_Cmd(TIM2,ENABLE);
    TIM2->PSC=719;
    
      if((u8)warn+2<dis)
       TIM2->PSC=366;
    if((u8)warn+5<dis)
        TIM2->PSC=71;
    return 1;
  }
  return 0;
}
 int main(void) //Ö÷º¯Êý
 { 
    u32 distance[3];
    float dis_save[3];
     float dis_temp;
    u8 distance_warning=10;
	volatile u8 Key_vaule,num_pos=0;
    
	u8 buf[20],buf1[20],Is_distance_set=0,Heart_bit; //
	delay_init();	    	 //ÑÓÊ±º¯Êý³õÊ¼»¯	  
	TIM4_Cap_Init(0xffff,71);
    
  //  TIM4_Int_Init(0xffff,71);
    Key_GPIO_Init();  // PA 0-7
     
   // TIM4_Cap_Init(0xffff,71);          //ÈýÂ·³¬Éù²¨³õÊ¼»¯ PB 7-9
     OLED_Init();  //oled³¬ÊæÊÊ»¯  PB 3,4,5,6
    Targ_GPIO();
	memset(buf,0,16);
    memset(buf1,0,16);
    TIME_INIT(); 
    TIM_Cmd(TIM4,ENABLE ); 	//Ê¹ÄÜ¶¨Ê±Æ÷2
	while(1)
	{
      Key_vaule=Key_Scan(); //°´¼üÉ¨Ãè
        
       if(Heart_bit>100) //³¬Éù²¨²â¾à,Ã¿100ms²âÒ»´Î
       {
          
 
            state=1;
            PBout(0)=1;
            delay_us(30);
            PBout(0)=0;
            TIM4_CAPTURE_VAL=0;
            while(TIM4_CAPTURE_STA<0xc0);
           out_state[0]=TIM4_CAPTURE_STA;
            distance[0]=TIM4_CAPTURE_VAL;
            TIM4_CAPTURE_STA=0; //ÖØÖÃ±êÖ¾Î»
            state=2;
            PBout(1)=1;
            delay_us(30);
            PBout(1)=0;
            TIM4_CAPTURE_VAL=0;
            while(TIM4_CAPTURE_STA<0xc0);
           out_state[1]=TIM4_CAPTURE_STA;
            distance[1]=TIM4_CAPTURE_VAL;
            TIM4_CAPTURE_STA=0;  //ÖØÖÃ±êÖ¾Î»
            state=3;
            PBout(10)=1;
            delay_us(30);
            PBout(10)=0;
            TIM4_CAPTURE_VAL=0;
           while(TIM4_CAPTURE_STA<0xc0);
           out_state[2]=TIM4_CAPTURE_STA;
           distance[2]=TIM4_CAPTURE_VAL;
           TIM4_CAPTURE_STA=0;  //ÖØÖÃ±êÖ¾Î»
       }
      if(Key_vaule=='A') //°´¼üA,ÉèÖÃ¾àÀë 
      {
        Is_distance_set=1;
        OLED_Clear();//ÇåÆÁ ÏÔÊ¾ÉèÖÃµÄ¾àÀë
        OLED_ShowString(5,0,"setting/cm");      
        OLED_Refresh_Gram();	 
          
      }
      if(Key_vaule>='0'&&Key_vaule<='9'&&Is_distance_set==1)
      {
        buf[num_pos++]=Key_vaule;
        OLED_ShowString(5,20,buf);  //ÏÔÊ¾°´¼ü
        OLED_Refresh_Gram();
        if(num_pos>3)
            num_pos=0;
      }
      if(Key_vaule=='#'&&(Is_distance_set==1))  //ÉèÖÃ¾àÀë
      {
        Is_distance_set=0; //ÉèÖÃÍê³É,Ìø³ö
        if(strlen(buf)>0)
            distance_warning=atoi(buf);
        memset(buf,0,10);
        delay_ms(1000);
        OLED_Clear();
        Heart_bit=111;  //ÎªÁËµÈÏÂÄÜ¿ìËÙ¿´µ½¾àÀë
      }
     
      
     if(Heart_bit>100&&(Is_distance_set==0)) //³¬Éù²¨²â¾à,Ã¿100ms²âÒ»´Î,²¢ÏÔÊ¾,²¢ÇÒÅÐ¶ÏÊÇ·ñ±¨¾¯
     {
        Heart_bit=0;
         sprintf(buf1,"CH1:%.1f cm",dis_save[0]=distance_circulate(distance[0],out_state[0]));               //²âÁ¿¾àÀë
         OLED_ShowString(5,0,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
         sprintf(buf1,"CH2:%.1f cm",dis_save[1]=distance_circulate(distance[1],out_state[1]));               //²âÁ¿¾àÀë
         OLED_ShowString(5,16,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
         sprintf(buf1,"CH3:%.1f cm",dis_save[2]=distance_circulate(distance[2],out_state[2]));               //²âÁ¿¾àÀë
         OLED_ShowString(5,32,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
     }
     /*-----------------Èý¸öµÈ¼¶----------------------*/
     if(dis_save[0]<distance_warning||dis_save[1]<distance_warning||dis_save[2]<distance_warning)
     {
        dis_warn(dis_save[0],distance_warning);
        dis_warn(dis_save[1],distance_warning);
        dis_warn(dis_save[2],distance_warning);
     }else{
     TIM_Cmd(TIM2,DISABLE);  //DISABLE
     }
//     dis_temp=0;
//     dis_temp+=dis_save[0];
//     dis_temp+=dis_save[1];
//     dis_temp+=dis_save[2];
//     if((int)dis_temp<distance_warning*3)
//     {
//        TIM_Cmd(TIM2,ENABLE);
//        if((int)dis_temp<(distance_warning*3-20))
//         TIM2->PSC=199;
//        if((int)dis_temp<(distance_warning*3-30))
//         TIM2->PSC=71;
//     }else
//     {
//     
//      TIM_Cmd(TIM2,DISABLE);  //DISABLE
//     }
     Heart_bit++;
     delay_ms(10);   
    }
    
}
//TIM_SetCompare2(TIM1,light_table[pre_t][1]);
#include "delay.h"
#include "sys.h"
#include "usart.h"
#include "timer.h"
#include "led.h"
#include "key.h"

#define LAMP_ON   1
#define LAMP_OFF  0

void bsp_init(void);
int main(void)
{
	bsp_init();
	 
	while(1)
	{
		if(IO_LIGHT == 1) //Èõ¹â
		{
			if(IO_MAN  == 1|| IO_SOUND == 1)
			{
				sendMsgTout1 = 5000; //10s
				if(!IO_LAMP)
					IO_LAMP = LAMP_ON;
			}
		}
		else
		{
			if(IO_LAMP)
					IO_LAMP = LAMP_OFF;
		}
		
		if(sendMsgTout1 == 0) 
		{
			if(IO_LAMP)
				IO_LAMP = LAMP_OFF; //¹ØµÆ
		}
	}
}

void bsp_init(void)
{
	delay_init();	    	 //ÑÓÊ±º¯Êý³õÊ¼»¯	  
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//ÉèÖÃÖÐ¶ÏÓÅÏÈ¼¶·Ö×éÎª×é2£º2Î»ÇÀÕ¼ÓÅÏÈ¼¶£¬2Î»ÏìÓ¦ÓÅÏÈ¼¶
	TIM3_Int_Init(9,7199);//10KhzµÄ¼ÆÊýÆµÂÊ£¬¼ÆÊýµ½9,1ms½øÈëÒ»´ÎÖÐ¶Ï
	uart_init(9600);	 	//´®¿Ú³õÊ¼»¯Îª115200	 	
	IO_Init();
}


#include "stm32f10x.h"
#include "led.h"
#include "delay.h"
#include "key.h"
#include "usart.h"
#include <string.h>
#include <stdio.h>
#include <w25q128.h>
#include <lcd.h>
#include "sd.h" //SD¿¨
#include "ff.h" //ÎÄ¼þÏµÍ³
#include "vs1053b.h"
#include "exti.h"
#include "rtc.h"
#include "timer.h"
u8 ScanVSFile(const char *path);
/*
°´¼ü1 ¿ªÊ¼Â¼Òô
°´¼ü2 ½áÊøÂ¼Òô
°´¼ü3 ²¥·ÅÒôÆµ
*/
FATFS fs;  // ÓÃ»§¶¨ÒåµÄÎÄ¼þÏµÍ³½á¹¹Ìå
u8 RecoderPlay(u8 *file_name);
u8 VS1053_PlayOneMusic(u8 *pname);
u8 *VS1053_FileBuff[10];
u32  VS_Cnt=0;
int main()
{
		        //ÎÄ¼þÊýÁ¿	
	char clock_buff[1024];	//´æ·ÅÊ±¼ä×Ö·û´®
	u8 key;
	u32 sd_size;    //´æ·ÅSD¿¨·µ»ØµÄÈÝÁ¿
	BeepInit();		  //·äÃùÆ÷³õÊ¼»¯
	LedInit();      //LEDµÆ³õÊ¼»¯ 
	UsartInit(USART1,72,115200);
	KeyInit();     //°´¼ü³õÊ¼»¯
	W25Q128_Init();
	LcdInit();
	EXTI0_Init();
	TIMx_Init(TIM2,72,20000);//20ms
	RTC_Init();
	LCD_Clear(WHITE);
	
	NT35310_LCD_ShowString(0,0,16,(u8*)"´®¿Ú¹¤×÷Õý³£!");
	if(SDCardDeviceInit()) {NT35310_LCD_ShowString(0,16,16,(u8*)"SD¿¨³õÊ¼»¯Ê§°Ü!");}
	else {NT35310_LCD_ShowString(0,16,16,(u8*)"SD¿¨³õÊ¼»¯³É¹¦!");}
	sd_size=GetSDCardSectorCount();	//¼ì²âSD¿¨´óÐ¡£¬·µ»ØÖµÓÒÒÆ11Î»µÃµ½ÒÔMÎªµ¥Î»µÄÈÝÁ¿
	sprintf(clock_buff,"SD¿¨ÈÝÁ¿:%d MB",sd_size>>11);
	NT35310_LCD_ShowString(0,32,16,(u8*)clock_buff);
	
  if(f_mount(&fs,"0:",1)==FR_OK)NT35310_LCD_ShowString(0,48,16,(u8*)"ÎÄ¼þÏµÍ³³õÊ¼»¯³É¹¦!");  // ×¢²áÎÄ¼þÏµÍ³¹¤×÷Çø£¬Çý¶¯Æ÷ºÅ 0£¬³õÊ¼»¯ºóÆäËûº¯Êý¿ÉÊ¹ÓÃÀïÃæµÄ²ÎÊý
	else NT35310_LCD_ShowString(0,48,16,(u8*)"ÎÄ¼þÏµÍ³³õÊ¼»¯Ê§°Ü!");
	DelayMs(3000);
	LCD_Clear(WHITE);
	VS1053_Init();       					//VS1053³õÊ¼»¯
	while(1)
	{	
			
			if(VS_Start)	 // key interrupt for record
			{
				LCD_Clear(WHITE);
				sprintf(clock_buff,"%d%d%d%d.wav",rtc_clock.day,rtc_clock.hour,rtc_clock.minue,rtc_clock.second);
				NT35310_LCD_ShowString(0,0,16,(u8*)"ÕýÔÚÂ¼ÒôÖÐ............");
				NT35310_LCD_ShowString(0,16,16,(u8*)"Â¼ÒôÃû³Æ£º");
				NT35310_LCD_ShowString(80,16,16, (u8*)clock_buff);
				RecoderPlay((u8*)clock_buff);
				ScanVSFile("0:");
				DelayMs(500);
				LCD_Clear(WHITE);
			}	
		
			key=GetKeyValue(1);
			if(key==1) 
			{
				LCD_Clear(WHITE);
				NT35310_LCD_ShowString(0,0,16,(u8*)"²¥·ÅÂ¼ÒôÖÐ............");
				NT35310_LCD_ShowString(0,16,16,(u8*)"Â¼ÒôÃû³Æ£º");
				NT35310_LCD_ShowString(80,16,16,(u8*)VS1053_FileBuff[VS_Cnt]);
				printf("%s\r\n",VS1053_FileBuff[VS_Cnt]);
				VS1053_PlayOneMusic(VS1053_FileBuff[VS_Cnt]);
				if(VS_Cnt == 0)
				{
					NT35310_LCD_ShowString(0,0,32,(u8*)"ÕâÊÇµÚÒ»Ê×Â¼Òô............");
					VS_Cnt++;
				}
				VS_Cnt--;
				DelayMs(500);
				LCD_Clear(WHITE);
			}
			else if(key==3)
			{
				LCD_Clear(WHITE);
				NT35310_LCD_ShowString(0,00,16,(u8*)"²¥·ÅÂ¼ÒôÖÐ............");
				NT35310_LCD_ShowString(0,16,16,(u8*)"Â¼ÒôÃû³Æ£º");
				NT35310_LCD_ShowString(80,16,16,(u8*)VS1053_FileBuff[VS_Cnt]);
				printf("%s\r\n",VS1053_FileBuff[VS_Cnt]);
				if(VS_Cnt>10)
				{
					NT35310_LCD_ShowString(0,32,16,(u8*)"ÕâÊÇ×îºóÒ»Ê×Â¼Òô............");
					VS_Cnt--;
				}
				 VS1053_PlayOneMusic(VS1053_FileBuff[VS_Cnt]);
				 VS_Cnt++;
				 DelayMs(500);
				 LCD_Clear(WHITE);
			}	
			
			LED1=!LED1;
			DelayMs(200);
			if(Flag_RX1)
			{
					if(buff[0]=='*')
					{
							rtc_clock.year=(buff[1]-48)*1000+(buff[2]-48)*100+(buff[3]-48)*10+(buff[4]-48)*1;
							rtc_clock.month=(buff[5]-48)*10+(buff[6]-48)*1;
							rtc_clock.day=(buff[7]-48)*10+(buff[8]-48)*1;
							rtc_clock.hour=(buff[9]-48)*10+(buff[10]-48)*1;
							rtc_clock.minue=(buff[11]-48)*10+(buff[12]-48)*1;
							rtc_clock.second=(buff[13]-48)*10+(buff[14]-48)*1;
							time_transfor(rtc_clock.year,rtc_clock.month,rtc_clock.day,rtc_clock.hour,rtc_clock.minue,rtc_clock.second);	
					}
					Flag_RX1=0;
					cnt_RX1=0;
					
			}
			sprintf(clock_buff,"%dÄê%dÔÂ%dÈÕ%dÊ±%d·Ö%dÃë",rtc_clock.year,rtc_clock.month,rtc_clock.day,rtc_clock.hour,rtc_clock.minue,rtc_clock.second);
			NT35310_LCD_ShowString(0,0,16, (u8*)clock_buff);
		
			

			
	}
}


/*
º¯Êý¹¦ÄÜ£ºÂ¼Òô
²Î    Êý£ºÂ¼ÒôÎÄ¼þµÄÃû³Æ
*/
u8 RecoderPlay(u8 *file_name)
{
	u8 recagc=4,res;											//Ä¬ÈÏÔöÒæÎª4
	u32 cnt;
	u16 w;
	u32 sectorsize=0;
	u8 recbuf[512];													 //Êý¾ÝÄÚ´æ
	u16 idx=0;
	__WaveHeader wavhead;
	FIL f_rec;															  //Â¼ÒôÎÄ¼þ
	VS1053_RecoderInit(1024);			            //¼¤»îPCM Â¼ÒôÄ£Ê½
	VS1053_RecoderWavInit(&wavhead);				  //³õÊ¼»¯wavÊý¾Ý	
	res=f_open(&f_rec,(const TCHAR*)file_name, FA_CREATE_ALWAYS | FA_WRITE);  //´´½¨´æ·ÅÂ¼ÒôµÄÎÄ¼þ
	if(res){printf("Â¼ÒôÎÄ¼þ´´½¨Ê§°Ü!\r\n");return 0;}
	else printf("Â¼ÒôÎÄ¼þ %s ´´½¨³É¹¦!\r\n",file_name);
	res=f_write(&f_rec,(const void*)&wavhead,sizeof(__WaveHeader),&cnt);      //Ð´ÈëÍ·Êý¾Ý		 //Ð´ÈëÍ·Êý¾Ý
	while(1)
	{
			//¶ÁÈ¡Êý¾Ý			  
			w=VS1053_ReadReg(SPI_HDAT1);	
			if((w>=256)&&(w<896))
			{
				idx=0;				   	 
				while(idx<512) 	//Ò»´Î¶ÁÈ¡512×Ö½Ú
				{	 
					w=VS1053_ReadReg(SPI_HDAT0);				   	    
					recbuf[idx++]=w&0XFF;
					recbuf[idx++]=w>>8;
				}	  		 
				res=f_write(&f_rec,recbuf,512,&cnt);//Ð´ÈëÎÄ¼þ ,Ð´Èë512×Ö½Ú
				if(res)
				{
					printf("Ð´Èë³ö´í.!\r\n");
					break;  
				}
				sectorsize++;//ÉÈÇøÊýÔö¼Ó1,Ô¼Îª32ms	 
			}
      if(VS1053_OK)  //½áÊøÂ¼Òô
			{
					wavhead.riff.ChunkSize=sectorsize*512+36;	//Õû¸öÎÄ¼þµÄ´óÐ¡-8;
					wavhead.data.ChunkSize=sectorsize*512;		//Êý¾Ý´óÐ¡
					f_lseek(&f_rec,0);							//Æ«ÒÆµ½ÎÄ¼þÍ·.
					f_write(&f_rec,(const void*)&wavhead,sizeof(__WaveHeader),&cnt);//Ð´ÈëÍ·Êý¾Ý
					f_close(&f_rec);
					sectorsize=0;
					printf("½áÊøÂ¼Òô!\r\n");
					break;
			}				
		}	
		
		VS1053_OK=0;
		VS_Start=0;
		return res;
		
}


//²¥·ÅÒôÆµ				     	   									    	 
//·µ»ØÖµ:0,Õý³£²¥·ÅÍê³É
u8 VS1053_PlayOneMusic(u8 *pname)
{	 
 	FIL fmp3;
  u16 br;
	u8 res,rval;	  
	u8 databuf[4096];	   		   
	u16 i=0;

	printf("VS1053_Reset=%d\r\n",VS1053_Reset());      								//Ó²¸´Î»MP3
	VS1053_SoftReset(); 								//Èí¸´Î»VS10XX
	VS1053_SetVol(250);								  //ÉèÖÃÒôÁ¿
	
	res=f_open(&fmp3,(const TCHAR*)pname,FA_READ);//´ò¿ªÎÄ¼þ	 
	if(res!=0)return 1;  //ÎÄ¼þ´ò¿ªÊ§°Ü 
	printf("%sÎÄ¼þ´ò¿ª³É¹¦!\r\n",pname);				   
	while(1)
	{
		res=f_read(&fmp3,databuf,4096,(UINT*)&br);//¶Á³ö4096¸ö×Ö½Ú  
		i=0;
		while(i<4096) //Ã¿´Î²¥·Å4096¸ö×Ö½Ú
		{  	
				if(VS1053_SendMusicData(databuf+i)==0)//¸øVS10XX·¢ËÍÒôÆµÊý¾Ý
				{
					i+=32;
				}
		}
		if(br!=4096||res!=0)
		{
			rval=0;
			break;//¶ÁÍêÁË.		  
		} 							 
	}
	f_close(&fmp3);	  
	return rval;	  	 		  	    
}

/*
º¯Êý¹¦ÄÜ£ºÉ¨ÃèÂ¼Òô¸ùÄ¿Â¼
º¯Êý·µ»ØÖµ£º0 ±íÊ¾³É¹¦ 1£º±íÊ¾Ê§°Ü
*/
u8 ScanVSFile(const char *path)
{
		int i=0;
		DIR dp;
		FRESULT res;
		FILINFO fno; 
		char *abs_path=NULL; 
		/*1.´ò¿ªÄ¿Â¼*/
		res=f_opendir(&dp,path);
		if(res!=FR_OK) return 1;
	
		/*Ñ­»·¶ÁÈ¡Ä¿Â¼*/
		while(f_readdir(&dp,&fno)==FR_OK)
		{
		
			if(fno.fname[0]==0)break;
			printf("ÎÄ¼þÃû³Æ: %s,ÎÄ¼þ´óÐ¡: %ld ×Ö½Ú\r\n",fno.fname,fno.fsize);
			/*2.¹ýÂËÄ¿Â¼*/
			if(strstr(fno.fname,".wav"))
			{
					
					//ÉêÇë´æ·ÅÎÄ¼þÃû³Æ³¤¶ÈµÄ¿Õ¼ä
					abs_path=malloc(strlen(fno.fname)+1);
			 
					if(abs_path==NULL)break;
			
					strcpy(abs_path,fno.fname);
					VS1053_FileBuff[i++]=(u8*)abs_path;
					if(i>10)i=0;
				
		   }
	}
				f_closedir(&dp);
				return 0;
}
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "LCD1602.h"
#include "usart2.h"
#include "AS608.h"
#include "timer.h"
#include "beep.h"
#include "rtc.h"
#include "date.h"
#include "stm32f10x.h"
#include "stm32f10x_rtc.h"
#include "AT24CXX.h"
#include "iic.h"

#define usart2_baund  57600//´®¿Ú2²¨ÌØÂÊ£¬¸ù¾ÝÖ¸ÎÆÄ£¿é²¨ÌØÂÊ¸ü¸Ä£¨×¢Òâ£ºÖ¸ÎÆÄ£¿éÄ¬ÈÏ57600£©
SysPara AS608Para;//Ö¸ÎÆÄ£¿éAS608²ÎÊý
u16 ValidN;//Ä£¿éÄÚÓÐÐ§Ä£°å¸öÊý
u8** kbd_tbl;

u32 timedata=0;

void Add_FR(u8 a);	//Â¼Ö¸ÎÆ
void Del_FR(u8 a);	//É¾³ýÖ¸ÎÆ
void press_FR(void);//Ë¢Ö¸ÎÆ
void ShowErrMessage(u8 ensure);//ÏÔÊ¾È·ÈÏÂë´íÎóÐÅÏ¢

int d=0;  //É¾³ýÖ¸ÎÆÊ±ÓÃµÄID²ÎÊý
int get_d=0;  //·µ»Ø¸øQTµÃÖ¸ÎÆID

u8 num = 1; //×¢²áID
u8 num_24C02 = 0; //±£´æµØÖ·

int KeyVal;	 //keyVal?????????
int key_number = 0; 
struct rtc_time systmtime;	

unsigned char pass[6] = {1,2,3,4,5,6};
unsigned char in_key[6];			//ÊäÈëÃÜÂë

u16 nao_hour_start = 0;
u16 nao_min_start = 0;

u16 nao_hour_stop = 0;
u16 nao_min_stop = 0;

u8 number = 0; //Ö¸ÎÆ±àºÅ
void GPIO_Configuration(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;
  	
	SystemInit();

	//GPIOÊäÈëÅäÖÃ
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);

	GPIO_InitStructure.GPIO_Pin= GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_9|GPIO_Pin_10;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING;
//	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_Init(GPIOA,&GPIO_InitStructure);
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);	
	GPIO_InitStructure.GPIO_Pin= GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_Init(GPIOA,&GPIO_InitStructure);
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);	
	GPIO_InitStructure.GPIO_Pin= GPIO_Pin_0;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_Init(GPIOB,&GPIO_InitStructure);
}

int key_down(void)  //???????????,??????,???????????
{
	KeyVal = 99;

	GPIO_ResetBits(GPIOA,GPIO_Pin_7); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_6); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_5); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_4); //????? 

	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9)==0)
	{
		 KeyVal = 15;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10)==0)
	{
		 KeyVal = 14;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1)==0)
	{
		 KeyVal = 13;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)==0)
	{
		 KeyVal = 12;
	}

	GPIO_SetBits(GPIOA,GPIO_Pin_7); //????? 
	GPIO_ResetBits(GPIOA,GPIO_Pin_6); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_5); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_4); //????? 

	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9)==0)
	{
		 KeyVal = 11;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10)==0)
	{
		 KeyVal = 10;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1)==0)
	{
		 KeyVal = 9;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)==0)
	{
		 KeyVal = 8;
	}

	GPIO_SetBits(GPIOA,GPIO_Pin_7); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_6); //????? 
	GPIO_ResetBits(GPIOA,GPIO_Pin_5); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_4); //????? 

	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9)==0)
	{
		 KeyVal = 7;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10)==0)
	{
		 KeyVal = 6;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1)==0)
	{
		 KeyVal = 5;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)==0)
	{
		 KeyVal = 4;
	}

	GPIO_SetBits(GPIOA,GPIO_Pin_7); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_6); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_5); //????? 
	GPIO_ResetBits(GPIOA,GPIO_Pin_4); //????? 

	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9)==0)
	{
		 KeyVal = 3;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10)==0)
	{
		 KeyVal = 2;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1)==0)
	{
		 KeyVal = 1;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)==0)
	{
		 KeyVal = 0;
	}
//	GPIO_Write(GPIOA,(GPIOA->ODR & 0xff0f | 0x00f0)); //?PB8?PB11?????,???????????
//	while((GPIOA->IDR & 0x000f) != 0x0000);        //??????????
	if(KeyVal!=99)
	{
		GPIO_SetBits(GPIOB,GPIO_Pin_0); //????? 
		delay_ms(200); 
		GPIO_ResetBits(GPIOB,GPIO_Pin_0); //????? 
		switch(KeyVal)
		{	
			case 0:	 KeyVal = 12;
				break;
			case 1:	 KeyVal = 3;
				break;
			case 2:	 KeyVal = 2;
				break;
			case 3:	 KeyVal = 1;
				break;
			case 4:	 KeyVal = 13;
				break;
			case 5:	 KeyVal = 6;	
				break;		 	
			case 6:	 KeyVal = 5;
				break;
			case 7:	 KeyVal = 4;
				break;
			case 8:	 KeyVal = 14;
				break;
			case 9:	 KeyVal = 9;
				break;		  
			case 10: KeyVal = 8;
				break;
			case 11: KeyVal = 7;
				break;
			case 12: KeyVal = 15;
				break;
			case 13: KeyVal = 11;
				break;
			case 14: KeyVal = 0;
				break;
			case 15: KeyVal = 10;
				break;
		}
	}
	return KeyVal;		
}

//ÐÞ¸ÄÊ±¼ä
void RTC_TimeAdjust(void)
{
  /* Wait until last write operation on RTC registers has finished */
  RTC_WaitForLastTask();

  RTC_SetCounter(mktimev(&systmtime));
  /* Wait until last write operation on RTC registers has finished */
  RTC_WaitForLastTask();
}


void set_time()
{
	int time_flag =0; 			//????????

			//?
					
			LCD_Write_Com(0x80); 
			LCD_Write_Data(systmtime.tm_year/1000+'0');
			LCD_Write_Data((systmtime.tm_year%1000)/100+'0');
			LCD_Write_Data(systmtime.tm_year%100/10+'0');
			LCD_Write_Data(systmtime.tm_year%10+'0');   //?lcd1602????

			time_flag =0; 
			for(;;)
			{				
				LCD_Write_Com(0x80);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_year = time_flag*1000;
					break;
				}	
		   }
			
			for(;;)
			{
				LCD_Write_Com(0x81);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_year += time_flag*100;
					break;
				}	
			}

			for(;;)
			{
				LCD_Write_Com(0x82);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_year += time_flag*10;
					break;
				}	
			}

			for(;;)
			{
				LCD_Write_Com(0x83);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_year += time_flag;

					if(systmtime.tm_year>=2099)	   //?????
						systmtime.tm_year = 2099;
					else if(systmtime.tm_year<=1970)
						systmtime.tm_year = 1970;	
					break;
				}	
			}
			//?
			LCD_Write_Com(0x85);  //????
			LCD_Write_Data(systmtime.tm_mon%100/10+'0');
			LCD_Write_Data(systmtime.tm_mon%10+'0');   //?lcd1602????

			for(;;)
			{
				LCD_Write_Com(0x85);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	

				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_mon = time_flag * 10;
					break;
				}	
			}
			//time_flag = Time_1[4]&0x0f;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0x86);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_mon += time_flag;
					if(systmtime.tm_mon>=12)	   //???
						systmtime.tm_mon = 12;
					break;
				}	
			}

			LCD_Write_Com(0x88);  //????
			LCD_Write_Data(systmtime.tm_mday%100/10+'0');
			LCD_Write_Data(systmtime.tm_mday%10+'0');   //?lcd1602????
			//?
			time_flag = systmtime.tm_mday;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0x88);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	

				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_mday = time_flag * 10;
					break;
				}	
			}


			//time_flag = Time_1[4]&0x0f;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0x89);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(key_number + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_mday += time_flag;
					if(systmtime.tm_mday>=31)	   //???
						systmtime.tm_mday = 31;
					break;
				}	
			}

			//?
			LCD_Write_Com(0xc2);  //????
			LCD_Write_Data(systmtime.tm_hour%100/10+'0');
			LCD_Write_Data(systmtime.tm_hour%10+'0');   //?lcd1602????
			for(;;)
			{
				LCD_Write_Com(0xc2);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	

				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_hour = time_flag * 10;
					break;
				}	
			}
			//time_flag = Time_1[4]&0x0f;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0xc3);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_hour += time_flag;
					if(systmtime.tm_hour>=23)	   //????
						systmtime.tm_hour = 23;
					break;
				}	
			}


			//?
			LCD_Write_Com(0xc5);  //????
			LCD_Write_Data(systmtime.tm_min%100/10+'0');
			LCD_Write_Data(systmtime.tm_min%10+'0');   //?lcd1602????
			for(;;)
			{
				LCD_Write_Com(0xc5);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	

				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_min = time_flag * 10;

					break;
				}	
			}
			//time_flag = Time_1[4]&0x0f;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0xc6);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_min+= time_flag;
					if(systmtime.tm_min>=59)	   //????
						systmtime.tm_min = 59;
					break;
				}	
			}
			//sec
			LCD_Write_Com(0xc8);  //????
			LCD_Write_Data(systmtime.tm_sec%100/10+'0');
			LCD_Write_Data(systmtime.tm_sec%10+'0');   //?lcd1602????
			for(;;)
			{
				LCD_Write_Com(0xc8);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	

				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_sec = time_flag * 10;
					break;
				}	
			}
			//time_flag = Time_1[4]&0x0f;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0xc9);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_sec+= time_flag;
					if(systmtime.tm_sec>=59)	   //???
						systmtime.tm_sec = 59;
					break;
				}	
			}

			//xing?
			LCD_Write_Com(0xc0);  //????
			LCD_Write_Data(systmtime.tm_wday%10+'0');   //?lcd1602????
			for(;;)
			{
				LCD_Write_Com(0xc0);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_wday = time_flag;
					if(systmtime.tm_wday>=7)	   //????
						systmtime.tm_wday = 7;
					break;
				}	
			}
				
			RTC_TimeAdjust();//????
}
void set_nao()
{

	int time_flag =0; 			//????????

		LCD_Write_Com(0x8b);
		LCD_Write_Data('0'+ nao_hour_start/10);
		LCD_Write_Data('0'+ nao_hour_start%10);
		LCD_Write_Data(':');
		LCD_Write_Data('0'+ nao_min_start/10);
		LCD_Write_Data('0'+ nao_min_start%10);
		delay_ms(200);	

				
		for(;;)		 //???? ??
		{

			key_number = key_down();	  //????
			LCD_Write_Com(0x8b);  //????	 
			LCD_Write_Com(0x0e);  //??
			delay_ms(200);	
			LCD_Write_Com(0x0c);  //??
			if(key_number<=9)
			{
				time_flag =  key_number;
				LCD_Write_Com(0x8b);
				LCD_Write_Data('0'+ time_flag);
			}
			else if(key_number==11) //#?? ??
			{
				nao_hour_start = 	time_flag*10;
				break;
			}
		}

		for(;;)		 //???? ??
		{

			key_number = key_down();	  //????
			LCD_Write_Com(0x8c);  //????	 
			LCD_Write_Com(0x0e);  //??
			delay_ms(200);	
			LCD_Write_Com(0x0c);  //??
			if(key_number<=9)
			{
				time_flag =  key_number;
				LCD_Write_Com(0x8c);
				LCD_Write_Data('0'+ time_flag);
			}
			else if(key_number==11) //#?? ??
			{
				nao_hour_start += time_flag;
				if(nao_hour_start>=23)	   //??????
					nao_hour_start = 23;
				break;
			}
		}

//		for(;;)		 //??miao
//		{

//			key_number = key_down();	  //????
//			LCD_Write_Com(0x8e);  //????	 
//			LCD_Write_Com(0x0e);  //??
//			delay_ms(200);	
//			LCD_Write_Com(0x0c);  //??
//			if(key_number<=9)
//			{					
//				time_flag =  key_number;
//				LCD_Write_Com(0x8e);
//				LCD_Write_Data('0'+ time_flag);
//			}
//			else if(key_number==11) //#?? ??
//			{
//				nao_min_start = 	time_flag*10;
//				break;
//			}
//		}

//		for(;;)		 //??? ??
//		{

//			key_number = key_down();	  //????
//			LCD_Write_Com(0x8f);  //????	 
//			LCD_Write_Com(0x0e);  //??
//			delay_ms(200);	
//			LCD_Write_Com(0x0c);  //??
//			if(key_number<=9)
//			{
//				time_flag =  key_number;
//				LCD_Write_Com(0x8f);
//				LCD_Write_Data('0'+ time_flag);
//			}
//			else if(key_number==11) //#?? ??
//			{
//				nao_min_start += time_flag;
//				if(nao_min_start>=59)	   //??????
//					nao_min_start = 59;
//				break;
//			}
//		}
//		

		LCD_Write_Com(0xcb);
		LCD_Write_Data('0'+ nao_hour_stop/10);
		LCD_Write_Data('0'+ nao_hour_stop%10);
		LCD_Write_Data(':');
		LCD_Write_Data('0'+ nao_min_stop/10);
		LCD_Write_Data('0'+ nao_min_stop%10);
		delay_ms(200);	

				
		for(;;)		 //???? ??
		{

			key_number = key_down();	  //????
			LCD_Write_Com(0xcb);  //????	 
			LCD_Write_Com(0x0e);  //??
			delay_ms(200);	
			LCD_Write_Com(0x0c);  //??
			if(key_number<=9)
			{
				time_flag =  key_number;
				LCD_Write_Com(0xcb);
				LCD_Write_Data('0'+ time_flag);
			}
			else if(key_number==11) //#?? ??
			{
				nao_hour_stop = 	time_flag*10;
				break;
			}
		}

		for(;;)		 //???? ??
		{

			key_number = key_down();	  //????
			LCD_Write_Com(0xcc);  //????	 
			LCD_Write_Com(0x0e);  //??
			delay_ms(200);	
			LCD_Write_Com(0x0c);  //??
			if(key_number<=9)
			{
				time_flag =  key_number;
				LCD_Write_Com(0xcc);
				LCD_Write_Data('0'+ time_flag);
			}
			else if(key_number==11) //#?? ??
			{
				nao_hour_stop += time_flag;
				if(nao_hour_stop>=23)	   //??????
					nao_hour_stop = 23;
				break;
			}
		}

//		for(;;)		 //??miao
//		{

//			key_number = key_down();	  //????
//			LCD_Write_Com(0xce);  //????	 
//			LCD_Write_Com(0x0e);  //??
//			delay_ms(200);	
//			LCD_Write_Com(0x0c);  //??
//			if(key_number<=9)
//			{					
//				time_flag =  key_number;
//				LCD_Write_Com(0xce);
//				LCD_Write_Data('0'+ time_flag);
//			}
//			else if(key_number==11) //#?? ??
//			{
//				nao_min_stop = 	time_flag*10;
//				break;
//			}
//		}

//		for(;;)		 //??? ??
//		{

//			key_number = key_down();	  //????
//			LCD_Write_Com(0xcf);  //????	 
//			LCD_Write_Com(0x0e);  //??
//			delay_ms(200);	
//			LCD_Write_Com(0x0c);  //??
//			if(key_number<=9)
//			{
//				time_flag =  key_number;
//				LCD_Write_Com(0xcf);
//				LCD_Write_Data('0'+ time_flag);
//			}
//			else if(key_number==11) //#?? ??
//			{
//				nao_min_stop += time_flag;
//				if(nao_min_stop>=59)	   //??????
//					nao_min_stop = 59;
//				break;
//			}
//		}
}


//·äÃùÆ÷ÏìÒ»Éù
void beep()
{
		 GPIO_SetBits(GPIOB,GPIO_Pin_0); //·äÃùÆ÷±¨¾¯
		 delay_ms(200); 			//ÑÓÊ±200ms
		 GPIO_ResetBits(GPIOB,GPIO_Pin_0);
		 delay_ms(200); 			//ÑÓÊ±200ms			
}


void set_number()
{
	  char num_flag = 0;
	 	LCD_Write_Com(0xc0);  //??
		LCD_Write_Data('N');
		LCD_Write_Data('u');
		LCD_Write_Data('m');
		LCD_Write_Data('b');
		LCD_Write_Data('e');
		LCD_Write_Data('r');
		LCD_Write_Data(' ');
		LCD_Write_Data('>');
		LCD_Write_Data('0'+number%100/10);
		LCD_Write_Data('0'+number%10);			

	for(;;)
	{
		key_number = key_down();	  //????
		LCD_Write_Com(0xc8);  //????	 
		LCD_Write_Com(0x0e);  //??
		delay_ms(100); 
		LCD_Write_Com(0x0c);  //??	
     delay_ms(100); 		
		if(key_number <= 9)   //????????
		{  
			 num_flag =  key_number;
			 LCD_Write_Com(0xc8);  //????
			 LCD_Write_Data('0'+key_number);
		}
		if(key_number==11) //#??
		{
			 number = num_flag*10;
			 break;
		}
	}

	for(;;)
	{
			key_number = key_down();	  //????
			LCD_Write_Com(0xc9);  //????	 
			LCD_Write_Com(0x0e);  //??
			delay_ms(100); 
			LCD_Write_Com(0x0c);  //??	
			delay_ms(100); 		
		
			if(key_number <= 9)   //????????
			{  
				 num_flag =  key_number;
				 LCD_Write_Com(0xc9);  //????
				 LCD_Write_Data('0'+key_number);
			}
			if(key_number==11) //#??
			{
				 number += num_flag;
				 break;
			}
	}

	LCD_Write_Com(0x01); 
}

void set_zhuce(u8 a)
{
		if(a==0)
		{
				
			LCD_Write_Com(0x80);  
			LCD_Write_Data('z');
			LCD_Write_Data('h');
			LCD_Write_Data('u');
			LCD_Write_Data(' ');
			LCD_Write_Data('c');
			LCD_Write_Data('e');
			
		}
		else if(a==1)
		{
			LCD_Write_Com(0x80);  
			LCD_Write_Data('D');
			LCD_Write_Data('e');
			LCD_Write_Data('l');
			LCD_Write_Data('e');
			LCD_Write_Data('t');
			LCD_Write_Data('e');
		}	
		set_number();
}


void time_display()
{

	LCD_Write_Com(0x80);  //LCD1602??????
	LCD_Write_Data('0' + (systmtime.tm_year%10000)/1000);
	LCD_Write_Data('0' + (systmtime.tm_year%1000)/100);
	LCD_Write_Data('0'+(systmtime.tm_year%100)/10);
	LCD_Write_Data('0'+systmtime.tm_year%10);
	LCD_Write_Data('-');
	LCD_Write_Data('0'+systmtime.tm_mon/10);
	LCD_Write_Data('0'+systmtime.tm_mon%10);
	LCD_Write_Data('-');
	LCD_Write_Data('0'+systmtime.tm_mday/10);
	LCD_Write_Data('0'+systmtime.tm_mday%10);
	LCD_Write_Data(' ');	

							
	LCD_Write_Com(0xC0);	//LCD1602
	if(systmtime.tm_wday==0)
	{
			LCD_Write_Data('7');
	}
	else
	{
			LCD_Write_Data('0'+ systmtime.tm_wday);
	}
	LCD_Write_Data(' ');
	LCD_Write_Data('0'+systmtime.tm_hour/10);
	LCD_Write_Data('0'+systmtime.tm_hour%10);
	LCD_Write_Data(':');
	LCD_Write_Data('0'+systmtime.tm_min/10);
	LCD_Write_Data('0'+systmtime.tm_min%10);
	LCD_Write_Data(':');
	LCD_Write_Data('0'+systmtime.tm_sec/10);
	LCD_Write_Data('0'+systmtime.tm_sec%10);
	LCD_Write_Data(' ');

}


void RTC_IRQHandler()	//RTCÊµÊ±Ê±ÖÓ
{
	if(RTC_GetITStatus((RTC_IT_SEC))!=RESET)
	{
		RTC_ClearITPendingBit(RTC_IT_SEC);
		timebz=1;	
	}
}

//¶ÁÈ¡24c02´æ´¢ÐÅÏ¢
void read_24C02()				 //??24C02????
{
	u8 i = 0; //??forÑ­»·
	u8 read_num = 0;
	for(i=0;i<10;i++)
	{
	 	systmtime.tm_year = At24c02Read(0 + 8*i)+1970;	delay_ms(1);	
		systmtime.tm_wday = At24c02Read(1 + 8*i);	delay_ms(1);	
		systmtime.tm_mon = At24c02Read(2 + 8*i);		delay_ms(1);	
		systmtime.tm_mday= At24c02Read(3 + 8*i);	delay_ms(1);	
		systmtime.tm_hour = At24c02Read(4 + 8*i);	delay_ms(1);		
		systmtime.tm_min = At24c02Read(5 + 8*i);	delay_ms(1);	
		systmtime.tm_sec = At24c02Read(6 + 8*i);	delay_ms(1);	
		read_num = At24c02Read(7 + 8*i);	delay_ms(1);		
		time_display();
	 	LCD_Write_Com(0x8c);
		LCD_Write_Data('0'+i%10);
		LCD_Write_Data(' ');
	 	LCD_Write_Data(' ');
	 	LCD_Write_Com(0xcc);
		LCD_Write_Data('0'+ read_num/10);
		LCD_Write_Data('0'+ read_num%10);
		if(systmtime.tm_hour<nao_hour_start)
		{
			LCD_Write_Com(0x8F);	//LCD1602
			LCD_Write_Data('A');						
		}
		else if((systmtime.tm_hour>=nao_hour_start)&&(systmtime.tm_hour<12))
		{
			LCD_Write_Com(0x8F);	//LCD1602
			LCD_Write_Data('B');						
		}
		else if((systmtime.tm_hour<nao_hour_stop)&&(systmtime.tm_hour>=12))
		{
			LCD_Write_Com(0x8F);	//LCD1602
			LCD_Write_Data('C');						
		}		
		else
		{
			LCD_Write_Com(0x8F);	//LCD1602
			LCD_Write_Data('D');						
		}
		delay_ms(1000);
		delay_ms(1000);
	}
	LCD_1602Clear(); //ÇåÆÁ
}

void Save_24C02(u8 a)
{
	 At24c02Write(0 + 8*num_24C02,(systmtime.tm_year-1970));
	 delay_ms(1);	
	 At24c02Write(1 + 8*num_24C02,systmtime.tm_wday);delay_ms(1);	
	 At24c02Write(2 + 8*num_24C02,systmtime.tm_mon);delay_ms(1);	
	 At24c02Write(3 + 8*num_24C02,systmtime.tm_mday);delay_ms(1);	
	 At24c02Write(4 + 8*num_24C02,systmtime.tm_hour);delay_ms(1);	
	 At24c02Write(5 + 8*num_24C02,systmtime.tm_min);delay_ms(1);	
	 At24c02Write(6 + 8*num_24C02,systmtime.tm_sec);delay_ms(1);	
	 At24c02Write(7 + 8*num_24C02,a);delay_ms(1);	

	 num_24C02++;
	 if(num_24C02>=10)
	 	num_24C02 = 0;
}

//ems????
void ems_diaplay()
{
	LCD_1602Clear();  //??

	LCD_Write_Com(0xc0);
	LCD_Write_Data('I'); 
	LCD_Write_Data('N');  
	LCD_Write_Data('P');
	LCD_Write_Data('U');  
	LCD_Write_Data('T');
	LCD_Write_Data(':'); 
}

void input_pass()
{
	 unsigned char x=0,z=0,y=0;
	 
	 ems_diaplay();
	 for(;;)
	 {

		key_number = key_down();  //????

		if(key_number <= 9)   //????????
		{  			
			LCD_Write_Com(0xc6 + z);
			LCD_Write_Data('*'); 	//acsii??*?	 
		  	in_key[z] = key_number;		//????
			z++;
		}
		
		if(key_number == 11)			 //????
		{
			for(x=0;x<6;x++)
			{
				if(pass[x] == in_key[x])
					y++;
			}
			break;	//??????
		}
	 }
	 if(y>=6)  	//????????;
	 {	 
			LCD_1602Clear();
			for(;;)
		  {
				LCD_Write_Com(0xc0);
				LCD_Write_Data('V'); 
				LCD_Write_Data('I');  
				LCD_Write_Data('P');
				LCD_Write_Data(':');  
				LCD_Write_Data(' ');
				LCD_Write_Data(' '); 
					key_number = key_down();  //¶ÁÈ¡°´¼ü
					if(key_number==10)
					{
							break;
					}
					else if(key_number==11)
					{
							time_display(); //ÏÔÊ¾Ê±¼ä
							set_time(); //ÉèÖÃÏµÍ³Ê±¼ä
						  LCD_1602Clear();
					}
					else if(key_number==12) //×¢²áÖ¸ÎÆ
					{	    
							LCD_1602Clear();	//ÇåÆÁ
							set_zhuce(0);
							Add_FR(number);		//Â¼Ö¸ÎÆ	
							LCD_1602Clear();
					}
					else if(key_number==13)  //É¾³ýÖ¸ÎÆ
					{
						LCD_1602Clear();	//ÇåÆÁ
						set_zhuce(1);
						Del_FR(number);	 //É¾³ýÖ¸ÎÆ
						LCD_1602Clear();
					}
					else if(key_number==14) 
					{
							read_24C02();
						  LCD_1602Clear();
					}
					else if(key_number==15) 
					{
							set_nao();   //ÉèÖÃ¶¨Ê±
							LCD_1602Clear();
					}
			}	

	 }

}



int main(void)
{		
 
	u8 ensure;
	delay_init();

	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//ÉèÖÃÏµÍ³ÖÐ¶ÏÓÅÏÈ¼¶·Ö×é2

	//uart_init(115200);	//³õÊ¼»¯´®¿Ú1²¨ÌØÂÊÎª115200£¬ÓÃÓÚÖ§³ÖUSMART

	usart2_init(usart2_baund);//³õÊ¼»¯´®¿Ú2,ÓÃÓÚÓëÖ¸ÎÆÄ£¿éÍ¨Ñ¶
	
	clockinit_RTC();  //³õÊ¼»¯RTCÊ±ÖÓ
	
	LCD_1602Init();  //³õÊ¼»¯lcd1602
	
	PS_StaGPIO_Init();	//³õÊ¼»¯FR¶Á×´Ì¬Òý½Å
	
	GPIO_Configuration(); //³õÊ¼»¯GPIO
	
	I2C_INIT();		 //IIC³õÊ¼»¯
	
	while(PS_HandShake(&AS608Addr))//ÓëAS608Ä£¿éÎÕÊÖ
	{
//		printf("Cannot connect with AS608!"); 
		delay_ms(200);
	//  printf("Try to connect again....");		
		delay_ms(200);	  
	}
	
  // printf("\nÍ¨Ñ¶³É¹¦\n");

	ensure=PS_ValidTempleteNum(&ValidN);//¶Á¿âÖ¸ÎÆ¸öÊý
	
//	if(ensure!=0x00)
//		 printf("´íÎó");
		  
	ensure=PS_ReadSysPara(&AS608Para);  //¶ÁAS608Ä£¿é²ÎÊý 

//	d = 1;			
//	printf("µ±Ç°ÊäÈëµÄidÎª %d\n",d);

	//Del_FR();						
	while(1)
	{			
			
			key_number = key_down();  //¶ÁÈ¡°´¼ü

			if(key_number==10)  
			{
					input_pass();  
				  LCD_1602Clear();	//ÇåÆÁ
			}

			if(timebz==1)	   //Ê±ÖÓÃëÖÐ¶Ï
			{
					timebz=0;	  //ÇåÁã

					timedata=RTC_GetCounter();//»ñÈ¡RTC¼ÆÊýÆ÷µÄÖµ

					to_tm(timedata, &systmtime); //Ê±¼ä×ª»»
					
					time_display(); //ÏÔÊ¾Ê±¼ä
			}

			if(PS_Sta)	 //¼ì²âPS_Sta×´Ì¬£¬Èç¹ûÓÐÊÖÖ¸°´ÏÂ
			{
					press_FR();//Ë¢Ö¸ÎÆ		
			}		
				
			delay_ms(100);	

		}		 
	} 	


//ÏÔÊ¾È·ÈÏÂë´íÎóÐÅÏ¢
void ShowErrMessage(u8 ensure)
{  	
//	printf("´íÎóÐÅÏ¢ ");

}

//Â¼Ö¸ÎÆ
void Add_FR(u8 a)
{
	u8 i=0,ensure ,processnum=0;
	u16 ID;
	
	while(1)
	{  
			delay_ms(50);	
		switch (processnum)
		{
			case 0:
				i++;
		   //	printf("Çë°´ÊÖÖ¸\n");
			 
			  delay_ms(50);
				ensure=PS_GetImage();
				if(ensure==0x00) 
				{	delay_ms(50);	
					ensure=PS_GenChar(CharBuffer1);//Éú³ÉÌØÕ÷
					if(ensure==0x00)
					{ delay_ms(50);
						//printf("Ö¸ÎÆÕýÈ·\n");
						beep();
						i=0;
						delay_ms(50);
						processnum=1;//Ìøµ½µÚ¶þ²½						
					}else ShowErrMessage(ensure);	
	      delay_ms(50);						
				}else ShowErrMessage(ensure);		
	      delay_ms(50);					
				break;
			
			case 1:
				i++;
				//printf("ÔÙ°´Ò»´ÎÊÖÖ¸\n");//
			  
			 delay_ms(50);
				ensure=PS_GetImage();
				if(ensure==0x00) 
				{   	delay_ms(50);	
					ensure=PS_GenChar(CharBuffer2);//Éú³ÉÌØÕ÷			
					if(ensure==0x00)
					{ 	delay_ms(50);	
					//	printf("Ö¸ÎÆÕýÈ·\n");
	        
						i=0;
						processnum=2;//Ìøµ½µÚÈý²½
					}else ShowErrMessage(ensure);	
						delay_ms(50);	
				}else ShowErrMessage(ensure);		
					delay_ms(50);	
				break;

			case 2:
				//printf("¶Ô±ÈÁ½´ÎÖ¸ÎÆ\n");//
					  
				ensure=PS_Match();
				if(ensure==0x00) 
				{	delay_ms(50);	
					//printf("Á½´ÎÖ¸ÎÆÊÇÒ»ÑùµÄ\n");//
					beep();beep();  
					processnum=3;//Ìøµ½µÚËÄ²½
				}
				else 
				{  
  					delay_ms(50);	
				//	 printf("¶Ô±ÈÊ§°Ü£¬ÇëÖØÐÂ°´ÊÖÖ¸\n");//
					
					ShowErrMessage(ensure);
					i=0;
					processnum=0;//Ìø»ØµÚÒ»²½		
				}
				delay_ms(1000);
				break;

			case 3:
				//printf("²úÉúÒ»¸öÖ¸ÎÆÄ£°å\n");//
			
				ensure=PS_RegModel();
				if(ensure==0x00) 
				{	delay_ms(50);	 
			//		printf("Éú³ÉÖ¸ÎÆÄ£°å³É¹¦\n");//
									
					processnum=4;//Ìøµ½µÚÎå²½
				}else {processnum=0;ShowErrMessage(ensure);}
				delay_ms(500);
				break;
				
			case 4:	
		
				do
				{	
					PS_ValidTempleteNum(&ValidN);//¶Á¿âÖ¸ÎÆ¸öÊý
					ID = a;
					delay_ms(50);
				}
				while(!(ID<300));//ÊäÈëDI±ØÐëÐ¡ÓÚ300
				ensure=PS_StoreChar(CharBuffer2,ID);//´¢´æÄ£°å
				delay_ms(50);
				if(ensure==0x00) 
				{			
					delay_ms(50);
			//		printf("Ìí¼ÓÖ¸ÎÆ³É¹¦\n");//
					PS_ValidTempleteNum(&ValidN);//¶Á¿âÖ¸ÎÆ¸öÊý
					d=0;
					delay_ms(50);
				//	printf("Ê£ÓàÖ¸ÎÆ¸öÊý  %d  \n",AS608Para.PS_max-ValidN);				
					 delay_ms(500);			
					beep();beep();beep();
					return ;
				}else {processnum=0;ShowErrMessage(ensure);}					
				break;				
		}
		delay_ms(800);
		if(i==5)//³¬¹ý5´ÎÃ»ÓÐ°´ÊÖÖ¸ÔòÍË³ö
		{
      // printf("Ìí¼ÓÖ¸ÎÆÊ§°Ü\n");
			break;	
		}				
	}
}
//Ë¢Ö¸ÎÆ
void press_FR(void)
{
	SearchResult seach;
	u8 ensure;

	ensure=PS_GetImage();
	if(ensure==0x00)//»ñÈ¡Í¼Ïñ³É¹¦ 
	{	
		
		ensure=PS_GenChar(CharBuffer1);
		//printf("»ñÈ¡Í¼Ïñ³É¹¦ \n");
		if(ensure==0x00) //Éú³ÉÌØÕ÷³É¹¦
		{	
			
			//printf("»ñÈ¡Í¼Ïñ³É¹¦ \n");
			ensure=PS_HighSpeedSearch(CharBuffer1,0,300,&seach);
			if(ensure==0x00)//ËÑË÷³É¹¦
			{			
			//	printf("ËÑË÷Ö¸ÎÆ³É¹¦\n ");//ËÑË÷Ö¸ÎÆ³É¹¦	

				get_d = seach.pageID;	
			//	printf(" Æ¥ÅäÖ¸ÎÆµÄID%d\n",get_d);
				LCD_Write_Com(0x8C);	//LCD1602
				LCD_Write_Data('O');
				LCD_Write_Data('K');				
				
				if(systmtime.tm_hour<nao_hour_start)
				{
					LCD_Write_Com(0x8F);	//LCD1602
					LCD_Write_Data('A');						
				}
				else if((systmtime.tm_hour>=nao_hour_start)&&(systmtime.tm_hour<12))
				{
					LCD_Write_Com(0x8F);	//LCD1602
					LCD_Write_Data('B');						
				}
				else if((systmtime.tm_hour<nao_hour_stop)&&(systmtime.tm_hour>=12))
				{
					LCD_Write_Com(0x8F);	//LCD1602
					LCD_Write_Data('C');						
				}		
				else
				{
					LCD_Write_Com(0x8F);	//LCD1602
					LCD_Write_Data('D');						
				}
				
				LCD_Write_Com(0xCC);	//LCD1602
				LCD_Write_Data('0'+ get_d/10);
				LCD_Write_Data('0'+ get_d%10);
				Save_24C02(get_d); //±£´æµØÖ·
				beep();
				delay_ms(1000);
				delay_ms(1000);
				LCD_Write_Com(0xCC);	//LCD1602
				LCD_Write_Data(' ');
				LCD_Write_Data(' ');
				LCD_Write_Com(0x8C);	//LCD1602
				LCD_Write_Data(' ');
				LCD_Write_Data(' ');
				LCD_Write_Data(' ');
				LCD_Write_Data(' ');
			}
			else 
			{				
					LCD_Write_Com(0x8b);	//LCD1602
					LCD_Write_Data('E');
					LCD_Write_Data('R');	
				  LCD_Write_Data('R');
				  LCD_Write_Data('O');
				  LCD_Write_Data('R');
					beep();beep();beep();//·äÃùÆ÷Ïì3ÏÂ
					LCD_Write_Com(0x8b);	//LCD1602
					LCD_Write_Data(' ');
					LCD_Write_Data(' ');	
				  LCD_Write_Data(' ');
				  LCD_Write_Data(' ');
				  LCD_Write_Data(' ');
			}
			//	printf("Ê§°ÜAA\n ");		
	   delay_ms(50);			
	  }
		else
			//printf("Ê§°ÜBB\n ");	
			delay_ms(50);

	}
		
}

//É¾³ýÖ¸ÎÆ
void Del_FR(u8 a)
{
	u8  ensure;
  int v;
   PS_ValidTempleteNum(&ValidN);//¶Á¿âÖ¸ÎÆ¸öÊý
			v=ValidN;		 
		ensure=PS_DeletChar(a,1);//É¾³ýµ¥¸öÖ¸ÎÆ 
	  PS_ValidTempleteNum(&ValidN);//¶Á¿âÖ¸ÎÆ¸öÊý
	if(ensure==0&&v==ValidN+1)
	{
		     // printf("É¾³ý³É¹¦"); 
	}
  else
	{	
		ShowErrMessage(ensure);	
   // printf("É¾³ýÊ§°Ü"); 

	}       
}



/**
  ******************************************************************************
  * @file    main.c
  * @author  pcf
  * @version V4.0
  * @date    2018-4-23
  * @brief   ÖÇÄÜÊÖ»·
  ******************************************************************************
  */ 

#include "stm32f10x.h"
#include "led.h"
#include "bsp_exti.h"
#include "delay.h"
#include "GY-MCU90615.h"
#include "OLED_I2C.h"
#include "bsp_adc.h"
#include "bsp_TiMbase.h" 
#include "Step_Num.h"
#include "./mpu6050/mpu6050.h"
#include "bsp_GeneralTim.h" 

extern int LED_SIGN;							//¹¦ÄÜÇÐ»»±êÖ¾	
float ADC_ConvertedValueLocal; 			// ¾Ö²¿±äÁ¿£¬ÓÃÓÚ±£´æ×ª»»¼ÆËãºóµÄµçÑ¹Öµ 	 
extern __IO unsigned char QS;       	// µ±·¢ÏÖÒ»¸ö½ÚÅÄÊ±£¬±äÎªÕæ
int sign1=0, sign2=0;
/**
  * @brief  Ö÷º¯Êý
  * @param  ÎÞ
  * @retval ÎÞ
  */ 
int main(void)
{
	int i = 0;
	/*ÏµÍ³Ê±ÖÓÉèÖÃ*/
	delay_init(72);
	
	/* LED ¶Ë¿Ú³õÊ¼»¯ */
	LED_Init();

	/*³õÊ¼»¯´®¿ÚÒ»£¬ÓÃÓÚÎÂ¶È¼ì²â£¨½ÓÊÕÊý¾Ý£©*/ 	
	Usart1_Int(115200);

	/*ÅäÖÃIIC1£¬ÓÃÓÚOLEDÏÔÊ¾ÆÁ*/
	I2C_Configuration();	

	/*³õÊ¼»¯OLED*/
	OLED_Init();											
	
	MPU6050_Init();
	
	/*µÈ´ýÄ£¿é³õÊ¼»¯Íê³É*/
	delay_ms(1);

	/*¿ª»úÏÔÊ¾*/
	LED_ON;
	for(i=0;i<4;i++)
	{
		OLED_ShowCN(22+i*16,3,i);									//²âÊÔÏÔÊ¾"ÖÇÄÜÊÖ»·"
	}
	delay_ms(3000);
	OLED_Fill(0x00);	//È«ÆÁÃð
	
	
	/*Íâ²¿ÖÐ¶Ï³õÊ¼»¯£¬ÓÃÓÚ¹¦ÄÜÇÐ»»*/
	EXTI_Key_Config(); 
	
	/*ADC ³õÊ¼»¯*/ 
	ADCx_Init();
	
	/*¶¨Ê±Æ÷³õÊ¼»¯*/
	BASIC_TIM_Init();
	
	GENERAL_TIM_Init();	

	LED_OFF;
	/* µÈ´ýÖÐ¶Ï£¬ÓÉÓÚÊ¹ÓÃÖÐ¶Ï·½Ê½£¬CPU²»ÓÃÂÖÑ¯°´¼ü */
	while(1)                            
	{
		switch(LED_SIGN%4)
		{
			/*³õÊ¼×´Ì¬*/
			case 0 :
				LED_OFF;
				OLED_Fill(0x00);	//È«ÆÁÃð
				break;
			/*¹¦ÄÜ1£º²âÁ¿Ìå±íÎÂ¶È*/
			case 1 :
				send_com(0x15);				//·¢ËÍÃüÁî
				delay_ms(1000); 				//µÈ´ýÃüÁî½ÓÊÕÍê±Ï
				temp_float();					//Êý¾Ý×ª»»
				OLED_Display_Temp();			//ÏÔÊ¾¶ÁÈ¡µÄÎÂ¶È
				break;
			/*¹¦ÄÜ2£º²âÁ¿ÐÄÂÊ*/
			case 2 :
				if (sign1 ==0)
				{
					OLED_Fill(0x00);	//È«ÆÁÃð
//					delay_ms(100); 
				}
				if (QS == 1)
				{
					sign1 = 1;
					
					OLED_Display_HeareRate();
					delay_ms(1000); 				//µÈ´ýÃüÁî½ÓÊÕÍê±Ï
					QS = 0;                    // ÏÂ´ÎÖØÐÂÉèÖÃÁ¿»¯µÄ×ÔÎÒ±êÖ¾
				}
				break;
			/*¹¦ÄÜ3£º¼Æ²½*/
			case 3 :
				
				if (sign2 == 0)
				{
					OLED_Fill(0x00);	//È«ÆÁÃð
//					delay_ms(100); 
				}
				sign2 = 1;
				OLED_Display_StepNumber();
				delay_ms(1000);
				break;
		}
		
	}
}
/*********************************************END OF FILE**********************/
#include "led.h"
#include "delay.h"
#include "sys.h"
#include "usart.h"
#include "oled.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "adc.h"
#include "DHT11.h"
extern u8 hum_set;


 int main(void)
 { 
	volatile u16 adcx;
	u8 temp,hum,buf[20],buf1[20],times;
	delay_init();	    	 //ÑÓÊ±º¯Êý³õÊ¼»¯	  
	uart_init(9600);	 	//´®¿Ú³õÊ¼»¯Îª9600
    OLED_Init();  //oled³¬ÊæÊÊ»¯  PB 3,4,5,6
    DHT11_Init();  //PB 0
    Adc_Init();  //PA1
    Relay_Init();// PB 12,13
	memset(buf,0,16);
    memset(buf1,0,16);
    Relay_Init(); 
	while(1)
	{
    
           // Relay=1;
     	adcx=Get_Adc_Average(ADC_Channel_3,10);
	    if(times>3)
        {
            times=0;
            DHT11_Read_Data(&temp,&hum);
            sprintf( buf,"T %d -- H %d",temp,hum-30);
            OLED_ShowString(5,0,buf); 
            sprintf(buf,"ADC %d ",adcx);
            OLED_ShowString(5,20,buf);
            memset(buf,0,16);            
            OLED_Refresh_Gram();	 
                    //ÏÔÊ¾Êý¾Ý
        }
        if(hum_set>0)
        {
             if(adcx>1800+((100-hum_set)*23))  //1800  ËµÃ÷Êµ²âÒ»°ãadc ÔÚ1800 Ë®·Ö³ä×ã
            {
                Relay=0; 
                Beep=1;       //·äÃùÆ÷ ºÍ¼ÌµçÆ÷¹²ÓÃÒ»¸öIO
            }else
            {
                Relay=1;
                Beep=0;
              
            }
        }
        delay_ms(1000);
        
        times++;
	}						
 
}
					    
#include "led.h"
#include "delay.h"
#include "sys.h"
#include "usart.h"
#include "oled.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "scan.h"
extern u8 hum_set,Is_Ture;
u8 out_state[3];

/*
         1.ÏÔÊ¾ÈýÂ·³¬Éù²¨µÄ¾àÀë
         2.µÚ¶þÆÁÄ»ÉèÖÃ ±¨¾¯¾àÀë
*/
void Targ_GPIO()
{
    GPIO_InitTypeDef  GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_10|GPIO_Pin_1;	 //PD3,PD6ÍÆÍìÊä³ö  
 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //ÍÆÍìÊä³ö
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//ËÙ¶È50MHz
 	GPIO_Init(GPIOB, &GPIO_InitStructure);	  //³õÊ¼»¯GPIOD3,6
    
 	GPIO_ResetBits(GPIOB,GPIO_Pin_0|GPIO_Pin_10|GPIO_Pin_1);	//PD3,PD6 Êä³ö¸ß
}
extern volatile u8  TIM4_CAPTURE_STA,state;	//ÊäÈë²¶»ñ×´Ì¬		    				
extern volatile u16 TIM4_CAPTURE_VAL;	//ÊäÈë²¶»ñÖµ
float distance_circulate(u32 date,u8 state)
{
    float dis;
    if(state>0xc1)
        state=0xc1;
    date+=(state-0xc0)*65535;
    date/=2;
    dis=(date*340)/10000.0;
    return dis;
}
u8 dis_warn(float warn,u8 dis)
{
  if((u8)warn<dis)
  {
    TIM_Cmd(TIM2,ENABLE);
    TIM2->PSC=719;
    
      if((u8)warn+2<dis)
       TIM2->PSC=366;
    if((u8)warn+5<dis)
        TIM2->PSC=71;
    return 1;
  }
  return 0;
}
 int main(void)
 { 
    u32 distance[3];
    float dis_save[3];
     float dis_temp;
    u8 distance_warning=10;
	volatile u8 Key_vaule,num_pos=0;
    
	u8 buf[20],buf1[20],Is_distance_set=0,Heart_bit;
	delay_init();	    	 //ÑÓÊ±º¯Êý³õÊ¼»¯	  
	TIM4_Cap_Init(0xffff,71);
    
  //  TIM4_Int_Init(0xffff,71);
    Key_GPIO_Init();  // PA 0-7
     
   // TIM4_Cap_Init(0xffff,71);          //ÈýÂ·³¬Éù²¨³õÊ¼»¯ PB 7-9
     OLED_Init();  //oled³¬ÊæÊÊ»¯  PB 3,4,5,6
    Targ_GPIO();
	memset(buf,0,16);
    memset(buf1,0,16);
    TIME_INIT(); 
    TIM_Cmd(TIM4,ENABLE ); 	//Ê¹ÄÜ¶¨Ê±Æ÷2
	while(1)
	{
      Key_vaule=Key_Scan();
        
       if(Heart_bit>100)
       {
          
 
            state=1;
            PBout(0)=1;
            delay_us(30);
            PBout(0)=0;
            TIM4_CAPTURE_VAL=0;
            while(TIM4_CAPTURE_STA<0xc0);
           out_state[0]=TIM4_CAPTURE_STA;
            distance[0]=TIM4_CAPTURE_VAL;
            TIM4_CAPTURE_STA=0; //ÖØÖÃ±êÖ¾Î»
            state=2;
            PBout(1)=1;
            delay_us(30);
            PBout(1)=0;
            TIM4_CAPTURE_VAL=0;
            while(TIM4_CAPTURE_STA<0xc0);
           out_state[1]=TIM4_CAPTURE_STA;
            distance[1]=TIM4_CAPTURE_VAL;
            TIM4_CAPTURE_STA=0;  //ÖØÖÃ±êÖ¾Î»
            state=3;
            PBout(10)=1;
            delay_us(30);
            PBout(10)=0;
            TIM4_CAPTURE_VAL=0;
           while(TIM4_CAPTURE_STA<0xc0);
           out_state[2]=TIM4_CAPTURE_STA;
           distance[2]=TIM4_CAPTURE_VAL;
           TIM4_CAPTURE_STA=0;  //ÖØÖÃ±êÖ¾Î»
       }
      if(Key_vaule=='A')  
      {
        Is_distance_set=1;
        OLED_Clear();//ÇåÆÁ ÏÔÊ¾ÉèÖÃµÄ¾àÀë
        OLED_ShowString(5,0,"setting/cm");      
        OLED_Refresh_Gram();	 
          
      }
      if(Key_vaule>='0'&&Key_vaule<='9'&&Is_distance_set==1)
      {
        buf[num_pos++]=Key_vaule;
        OLED_ShowString(5,20,buf);  //ÏÔÊ¾°´¼ü
        OLED_Refresh_Gram();
        if(num_pos>3)
            num_pos=0;
      }
      if(Key_vaule=='#'&&(Is_distance_set==1))  //ÉèÖÃ¾àÀë
      {
        Is_distance_set=0;
        if(strlen(buf)>0)
            distance_warning=atoi(buf);
        memset(buf,0,10);
        delay_ms(1000);
        OLED_Clear();
        Heart_bit=111;  //ÎªÁËµÈÏÂÄÜ¿ìËÙ¿´µ½¾àÀë
      }
     
      
     if(Heart_bit>100&&(Is_distance_set==0))
     {
        Heart_bit=0;
         sprintf(buf1,"CH1:%.1f cm",dis_save[0]=distance_circulate(distance[0],out_state[0]));               //²âÁ¿¾àÀë
         OLED_ShowString(5,0,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
         sprintf(buf1,"CH2:%.1f cm",dis_save[1]=distance_circulate(distance[1],out_state[1]));               //²âÁ¿¾àÀë
         OLED_ShowString(5,16,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
         sprintf(buf1,"CH3:%.1f cm",dis_save[2]=distance_circulate(distance[2],out_state[2]));               //²âÁ¿¾àÀë
         OLED_ShowString(5,32,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
     }
     /*-----------------Èý¸öµÈ¼¶----------------------*/
     if(dis_save[0]<distance_warning||dis_save[1]<distance_warning||dis_save[2]<distance_warning)
     {
        dis_warn(dis_save[0],distance_warning);
        dis_warn(dis_save[1],distance_warning);
        dis_warn(dis_save[2],distance_warning);
     }else{
     TIM_Cmd(TIM2,DISABLE);  //DISABLE
     }
//     dis_temp=0;
//     dis_temp+=dis_save[0];
//     dis_temp+=dis_save[1];
//     dis_temp+=dis_save[2];
//     if((int)dis_temp<distance_warning*3)
//     {
//        TIM_Cmd(TIM2,ENABLE);
//        if((int)dis_temp<(distance_warning*3-20))
//         TIM2->PSC=199;
//        if((int)dis_temp<(distance_warning*3-30))
//         TIM2->PSC=71;
//     }else
//     {
//     
//      TIM_Cmd(TIM2,DISABLE);  //DISABLE
//     }
     Heart_bit++;
     delay_ms(10);   
    }
    
}
//TIM_SetCompare2(TIM1,light_table[pre_t][1]);
#include "stm32f10x.h"
#include "led.h"
#include "key.h"
#include "sys.h"
#include "exti.h"
#include "usart.h"
#include "timer.h"
#include "delay.h"
#include <string.h>
#include "adc.h"
#include "oled.h"
#include "oledshow.h"
#include "temperature.h"
#include "mpu6050.h"
#include "step.h"

extern int BPM;          //ÐÄÂÊÖµ        

int main()
{
	Led_Init();		//³õÊ¼»¯LEDµÆ
	OLED_Init();	//³õÊ¼»¯OLED
	Usart_X_Init(USART1,72,115200);	//³õÊ¼»¯´®¿Ú1
	ADC1_Init();	//ADC³õÊ¼»¯
	TimerX_Init(TIM3,72,2000);  //¶¨Ê±ÖÜÆÚ2ms ÓÃÓÚÐÄÂÊ¼ì²â
	
	OLED_Clear();//oledÇåÆÁ
	while(1)
	{
		OLEDPag1();
	}
}


å¶è¯´æå¯¹äºæ æ¥è®²ï¼ä½¿ç¨äºå¤å°åå­ï¼å°±å ç¨å¤å°ç©çé¡µé¢ï¼è¿ä¸å æ¥è®²æ¯ä¸ä¸æ ·çã
ä¸å¤ªæ¸æ¥ä¸ºä»ä¹ä¼è¿ä¹è®¾è®¡ï¼æçæµå¯è½æä¸¤æ¹é¢çåå ï¼
1ã ç¡®å®æ²¡æåéçäºä»¶æ¥è§¦åæ æ®µåå­çåæ¶ã
2ã Linux çæ æ®µè½ç¶å¨å½æ°éåºæ¶ä¸ä¼è¢«éæ¾ï¼ä½å¨ä¸æ¬¡è¿å¥å½æ°æ¶å¯ä»¥å¤ç¨ï¼å æ­¤å¯è½
è®¤ä¸º Linux çæ æ®µåå­éæ¾é®é¢å¯¹äºæ´ä¸ªè¿ç¨çåå­ä½¿ç¨å½±åä¸å¤§ã
èå¯¹æä»¬æ¥è®²ï¼æç¨éå½å½æ°åå¨å½æ°ååéå¤§ååå­ï¼å ä¸ºé£æ¯æä»£ä»·çã
è¯´æè¯¥å­ç¬¦ä½äºå æ®µï¼ç¨åºåç°å¨æ çé¡¶é¨æ æ³ä¿å­æ°çç¯å¢åéï¼å¶ä¾¿å¨å æ®µç³è¯·äº
ä¸æ®µåå­ç¨æ¥ä¿å­ç¯å¢åéã
2ã ç¯å¢åéå­ç¬¦ä¸²æéæ°ç»çå°åä» 0xbefffeac åä¸º 0x11050ã
å ä¸ºç¯å¢åéå­ç¬¦ä¸²æéæ°ç»åå¤äºä¸ä¸ªæéï¼åæ¥çæ çé¡¶é¨å°±æ²¡æç©ºé´ä¿å­äºï¼æ
ä»¥è¿ç¨å¨å æ®µåç³è¯·äºä¸æ®µåå­ï¼ç¨æ¥ä¿å­ææçç¯å¢åéæéã
å æ­¤å¦æè¿ç¨æ°å¢ä¸ä¸ªç¯å¢åéï¼ç³»ç»å°æ¶èçåå­=4Ãç³»ç»ç¯å¢åéæ»æ°+æ°å¢ç¯å¢
åéçé¿åº¦+1ã
æä»¬å¯ä»¥éè¿ glibc çæºç ï¼æ¥è·å¾ç¸å³çä¿¡æ¯ï¼è¯¦ç»å¯ä»¥åè§/glibc/sysdeps/generic/setenv.c
ç__add_to_environ å½æ°ã
å½æä»¬æ´æ°ä¸ä¸ªç¯å¢åéæ¶ï¼libc å¹¶ä¸ä¼å»å¤æ­å¯¹åºçç¯å¢åéæ¯å¦ä¿å­å¨å ä¸­ï¼ç¶åå»è¯
å¾éæ¾å®ï¼èæ¯ç´æ¥å¦å¤åéä¸åå åå­ï¼æ¥ä¿å­æ°çç¯å¢åéå¼ï¼è¿æ¶ä¼æä¸ç¹çåå­æ³
æ¼ï¼å¥½å¨å¹¶ä¸ä¸¥éã
å®å° ELF æä»¶ä¸­æéè¦ä¿å­çä¿¡æ¯æç§ä¿¡æ¯çç±»åãæ ¼å¼çä¸åï¼åå«ä¿å­å¨æä»¶çä¸å
åºåãè¿äºåºåï¼ä¸­ææä»¬å«å®âèâï¼è±æç§°ä¹ä¸ºâsectionâãä¸ºäºè®¿é®è¿äºèåºï¼å¨ ELF
æä»¶ä¸­ååå«äºä¸ä¸ªè¿äºèåºä½ç½®çç´¢å¼ï¼èåºå¤´é¨è¡¨ section headersã
å¦ä¸ç§ä¸»è¦æ¯é¢åç¨åºçå è½½åè¿è¡ï¼ç§°ä¹ä¸ºæ§è¡è§å¾ã
å¨æ§è¡è§å¾ä¸­ï¼å®åä¼å¯¹åé¢æå°ç sectionï¼æç§è¿è¡æ¶çéè¦ï¼ååä¸ºä¸åçç»ï¼ä¸­æ
ç§°ä¹ä¸ºâæ®µâï¼è±æç§°ä¹ä¸ºâsegmentâãä¸ºäºè¯´ææ®µï¼segmentï¼ä¸èï¼sectionï¼çå³ç³»ï¼å¨
ELF æä»¶ä¸­åå¼å¥äºç¨åºå¤´é¨è¡¨ program headersã
èå¨æä»¶å¼å§å¤æ¯ä¸ä¸ª ELF å¤´é¨ï¼ELF Headerï¼
å¯ä»¥çå°ä»åæ¥ç 9172 ä¸ªå­èï¼ç¼©åå° 3628ï¼ææå¾ææ¾ï¼ä¸æ¯åã
4ã æä»¬ä½¿ç¨ readelf æ¥æ¥çä¿®æ¹åç ELF æä»¶çèçæåµã

æä»¬æåçå° section çæ°éä» 39 ä¸ªåå°å° 29 ä¸ªã
5ã æä»¬è¿å¯ä»¥æ.comment èä» ELF æä»¶ä¸­å é¤ã
>strip --remove-section=.comment hello
.bssï¼
ä¸»è¦ç¨æ¥ä¿å­æªåå§åæåå§åä¸ä¸º 0 çå¨å±åéåéæåéã
.dataï¼
ä¸»è¦ç¨æ¥ä¿å­åå§åä¸ä¸º 0 çå¨å±åéæéæåéã
ä¸ºä»ä¹åå¼æ¯å¦ä¸º 0ï¼åå¾å¦æ­¤å³é®å¢ï¼
è¿ä¸»è¦æ¯å ä¸º loader å¯ä»¥å¯¹åå¼ä¸º 0 çåééåä¸å®çä¼åæªæ½ã
å¨ g++ä¸­ï¼const å£°æçæ è¯ç¬¦ï¼å°å·æåé¨é¾æ¥å±æ§ï¼è¿æ¯ä¸ gcc æä¸åçãè¿æ ·å¨ç¼è¯
a1.c æ¶ï¼å¨å±åé m åªæ¯å¨ a1.c ä¸­çæï¼å¶ä»çç¼è¯ååï¼çä¸å°è¯¥å¨å±åé mï¼å¨ç¼è¯
a2.c æ¶ï¼ç¼è¯å¨åçæä¸ä¸ªå¨å±åé mï¼å¶åªæ¯å¨ a2.c ä¸­çæã
æä»¥ï¼æä»¬æä¼çå°å¨ç¼è¯åºæ¥ç hello ä¸­ï¼æä¸¤ä¸ªé½å« m çç¬¦å·
00008540 r m
00008544 r m
å®ä»¬æåä¸åçå°åã
ä¸ºå¼å®¹æ°æ®æ»çº¿å®½åº¦ä¸º 16 ä½çåºç¨ç³»ç»ï¼ ARM ä½ç³»ç»æé¤äºæ¯ææ§è¡æçå¾é«ç 32
ä½ ARM æä»¤éä»¥å¤ï¼åæ¶æ¯æ 16 ä½ç Thumb æä»¤éã Thumb æä»¤éæ¯ ARM æä»¤
éçä¸ä¸ªå­éï¼åè®¸æä»¤ç¼ç ä¸º 16 ä½çé¿åº¦ãä¸ç­ä»·ç 32 ä½ä»£ç ç¸æ¯è¾ï¼ Thumb æä»¤
éå¨ä¿ç 32 ä»£ç ä¼å¿çåæ¶ï¼å¤§å¤§çèçäºç³»ç»çå­å¨ç©ºé´ã
ææç Thumb æä»¤é½æå¯¹åºç ARM æä»¤ï¼èä¸ Thumb çç¼ç¨æ¨¡åä¹å¯¹åºäº ARM ç
ç¼ç¨æ¨¡åï¼å¨åºç¨ç¨åºçç¼åè¿ç¨ä¸­ï¼åªè¦éµå¾ªä¸å®è°ç¨çè§åï¼ Thumb å­ç¨åºå ARM
å­ç¨åºå°±å¯ä»¥äºç¸è°ç¨ãå½å¤çå¨å¨æ§è¡ ARM ç¨åºæ®µæ¶ï¼ç§° ARM å¤çå¨å¤äº ARM å·¥
ä½ç¶æï¼å½å¤çå¨å¨æ§è¡ Thumb ç¨åºæ®µæ¶ï¼ç§° ARM å¤çå¨å¤äº Thumb å·¥ä½ç¶æã
ä¸ ARM æä»¤éç¸æ¯è¾ï¼ Thumb æä»¤éä¸­çæ°æ®å¤çæä»¤çæä½æ°ä»ç¶æ¯ 32 ä½ï¼æä»¤
å°åä¹ä¸º 32 ä½ï¼ä½ Thumb æä»¤éä¸ºå®ç° 16 ä½çæä»¤é¿åº¦ï¼èå¼äº ARM æä»¤éçä¸äº
ç¹æ§ï¼å¦å¤§å¤æ°ç Thumb æä»¤æ¯æ æ¡ä»¶æ§è¡çï¼èå ä¹ææç ARM æä»¤é½æ¯ææ¡ä»¶æ§è¡
çï¼å¤§å¤æ°ç Thumb æ°æ®å¤çæä»¤çç®çå¯å­å¨ä¸å¶ä¸­ä¸ä¸ªæºå¯å­å¨ç¸åã
Thumb æä»¤çç¼è¯

hello.c
#include <stdlib.h>
#include <stdio.h>
int main()
{
printf("hello world!\n");
return 0;
}
ç¼è¯ï¼
#gcc -o hello -mthumb a.c
æä»¬å° a1.c ç¼è¯æ thumb æä»¤:
#gcc -o a1.o -c -mthumb a1.c
å° a2.c ç¼è¯æ ARM æä»¤ï¼
#gcc -o a2.o -c a2.c'
å°å¶é¾æ¥æä¸ä¸ªå¯æ§è¡æä»¶
#gcc -o hello a1.o a2.o
æä»¬ä¸è½½å°è®¾å¤ä¸ï¼è¿è¡ã
# ./hello

ä»ä¸é¢æä»¬å¯ä»¥çå°ï¼ä¸ºäº funca ä¸º Thumb æä»¤ï¼funcb å main ä¸º ARM æä»¤ï¼ä¸ºäºæ¯æ
ARM æä»¤å Thumb æä»¤çè°ç¨ï¼GCC åå®æçæäº 3 ä¸ªå½æ°__funcb_from_thumbã
__funcb_change_to_arm å__funca_from_armã
å¨æåºæä¸¤ç§å¶å è½½æ¹å¼ï¼
1ãéæå è½½
å¨ç¨åºç¼è¯çæ¶åå ä¸â-lâéé¡¹ï¼æå®å¶æä¾èµçå¨æåºï¼è¿ä¸ªåºçåå­å°è®°å½å¨ ELF æ
ä»¶ç.dynamic èãå¨ç¨åºè¿è¡æ¶ï¼loader ä¼é¢åå°ç¨åºæä¾èµçææå¨æåºé½å è½½å¨è¿ç¨ç©º
é´ä¸­ã
éæå è½½çä¼ç¹ï¼
å¨æåºçæ¥å£è°ç¨ç®åï¼å¯ä»¥ç´æ¥è°ç¨ã
ç¼ºç¹ï¼
å¨æåºççå­å¨æç­äºè¿ç¨ççå­å¨æï¼å¶å è½½æ¶æºä¸çµæ´»ã
2ãå¨æå è½½
æä»¬è¿å¯ä»¥å¨ç¨åºä¸­ç¼ç æ¥æå®å è½½å¨æåºçæ¶æºï¼ç»å¸¸ä½¿ç¨çå½æ° dlopen dlcloseã
å¨æå è½½çä¼ç¹ï¼
å¨æåºå è½½çæ¶æºéå¸¸çµæ´»ï¼å¯ä»¥éå¸¸ç»è´çå®ä¹å¨æåºççå­å¨æã
å¨æå è½½çç¼ºç¹:
å¨æåºçæ¥å£è°ç¨èµ·æ¥æ¯è¾éº»ç¦ï¼åæ¶è¿è¦å³æ³¨å¨æåºççå­å¨æã
>gcc âL./ -la hello.c âo hello
>gcc âshared âfPIC

a.c âo liba.so
è½ç¶æä»¬æ²¡æä½¿ç¨ bss æ°æ®ï¼ä½ç³»ç»è¿æ¯å ç¨äºç©çé¡µé¢ï¼è¿å¯è½ä¸è¿ç¨å¤å¶å±äº«åºçæ°æ®
æ®µæé æçã
å æ­¤ï¼ä¸è¦å¨è¿ç¨ä¸­éè¿ extern çæ¹å¼å¼ç¨å±äº«åºä¸­çå¨å±åéï¼ä¸æ¦å¼ç¨ï¼ä¸è®ºå¶æ¯å¦ä½¿
ç¨ï¼é½å°ä¼å ç¨ç©çåå­ãåæ¶è¿ä¼å¢å ç³»ç»å¯å¨æ¶ï¼åå­å¤å¶çä»£ä»·ï¼ä¼å¯¼è´æ§è½çä¸éã
æä»¬ä¹æ³¨æå°ï¼æ°æ®æ®µçå°åä¸å æ æ®µçå°åæ¯è¿ççï¼è¿ä¹å°±æ¯è¯´ï¼å½ä¸»ç¨åºé¾æ¥äºä¸ä¸ª
å±äº«åºçå¨å±åéæ¶ï¼å®ä¼ä¸ºè¯¥åéå®ä¹ä¸ä¸ªå°åï¼ä½å®ä¸ä¼å½±åæ°æ®æ®µçå¤§å°ï¼å°è¯¥å¼æ·
è´å°è¿ä¸ªå°åä¸ãå¦æå°åæ®µä¸å¤ç¨ï¼å®å°å ç¨å æ®µï¼ç³»ç»å°è°ç¨ brk æ¥æ©å±å æ®µã
æä»¬éè¿ strace å¯ä»¥æ¥éªè¯è¿ä¸ªè§ç¹ï¼
å æ­¤ï¼æä»¬å¯ä»¥éè¿è¿ç¨ç.rel.dyn å.rel.pltsection åå±äº«åºä¸­çç¬¦å·ï¼æ¾åºè¿ç¨ä¸å±äº«åºä¹
é´çè°ç¨å³ç³»ã
1ã å¦æå¨å±åéå£°æå¨è¿ç¨ä¸­ï¼å¨å±äº«åºä¸­ä½¿ç¨ï¼åè¯¥åéä½äºè¿ç¨çæ°æ®æ®µã
2ã å¦æå¨å±åéå£°æå¨å±äº«åºä¸­ï¼å¨è¿ç¨ä¸­ä½¿ç¨ï¼åè¯¥åéè¢«å¤å¶å°è¿ç¨çæ°æ®æ®µï¼åæ¶
ä¿®æ¹ä½¿ç¨è¯¥åéçå±äº«åºçæåã
3ã å¦æè¯¥åéå¨å±äº«åºä¸­å£°æï¼å¨å±äº«åºä¸­ä½¿ç¨ï¼åè¯¥åéä½äºå£°æå®çå±äº«åºçæ°æ®æ®µ
ä¸­ã
PIC ä½¿.so æä»¶çä»£ç æ®µåä¸ºçæ­£æä¹ä¸çå±äº«ã
å¦æä¸å -fPIC,åå è½½.so æä»¶çä»£ç æ®µæ¶,ä»£ç æ®µå¼ç¨çæ°æ®å¯¹è±¡éè¦éå®ä½, éå®ä½ä¼ä¿®æ¹
ä»£ç æ®µçåå®¹,è¿å°±é ææ¯ä¸ªä½¿ç¨è¿ä¸ª.so æä»¶ä»£ç æ®µçè¿ç¨å¨åæ ¸éé½ä¼çæè¿ä¸ª.so æä»¶
ä»£ç æ®µç copy.æ¯ä¸ª copy é½ä¸ä¸æ ·,åå³äºè¿ä¸ª.so æä»¶ä»£ç æ®µåæ°æ®æ®µåå­æ å°çä½ç½®.
æä»¬å¯ä»¥ä½¿ç¨ ulimit å½ä»¤ï¼æ¥æ¥çåè®¾ç½®ä¸ä¸ªè¿ç¨çæ ç©ºé´çå¤§å°ï¼
ä¸è¬æåµä¸ï¼ä¸ä¸ªè¿ç¨ææ¥æççº¿ç¨æ°éå¾å°ï¼å¤§æ¦ 10 ä¸ªä»¥åï¼å¦ææ¯ä¸ªçº¿ç¨çæ ä½¿ç¨ 20K
çåå­çè¯ï¼é£ä¹æ»å±æ¶è 200K çåå­ï¼å¯¹ç³»ç»çå½±åè¿æ¯å¾å°çã
æ³¨ï¼æ¯ä¸ä¸ªå±äº«åå­åºé½æä¸ä¸ªæ§å¶ç»æ struct shmid_kernelï¼shmid_kernel æ¯å±äº«åå­åºå
ä¸­éå¸¸éè¦çä¸ä¸ªæ°æ®ç»æï¼å®æ¯å­å¨ç®¡çåæä»¶ç³»ç»ç»åèµ·æ¥çæ¡¥æ¢ï¼å®ä¹å¦ä¸ï¼
æ­£å¦æ¶æ¯éååä¿¡å·ç¯ä¸æ ·ï¼åæ ¸éè¿æ°æ®ç»æ struct ipc_ids shm_ids ç»´æ¤ç³»ç»ä¸­çææå±
äº«åå­åºåãä¸å¾ä¸­ç shm_ids.entries åéæåä¸ä¸ª ipc_id ç»ææ°ç»ï¼èæ¯ä¸ª ipc_id ç»ææ°
ä¸ºä»ä¹æçç¨åºä½¿ç¨äºè¿ä¹å¤çåå­ï¼
ææ ·æ£æµåå­æ³æ¼ï¼
1ã å å¥å¤´æä»¶<mcheck.h>
2ã å¨éè¦åå­æ³æ¼æ£æ¥çä»£ç çå¼å§è°ç¨ void mtrace()ï¼å¨éè¦åå­æ³æ¼æ£æ¥ä»£ç çç»æ
è°ç¨ void muntrace()ã
ä¸è¬æåµä¸ä¸è¦è°ç¨ muntraceï¼èè®©ç¨åºèªç¶ç»æï¼å ä¸ºå¯è½æäºåå­éæ¾ä»£ç è¦å°
muntrace ä¹åè¿è¡ã
3ã ç¨ debug æ¨¡å¼ç¼è¯æ£æ¥ä»£ç ï¼-g æ-ggdbï¼
4ã å¨è¿è¡ç¨åºé±ï¼åè®¾ç½®ç¯å¢åé MALLOC_TRACE ä¸ºä¸æä»¶åï¼è¿ä¸æä»¶å°å­æåå­
åéä¿¡æ¯ã
5ã è¿è¡ç¨åºï¼åå­åéç log å°è¾åºå° MALLOC_TRACE ææåçæä»¶ä¸­ã
å¨ glibc ä¸­ï¼æä¾äº mallocãfreeãreallocãmemalign çé©å­å½æ°ã
ä½ å¯ä»¥æç§é©å­å½æ°çååï¼å®ä¹èªå·±çå½æ°ï¼å¹¶å¨ glibc ä¸­è®¾ç½®ç¸åºçé©å­å½æ°ï¼è¿æ · glibc
å¨å¤çå½æ°æ¶ï¼ä¼è°ç¨ä½ çé©å­å½æ°ï¼ä»èè·å¾ç¸åºçä¿¡æ¯ã
#! /usr/bin/perl
my $log = shift (@ARGV);
open flog ,"<$log" or die "cannot open $log:$!";
while(<flog>)
{
if(/^@@@/)
{
@items = split/\s+/;
if($items[2] eq '+')
{
$size=hex(substr($items[4],2));
$memory{$items[3]}=$size;
}
if($items[2] eq '-')
{
delete $memory{$items[3]};
}
}
}
foreach $key(sort keys %memory)
{
print "$key $memory{$key}\n";
}
4.1. gcc ä¸ g++çä¸å
gcc å g++é½æ¯ GNU çä¸ä¸ªç¼è¯å¨ã
å¾å¤äººé½è®¤ä¸º gcc åªè½ç¼è¯ C ç¨åºï¼è g++åªè½ç¼è¯ C++ä»£ç ãå®éä¸èè¿é½å¯ä»¥ã
1.åç¼ä¸º.c çï¼gcc æå®å½ä½æ¯ C ç¨åºï¼è g++å½ä½æ¯ c++ç¨åºï¼åç¼ä¸º.cpp çï¼ä¸¤èé½ä¼
è®¤ä¸ºæ¯ c++ç¨åºï¼æ³¨æï¼è½ç¶ c++æ¯ c çè¶éï¼ä½æ¯ä¸¤èå¯¹è¯­æ³çè¦æ±æ¯æåºå«çãC++ç
è¯­æ³è§åæ´å ä¸¥è°¨ä¸äºã
2.ç¼è¯é¶æ®µï¼g++ä¼è°ç¨ gccï¼å¯¹äº c++ä»£ç ï¼ä¸¤èæ¯ç­ä»·çï¼ä½æ¯å ä¸º gcc å½ä»¤ä¸è½èªå¨å
Cï¼ï¼ç¨åºä½¿ç¨çåºèæ¥ï¼æä»¥éå¸¸ç¨ g++æ¥å®æé¾æ¥ï¼ä¸ºäºç»ä¸èµ·è§ï¼å¹²èç¼è¯/é¾æ¥ç»ç»
ç¨ g++äºï¼è¿å°±ç»äººä¸ç§éè§ï¼å¥½å cpp ç¨åºåªè½ç¨ g++ä¼¼çã
å¨è¿éæä¸ç¯æç« åäºè¯¦ç»éè¿°ã
http://blog.chinaunix.net/u/30686/showart.php?id=519752
è¿éæè¦çéè¯´æçæ¯ï¼å¨ä½¿ç¨ g++ç¼è¯çæ¶åï¼æ è®ºè¿ä¸ªç¨åºæ¯å¦ä½¿ç¨äºç±»ï¼é½å°ä¼å°ä¾
èµäº C++çå¨æåºï¼libstdc++.soï¼ã
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
pause();
return 0;
}
ç¼è¯ï¼
gcc âo hello hello.c
è¿è¡
# ./hello
# cat maps

æä»¬ä¼åç° hello æä¾èµçåºå¢å äº 3 ä¸ª libstdc++.so libm.so libgcc_s.so,å¶ä¸­ libm.so å
libgcc_s.so æ¯ç± libstdc++.so å¼å¥çãä¸è¦å°çè¿ä¸ä¸ªåºï¼è¿ç¨æ¯å è½½ä¸ä¸ªåºï¼å°±è¦ä¸ºå¶å
éç¸åºçæ°æ®æ®µï¼åä¸äºéå®åå·¥ä½ç­ï¼æ¯ä¸ªåºçæ°æ®æ®µæå°è¦å æ® 4K çç©çåå­ï¼ä¹å°±
æ¯è¯´ä½¿ç¨ g++ç¼è¯åºç helloï¼è¦æ¯ä½¿ç¨ gcc ç¼è¯åºæ¥çï¼æå°åå­å¤äº 12Kã
/proc/sys/vm/pagecache
è¯¥æä»¶ä¸ /proc/sys/vm/buffermem çå·¥ä½åå®¹ä¸æ ·ï¼ä½å®æ¯éå¯¹æä»¶çåå­æ å°åä¸è¬é«é
å®ç°ä¸ä¸ªstm32h750 ADCè¿å·ææ¨¡æçé¨çåè½ï¼åè®¸ç²¾ç¡®å°çæµä¸ä¸ªæå¤ä¸ªæ¨¡æçµåï¼å½æ¨¡æçµåè¶åºå¯ç¼ç¨éå¼æ¶ä¼äº§çä¸ä¸ªä¸­æ­ã
ç¸æ¯èè¨ï¼Androidåæ´è¿ä¸æ­¥ï¼å®æ¯æå¤ä¸ªåºç¨å¥å£ç¹ï¼å¼å¥äºæ´ä¸°å¯çæºå¶ãå¨Androidç³»ç»ä¸­åå®çåææ¯ï¼ç³»ç»ä¼å¨ä¸åçå°æ¹å¯å¨å®ä»¬ï¼è¿åå³äºç¨æ·å½åæ­£å¨åªéä»¥åç¨æ·æ¥ä¸æ¥æ³åçæ¯ä»ä¹ã
å¨å¶ä¸­ä¸ä¸ªæ½è±¡å±ï¼Androidåºç¨çèµ·æ¥åWebåºç¨å¾ç¸ä¼¼ãæ´»å¨ç±»ä¼¼äºWebåºç¨ä¸­çservletãè®¾è®¡è¯å¥½çæ´»å¨è´è´£ç®¡çåä¸ªUIé¡µé¢ï¼æ¯ä¸ªUIé½æèªå·±å¯ä¸çåç§°ãç¨æ·æ ¹æ®è¿äºé¾æ¥ï¼ä»Webé¡µé¢çä¸ä¸ªé¡µé¢è·³è½¬å°å¦ä¸ä¸ªé¡µé¢ï¼èå¨Androidåºç¨ä¸­ï¼ç¨æ·äº¤äºæ¯éè¿intentè°ç¨çãæ°é¡µé¢å¯ä»¥éè¿é¾æ¥å¯¼èªå°èé¡µé¢ãæ­£å¦å¨Webåºç¨ä¸çä¸­ï¼æäºservletæä¾UIåè½ï¼å¶ä»çæä¾æå¡çAPIãå æ­¤ï¼å¨Androidä¸çä¸­ï¼æ´»å¨æä¾UIï¼èServiceåContentProviderç±»ï¼å¾å¿«ä¼ä»ç»ï¼æä¾å¯¹è¿äºæå¡çè®¿é®åè½ãçè§£è¿ç§æ¶æä¸çç¸ä¼¼æ§æå©äºååææå©ç¨Androidæ¡æ¶è®¾è®¡Androidåºç¨ã
Androidåºç¨è¿æä¸äºå¶ä»ç»ä»¶ï¼å·ä½åæ¬ï¼Serviceï¼æå¡ï¼ãContent Providerï¼åå®¹æä¾èï¼åBroadcast Receiverï¼å¹¿æ­æ¥æ¶å¨ï¼ãServiceç±»è´è´£ä¸ºåå°åè½æä¾æ¯æï¼ContentProviderç±»æ¯å¤ä¸ªåºç¨ä½¿ç¨æ°æ®å­å¨çè®¿é®æ¹å¼ï¼Broadcast Receiveræ¯æå¤æ¹æ¥æ¶åºç¨æå¹¿æ­çæå¾ä¿¡æ¯ã
æå°æä»¶çè¯»åï¼é£ä¹ä¸å¾ä¸æå°æä»¶ç³»ç»è¿ä¸ªæä½ç³»ç»ä¸­æä¸ºéè¦çç»æé¨åä¹ä¸ãæä»¶ç³»ç»ç®¡ççç£çä¸­æä»¶çå­å¨æ¹å¼ï¼æ¯å¦æä»¬å¨Linuxç³»ç»ä¸æä¸ä¸ªæä»¶â/home/user/test.datâï¼é¿åº¦ä¸º8 000ä¸ªå­èãé£ä¹æä»¬å¨åå»ºè¿ä¸ªæä»¶çæ¶åï¼Linuxçext3æä»¶ç³»ç»æå¯è½å°è¿ä¸ªæä»¶æç§è¿æ ·çæ¹å¼å­å¨å¨ç£çä¸­ï¼æä»¶çå4 096å­èå­å¨å¨ç£çç1000å·æåºå°1007å·æåºï¼æ¯ä¸ªæåº512å­èï¼8ä¸ªæåºåå¥½4 096å­èï¼æä»¶çç¬¬4 097ä¸ªå­èå°ç¬¬8 000å­èå±3 904ä¸ªå­èï¼å­å¨å¨ç£çç2000å·æåºå°2007å·æåºï¼8ä¸ªæåºä¹æ¯4 096å­èï¼åªä¸è¿åªå­å¨äº3 904ä¸ªææçå­èï¼å©ä¸ç192ä¸ªå­èæ æãå¦ææè¿ä¸ªæä»¶çå­å¨æ¹å¼çä½æ¯ä¸ä¸ªé¾ç¶çç»æï¼å®çç»æå¦å¾1-4æç¤ºã
è¿éæä»¬åç©¿æä¸ä¸ªå³äºç¡¬ççç»æä»ç»ï¼å³äºç¡¬çç»æå¯è½å¾å¤è¯»èå·²ç»æä¸ä¸ªå¤§æ¦çäºè§£ï¼é£å°±æ¯ç¡¬çåºæ¬å­å¨åä½ä¸ºæåºï¼Sectorï¼ï¼æ¯ä¸ªæåºä¸è¬ä¸º512å­èãä¸ä¸ªç¡¬çå¾å¾æå¤ä¸ªççï¼æ¯ä¸ªççåä¸¤é¢ï¼æ¯é¢æç§åå¿åååä¸ºè¥å¹²ä¸ªç£éï¼æ¯ä¸ªç£éååä¸ºè¥å¹²ä¸ªæåºãæ¯å¦ä¸ä¸ªç¡¬çæ2ä¸ªççï¼æ¯ä¸ªçé¢å65 536ç£éï¼æ¯ä¸ªç£éå1 024ä¸ªæåºï¼é£ä¹ç¡¬ççå®¹éå°±æ¯2 * 2 * 65 536 * 1 024 * 512 = 137 438 953 472å­èï¼128GBï¼ãä½æ¯æä»¬å¯ä»¥æ³è±¡ï¼æ¯ä¸ªçé¢ä¸åå¿åçå¨é¿ä¸ä¸æ ·ï¼å¦ææç§æ¯ä¸ªç£éé½æ¥æç¸åæ°éçæåºï¼é£ä¹é è¿çé¢å¤å´çç£éå¯åº¦è¯å®æ¯ååæ´å ç¨çï¼è¿æ ·æ¯æ¯è¾æµªè´¹ç©ºé´çãä½æ¯å¦æä¸åçç£éæåºæ°åä¸åï¼è®¡ç®èµ·æ¥å°±ååéº»ç¦ãä¸ºäºå±è½è¿äºå¤æçç¡¬ä»¶ç»èï¼ç°ä»£çç¡¬çæ®éä½¿ç¨ä¸ç§å«åLBAï¼Logical Block Addressï¼çæ¹å¼ï¼å³æ´ä¸ªç¡¬çä¸­ææçæåºä»0å¼å§ç¼å·ï¼ä¸ç´å°æåä¸ä¸ªæåºï¼è¿ä¸ªæåºç¼å·å«åé»è¾æåºå·ãé»è¾æåºå·æå¼äºææå¤æçç£éãçé¢ä¹ç±»çæ¦å¿µãå½æä»¬ç»åºä¸ä¸ªé»è¾çæåºå·æ¶ï¼ç¡¬çççµå­è®¾å¤ä¼å°å¶è½¬æ¢æå®éççé¢ãç£éç­è¿äºä½ç½®ã
è¿éæä»¬åç©¿æä¸ä¸ªå³äºç¡¬ççç»æä»ç»ï¼å³äºç¡¬çç»æå¯è½å¾å¤è¯»èå·²ç»æä¸ä¸ªå¤§æ¦çäºè§£ï¼é£å°±æ¯ç¡¬çåºæ¬å­å¨åä½ä¸ºæåºï¼Sectorï¼ï¼æ¯ä¸ªæåºä¸è¬ä¸º512å­èãä¸ä¸ªç¡¬çå¾å¾æå¤ä¸ªççï¼æ¯ä¸ªççåä¸¤é¢ï¼æ¯é¢æç§åå¿åååä¸ºè¥å¹²ä¸ªç£éï¼æ¯ä¸ªç£éååä¸ºè¥å¹²ä¸ªæåºãæ¯å¦ä¸ä¸ªç¡¬çæ2ä¸ªççï¼æ¯ä¸ªçé¢å65 536ç£éï¼æ¯ä¸ªç£éå1 024ä¸ªæåºï¼é£ä¹ç¡¬ççå®¹éå°±æ¯2 * 2 * 65 536 * 1 024 * 512 = 137 438 953 472å­èï¼128GBï¼ãä½æ¯æä»¬å¯ä»¥æ³è±¡ï¼æ¯ä¸ªçé¢ä¸åå¿åçå¨é¿ä¸ä¸æ ·ï¼å¦ææç§æ¯ä¸ªç£éé½æ¥æç¸åæ°éçæåºï¼é£ä¹é è¿çé¢å¤å´çç£éå¯åº¦è¯å®æ¯ååæ´å ç¨çï¼è¿æ ·æ¯æ¯è¾æµªè´¹ç©ºé´çãä½æ¯å¦æä¸åçç£éæåºæ°åä¸åï¼è®¡ç®èµ·æ¥å°±ååéº»ç¦ãä¸ºäºå±è½è¿äºå¤æçç¡¬ä»¶ç»èï¼ç°ä»£çç¡¬çæ®éä½¿ç¨ä¸ç§å«åLBAï¼Logical Block Addressï¼çæ¹å¼ï¼å³æ´ä¸ªç¡¬çä¸­ææçæåºä»0å¼å§ç¼å·ï¼ä¸ç´å°æåä¸ä¸ªæåºï¼è¿ä¸ªæåºç¼å·å«åé»è¾æåºå·ãé»è¾æåºå·æå¼äºææå¤æçç£éãçé¢ä¹ç±»çæ¦å¿µãå½æä»¬ç»åºä¸ä¸ªé»è¾çæåºå·æ¶ï¼ç¡¬çççµå­è®¾å¤ä¼å°å¶è½¬æ¢æå®éççé¢ãç£éç­è¿äºä½ç½®ã

æä»¶ç³»ç»ä¿å­äºè¿äºæä»¶çå­å¨ç»æï¼è´è´£ç»´æ¤è¿äºæ°æ®ç»æå¹¶ä¸ä¿è¯ç£çä¸­çæåºè½å¤ææå°ç»ç»åå©ç¨ãé£ä¹å½æä»¬å¨Linuxæä½ç³»ç»ä¸­ï¼è¦è¯»åè¿ä¸ªæä»¶çå4 096ä¸ªå­èæ¶ï¼æä»¬ä¼ä½¿ç¨ä¸ä¸ªreadçç³»ç»è°ç¨æ¥å®ç°ãæä»¶ç³»ç»æ¶å°readè¯·æ±ä¹åï¼å¤æ­åºæä»¶çå4 096ä¸ªå­èä½äºç£çç1000å·é»è¾æåºå°1007å·é»è¾æåºãç¶åæä»¶ç³»ç»å°±åç¡¬çé©±å¨ååºä¸ä¸ªè¯»åé»è¾æåºä¸º1000å·å¼å§ç8ä¸ªæåºçè¯·æ±ï¼ç£çé©±å¨ç¨åºæ¶å°è¿ä¸ªè¯·æ±ä»¥åå°±åç¡¬çååºç¡¬ä»¶å½ä»¤ãåç¡¬ä»¶åéI/Oå½ä»¤çæ¹å¼æå¾å¤ç§ï¼å¶ä¸­æä¸ºå¸¸è§çä¸ç§å°±æ¯éè¿è¯»åI/Oç«¯å£å¯å­å¨æ¥å®ç°ãå¨x86å¹³å°ä¸ï¼å±æ65 536ä¸ªç¡¬ä»¶ç«¯å£å¯å­å¨ï¼ä¸åçç¡¬ä»¶è¢«åéå°äºä¸åçI/Oç«¯å£å°åãCPUæä¾äºä¸¤æ¡ä¸é¨çæä»¤âinâåâoutâæ¥å®ç°å¯¹ç¡¬ä»¶ç«¯å£çè¯»ååã
? ç¬¬0x1F3ï½0x1F6 4ä¸ªå­èçç«¯å£å°åæ¯ç¨æ¥åå¥LBAå°åçï¼é£ä¹1000å·é»è¾æåºçLBAå°åä¸º0x000003E8ï¼æä»¥æä»¬éè¦å¾0x1F3ã0x1F4åå¥0x00ï¼å¾0x1F5åå¥0x03ï¼å¾0x1F6åå¥0xE8ã
? 0x1F2è¿ä¸ªå°åç¨æ¥åå¥å½ä»¤æéè¦è¯»åçæåºæ°ãæ¯å¦è¯»å8ä¸ªæåºå³åå¥8ã

? 0x1F7è¿ä¸ªå°åç¨æ¥åå¥è¦æ§è¡çæä½çå½ä»¤ç ï¼å¯¹äºè¯»åæä½æ¥è¯´ï¼å½ä»¤å­ä¸º0x20ã
æä»¥æä»¬è¦æ§è¡çæä»¤ä¸ºï¼

out 0x1F3, 0x00

out 0x1F4, 0x00

out 0x1F5, 0x03

out 0x1F6, 0xE8

out 0x1F2, 0x08

out 0x1F7, 0x20
? å°åç©ºé´ä¸éç¦» ææç¨åºé½ç´æ¥è®¿é®ç©çå°åï¼ç¨åºæä½¿ç¨çåå­ç©ºé´ä¸æ¯ç¸äºéç¦»çãæ¶æçç¨åºå¯ä»¥å¾å®¹ææ¹åå¶ä»ç¨åºçåå­æ°æ®ï¼ä»¥è¾¾å°ç ´åçç®çï¼æäºéæ¶æçãä½æ¯æè­è«çç¨åºå¯è½ä¸å°å¿ä¿®æ¹äºå¶ä»ç¨åºçæ°æ®ï¼å°±ä¼ä½¿å¶ä»ç¨åºä¹å´©æºï¼è¿å¯¹äºéè¦å®å¨ç¨³å®çè®¡ç®ç¯å¢çç¨æ·æ¥è¯´æ¯ä¸è½å®¹å¿çãç¨æ·å¸æä»å¨ä½¿ç¨è®¡ç®æºçæ¶åï¼å¶ä¸­ä¸ä¸ªä»»å¡å¤±è´¥äºï¼è³å°ä¸ä¼å½±åå¶ä»ä»»å¡ã

? åå­ä½¿ç¨æçä½ ç±äºæ²¡æææçåå­ç®¡çæºå¶ï¼éå¸¸éè¦ä¸ä¸ªç¨åºæ§è¡æ¶ï¼çæ§ç¨åºå°±å°æ´ä¸ªç¨åºè£å¥åå­ä¸­ç¶åå¼å§æ§è¡ãå¦ææä»¬å¿½ç¶éè¦è¿è¡ç¨åºCï¼é£ä¹è¿æ¶åå­ç©ºé´å¶å®å·²ç»ä¸å¤äºï¼è¿æ¶åæä»¬å¯ä»¥ç¨çä¸ä¸ªåæ³æ¯å°å¶ä»ç¨åºçæ°æ®ææ¶åå°ç£çéé¢ï¼ç­å°éè¦ç¨å°çæ¶ååè¯»åæ¥ãç±äºç¨åºæéè¦çç©ºé´æ¯è¿ç»­çï¼é£ä¹è¿ä¸ªä¾å­éé¢ï¼å¦ææä»¬å°ç¨åºAæ¢åºå°ç£çæéæ¾çåå­ç©ºé´æ¯ä¸å¤çï¼æä»¥åªè½å°Bæ¢åºå°ç£çï¼ç¶åå°Cè¯»å¥å°åå­å¼å§è¿è¡ãå¯ä»¥çå°æ´ä¸ªè¿ç¨ä¸­æå¤§éçæ°æ®å¨æ¢å¥æ¢åºï¼å¯¼è´æçååä½ä¸ã

? ç¨åºè¿è¡çå°åä¸ç¡®å® å ä¸ºç¨åºæ¯æ¬¡éè¦è£å¥è¿è¡æ¶ï¼æä»¬é½éè¦ç»å®ä»åå­ä¸­åéä¸åè¶³å¤å¤§çç©ºé²åºåï¼è¿ä¸ªç©ºé²åºåçä½ç½®æ¯ä¸ç¡®å®çãè¿ç»ç¨åºçç¼åé æäºä¸å®çéº»ç¦ï¼å ä¸ºç¨åºå¨ç¼åæ¶ï¼å®è®¿é®æ°æ®åæä»¤è·³è½¬æ¶çç®æ å°åå¾å¤é½æ¯åºå®çï¼è¿æ¶åç¨åºçéå®ä½é®é¢ï¼æä»¬å¨ç¬¬2é¨ååç¬¬3é¨åè¿ä¼è¯¦ç»æ¢è®¨éå®ä½çé®é¢ã

è§£å³è¿å ä¸ªé®é¢çæè·¯å°±æ¯ä½¿ç¨æä»¬åææå°è¿çæ³å®ï¼å¢å ä¸­é´å±ï¼å³ä½¿ç¨ä¸ç§é´æ¥çå°åè®¿é®æ¹æ³ãæ´ä¸ªæ³æ³æ¯è¿æ ·çï¼æä»¬æç¨åºç»åºçå°åçä½æ¯ä¸ç§èæå°åï¼Virtual Addressï¼ï¼ç¶åéè¿æäºæ å°çæ¹æ³ï¼å°è¿ä¸ªèæå°åè½¬æ¢æå®éçç©çå°åãè¿æ ·ï¼åªè¦æä»¬è½å¤å¦¥åå°æ§å¶è¿ä¸ªèæå°åå°ç©çå°åçæ å°è¿ç¨ï¼å°±å¯ä»¥ä¿è¯ä»»æä¸ä¸ªç¨åºæè½å¤è®¿é®çç©çåå­åºåè·å¦å¤ä¸ä¸ªç¨åºç¸äºä¸éå ï¼ä»¥è¾¾å°å°åç©ºé´éç¦»çææã

write a stm32f103 example to explain 

åè®¾æä»¬çè®¡ç®æºæ128 MBåå­ï¼ç¨åºAè¿è¡éè¦10 MBï¼ç¨åºBéè¦100 MBï¼ç¨åºCéè¦20 MBãå¦ææä»¬éè¦åæ¶è¿è¡ç¨åºAåBï¼é£ä¹æ¯è¾ç´æ¥çåæ³æ¯å°åå­çå10 MBåéç»ç¨åºAï¼10 MBï½110 MBåéç»Bãè¿æ ·å°±è½å¤å®ç°AåBä¸¤ä¸ªç¨åºåæ¶è¿è¡ï¼ä½æ¯è¿ç§ç®åçåå­åéç­ç¥é®é¢å¾å¤ã

? å°åç©ºé´ä¸éç¦» ææç¨åºé½ç´æ¥è®¿é®ç©çå°åï¼ç¨åºæä½¿ç¨çåå­ç©ºé´ä¸æ¯ç¸äºéç¦»çãæ¶æçç¨åºå¯ä»¥å¾å®¹ææ¹åå¶ä»ç¨åºçåå­æ°æ®ï¼ä»¥è¾¾å°ç ´åçç®çï¼æäºéæ¶æçãä½æ¯æè­è«çç¨åºå¯è½ä¸å°å¿ä¿®æ¹äºå¶ä»ç¨åºçæ°æ®ï¼å°±ä¼ä½¿å¶ä»ç¨åºä¹å´©æºï¼è¿å¯¹äºéè¦å®å¨ç¨³å®çè®¡ç®ç¯å¢çç¨æ·æ¥è¯´æ¯ä¸è½å®¹å¿çãç¨æ·å¸æä»å¨ä½¿ç¨è®¡ç®æºçæ¶åï¼å¶ä¸­ä¸ä¸ªä»»å¡å¤±è´¥äºï¼è³å°ä¸ä¼å½±åå¶ä»ä»»å¡ã

æå¼å§äººä»¬ä½¿ç¨çæ¯ä¸ç§å«ååæ®µï¼Segmentationï¼çæ¹æ³ï¼åºæ¬æè·¯æ¯æä¸æ®µä¸ç¨åºæéè¦çåå­ç©ºé´å¤§å°çèæç©ºé´æ å°å°æä¸ªå°åç©ºé´ãæ¯å¦ç¨åºAéè¦10 MBåå­ï¼é£ä¹æä»¬åè®¾æä¸ä¸ªå°åä»0x00000000å°0x00A00000ç10MBå¤§å°çä¸ä¸ªåè±¡çç©ºé´ï¼ä¹å°±æ¯èæç©ºé´ï¼ç¶åæä»¬ä»å®éçç©çåå­ä¸­åéä¸ä¸ªç¸åå¤§å°çç©çå°åï¼åè®¾æ¯ç©çå°å0x00100000å¼å§å°0x00B00000ç»æçä¸åç©ºé´ãç¶åæä»¬æè¿ä¸¤åç¸åå¤§å°çå°åç©ºé´ä¸ä¸æ å°ï¼å³èæç©ºé´ä¸­çæ¯ä¸ªå­èç¸å¯¹åºäºç©çç©ºé´ä¸­çæ¯ä¸ªå­èãè¿ä¸ªæ å°è¿ç¨ç±è½¯ä»¶æ¥è®¾ç½®ï¼æ¯å¦æä½ç³»ç»æ¥è®¾ç½®è¿ä¸ªæ å°å½æ°ï¼å®éçå°åè½¬æ¢ç±ç¡¬ä»¶å®æãæ¯å¦å½ç¨åºAä¸­è®¿é®å°å0x00001000æ¶ï¼CPUä¼å°è¿ä¸ªå°åè½¬æ¢æå®éçç©çå°å0x00101000ãé£ä¹æ¯å¦ç¨åºAåç¨åºBå¨è¿è¡æ¶ï¼å®ä»¬çèæç©ºé´åç©çç©ºé´æ å°å³ç³»å¯è½å¦å¾1-5æç¤ºã
åé¡µçåºæ¬æ¹æ³æ¯æå°åç©ºé´äººä¸ºå°ç­åæåºå®å¤§å°çé¡µï¼æ¯ä¸é¡µçå¤§å°ç±ç¡¬ä»¶å³å®ï¼æç¡¬ä»¶æ¯æå¤ç§å¤§å°çé¡µï¼ç±æä½ç³»ç»éæ©å³å®é¡µçå¤§å°ãæ¯å¦Intel Pentiumç³»åå¤çå¨æ¯æ4KBæ4MBçé¡µå¤§å°ï¼é£ä¹æä½ç³»ç»å¯ä»¥éæ©æ¯é¡µå¤§å°ä¸º4KBï¼ä¹å¯ä»¥éæ©æ¯é¡µå¤§å°ä¸º4MBï¼ä½æ¯å¨åä¸æ¶å»åªè½éæ©ä¸ç§å¤§å°ï¼æä»¥å¯¹æ´ä¸ªç³»ç»æ¥è¯´ï¼é¡µå°±æ¯åºå®å¤§å°çãç®åå ä¹ææçPCä¸çæä½ç³»ç»é½ä½¿ç¨4KBå¤§å°çé¡µãæä»¬ä½¿ç¨çPCæºæ¯32ä½çèæå°åç©ºé´ï¼ä¹å°±æ¯4GBï¼é£ä¹æ4KBæ¯é¡µåçè¯ï¼æ»å±æ1 048 576ä¸ªé¡µãç©çç©ºé´ä¹æ¯åæ ·çåæ³ã
çº¿ç¨ï¼Threadï¼ï¼ææ¶è¢«ç§°ä¸ºè½»éçº§è¿ç¨ï¼Lightweight Process, LWPï¼ï¼æ¯ç¨åºæ§è¡æµçæå°ååãä¸ä¸ªæ åççº¿ç¨ç±çº¿ç¨IDãå½åæä»¤æéï¼PCï¼ãå¯å­å¨éååå æ ç»æãéå¸¸æä¹ä¸ï¼ä¸ä¸ªè¿ç¨ç±ä¸ä¸ªå°å¤ä¸ªçº¿ç¨ç»æï¼åä¸ªçº¿ç¨ä¹é´å±äº«ç¨åºçåå­ç©ºé´ï¼åæ¬ä»£ç æ®µãæ°æ®æ®µãå ç­ï¼åä¸äºè¿ç¨çº§çèµæºï¼å¦æå¼æä»¶åä¿¡å·ï¼ãä¸ä¸ªç»å¸ççº¿ç¨ä¸è¿ç¨çå³ç³»å¦å¾1-8æç¤ºã
æä¸ªæä½å¯è½ä¼é·å¥é¿æ¶é´ç­å¾ï¼ç­å¾ççº¿ç¨ä¼è¿å¥ç¡ç ç¶æï¼æ æ³ç»§ç»­æ§è¡ãå¤çº¿ç¨æ§è¡å¯ä»¥ææå©ç¨ç­å¾çæ¶é´ãå¸åçä¾å­æ¯ç­å¾ç½ç»ååºï¼è¿å¯è½è¦è±è´¹æ°ç§çè³æ°åç§ã

æä¸ªæä½ï¼å¸¸å¸¸æ¯è®¡ç®ï¼ä¼æ¶èå¤§éçæ¶é´ï¼å¦æåªæä¸ä¸ªçº¿ç¨ï¼ç¨åºåç¨æ·ä¹é´çäº¤äºä¼ä¸­æ­ãå¤çº¿ç¨å¯ä»¥è®©ä¸ä¸ªçº¿ç¨è´è´£äº¤äºï¼å¦ä¸ä¸ªçº¿ç¨è´è´£è®¡ç®ã

ç¨åºé»è¾æ¬èº«å°±è¦æ±å¹¶åæä½ï¼ä¾å¦ä¸ä¸ªå¤ç«¯ä¸è½½è½¯ä»¶ï¼ä¾å¦Bittorrentï¼ã

å¤CPUæå¤æ ¸è®¡ç®æºï¼åºæ¬å°±æ¯æªæ¥çä¸»æµè®¡ç®æºï¼ï¼æ¬èº«å·å¤åæ¶æ§è¡å¤ä¸ªçº¿ç¨çè½åï¼å æ­¤åçº¿ç¨ç¨åºæ æ³å¨é¢å°åæ¥è®¡ç®æºçå¨é¨è®¡ç®è½åã

ç¸å¯¹äºå¤è¿ç¨åºç¨ï¼å¤çº¿ç¨å¨æ°æ®å±äº«æ¹é¢æçè¦é«å¾å¤ã
çº¿ç¨è°åº¦ä¸ä¼åçº§

ä¸è®ºæ¯å¨å¤å¤çå¨çè®¡ç®æºä¸è¿æ¯å¨åå¤çå¨çè®¡ç®æºä¸ï¼çº¿ç¨æ»æ¯âå¹¶åâæ§è¡çãå½çº¿ç¨æ°éå°äºç­äºå¤çå¨æ°éæ¶ï¼å¹¶ä¸æä½ç³»ç»æ¯æå¤å¤çå¨ï¼ï¼çº¿ç¨çå¹¶åæ¯çæ­£çå¹¶åï¼ä¸åççº¿ç¨è¿è¡å¨ä¸åçå¤çå¨ä¸ï¼å½¼æ­¤ä¹é´äºä¸ç¸å¹²ãä½å¯¹äºçº¿ç¨æ°éå¤§äºå¤çå¨æ°éçæåµï¼çº¿ç¨çå¹¶åä¼åå°ä¸äºé»ç¢ï¼å ä¸ºæ­¤æ¶è³å°æä¸ä¸ªå¤çå¨ä¼è¿è¡å¤ä¸ªçº¿ç¨ã

å¨åå¤çå¨å¯¹åºå¤çº¿ç¨çæåµä¸ï¼å¹¶åæ¯ä¸ç§æ¨¡æåºæ¥çç¶æãæä½ç³»ç»ä¼è®©è¿äºå¤çº¿ç¨ç¨åºè½®æµæ§è¡ï¼æ¯æ¬¡ä»æ§è¡ä¸å°æ®µæ¶é´ï¼éå¸¸æ¯å åå°å ç¾æ¯«ç§ï¼ï¼è¿æ ·æ¯ä¸ªçº¿ç¨å°±âçèµ·æ¥âå¨åæ¶æ§è¡ãè¿æ ·çä¸ä¸ªä¸æ­å¨å¤çå¨ä¸åæ¢ä¸åççº¿ç¨çè¡ä¸ºç§°ä¹ä¸ºçº¿ç¨è°åº¦ï¼Thread Scheduleï¼ãå¨çº¿ç¨è°åº¦ä¸­ï¼çº¿ç¨éå¸¸æ¥æè³å°ä¸ç§ç¶æï¼åå«æ¯ï¼

è¿è¡ï¼Runningï¼ï¼æ­¤æ¶çº¿ç¨æ­£å¨æ§è¡ã

å°±ç»ªï¼Readyï¼ï¼æ­¤æ¶çº¿ç¨å¯ä»¥ç«å»è¿è¡ï¼ä½CPUå·²ç»è¢«å ç¨ã

ç­å¾ï¼Waitingï¼ï¼æ­¤æ¶çº¿ç¨æ­£å¨ç­å¾æä¸äºä»¶ï¼éå¸¸æ¯I/Oæåæ­¥ï¼åçï¼æ æ³æ§è¡ã
è¯¥ç®å½ä¸æä»¶æ°ç®å¾å¤ï¼ä½æä»¬ä¸»è¦å³æ³¨ in_voltage3_rawãin_voltage_scale è¿ä¸¤ä¸ªæä»¶å³å¯ï¼å¶
ä¸­ in_voltage3_raw ä¸ºè¯»å adc æ°æ®çåå§æ°å¼ï¼in_voltage_scale ä¸º adc æ°æ®ä¸çµåå¼æ¢ç®æ¯ä¾ï¼
å°ä»è¿ä¸¤ä¸ªè¯»åå°çæ°æ®ç¸ä¹å³å¯å¾å°æä»¬æ³è¦çæ¿è½½çµä½å¨ä¸ççµåå¼ã
ç±äºè¯»åçµåå¼ç¸å¯¹ç®åï¼æ¥ä¸æ¥æä»¬å°ç¼åç®åç shell èæ¬è·åçµåå¼ã
	pthread_detach(id);
    queue_init(&bindReqQueue, sizeof(bindReq_t), 1);
    queue_init(&bindRespQueue, sizeof(bindReq_t), 1);
    queue_init(&secondaryBufferQueue, sizeof(secondaryBufferItem_t), NUM_SECONDARY_BUFFERS);
	c := http.Cookie{
		Name:    flashName,
		Value:   base64.URLEncoding.EncodeToString(value),
		Path:    "/",
		Expires: expire,
		MaxAge:  3,
	}
	http.SetCookie(w, &c)
func GetMessage(w http.ResponseWriter, r *http.Request) ([]byte, error) {
	log.Info("[flash] begin get message...")
	c, err := r.Cookie(flashName)
	if err != nil {
		switch err {
		case http.ErrNoCookie:
			return nil, nil
		default:
			return nil, err
		}
	}

	// delete cookie
	dc := http.Cookie{
		Name:    flashName,
		Path:    "/",
		MaxAge:  -1,
		Expires: time.Unix(1, 0),
	}
	http.SetCookie(w, &dc)

	value, err := base64.URLEncoding.DecodeString(c.Value)
	if err != nil {
		return nil, err
	}

	return value, nil
}
   ©¦1823    void init_cgroup_root(struct cgroup_root *root, struct cgroup_sb_opts *opts)                                              ©¦
   ©¦1824    {                                                                                                                         ©¦
   ©¦1825            struct cgroup *cgrp = &root->cgrp;                                                                                ©¦
   ©¦1826                                                                                                                              ©¦
  >©¦1827            INIT_LIST_HEAD(&root->root_list);                                                                                 ©¦
   ©¦1828            atomic_set(&root->nr_cgrps, 1);                                                                                   ©¦
   ©¦1829            cgrp->root = root;                                                                                                ©¦
   ©¦1830            init_cgroup_housekeeping(cgrp);                                                                                   ©¦
   ©¦1831            idr_init(&root->cgroup_idr);                                                                                      ©¦
   ©¦1832                                                                                                                              ©¦
   ©¦1833            root->flags = opts->flags;                                                                                        ©¦
   ©¦1834            if (opts->release_agent)                                                                                          ©¦
   ©¦1835                    strcpy(root->release_agent_path, opts->release_agent);                                                    ©¦
   ©¦1836            if (opts->name)                                                                                                   ©¦
   ©¦1837                    strcpy(root->name, opts->name);                                                                           ©¦
   ©¦1838            if (opts->cpuset_clone_children)                                                                                  ©¦
   ©¦300     static __always_inline void __write_once_size(volatile void *p, void *res, int size)                                      ©¦
   ©¦301     {                                                                                                                         ©¦
   ©¦302             switch (size) {                                                                                                   ©¦
   ©¦303             case 1: *(volatile __u8 *)p = *(__u8 *)res; break;                                                                ©¦
   ©¦304             case 2: *(volatile __u16 *)p = *(__u16 *)res; break;                                                              ©¦
  >©¦305             case 4: *(volatile __u32 *)p = *(__u32 *)res; break;                                                              ©¦
   ©¦306             case 8: *(volatile __u64 *)p = *(__u64 *)res; break;                                                              ©¦
   ©¦307             default:                                                                                                          ©¦
   ©¦308                     barrier();                                                                                                ©¦
   ©¦309                     __builtin_memcpy((void *)p, (const void *)res, size);                                                     ©¦
   ©¦310                     barrier();                                                                                                ©¦
   ©¦311             }                                                                                                                 ©¦
   ©¦312     }                                                                                                                         ©¦
   ©¦1800    static void init_cgroup_housekeeping(struct cgroup *cgrp)                                                                 ©¦
   ©¦1801    {                                                                                                                         ©¦
   ©¦1802            struct cgroup_subsys *ss;                                                                                         ©¦
   ©¦1803            int ssid;                                                                                                         ©¦
   ©¦1804                                                                                                                              ©¦
   ©¦1805            INIT_LIST_HEAD(&cgrp->self.sibling);                                                                              ©¦
   ©¦1806            INIT_LIST_HEAD(&cgrp->self.children);                                                                             ©¦
   ©¦1807            INIT_LIST_HEAD(&cgrp->cset_links);                                                                                ©¦
   ©¦1808            INIT_LIST_HEAD(&cgrp->pidlists);                                                                                  ©¦
  >©¦1809            mutex_init(&cgrp->pidlist_mutex);                                                                                 ©¦
   ©¦1810            cgrp->self.cgroup = cgrp;                                                                                         ©¦
   ©¦1811            cgrp->self.flags |= CSS_ONLINE;                                                                                   ©¦
   ©¦1812            cgrp->dom_cgrp = cgrp;                                                                                            ©¦
   ©¦1813            cgrp->max_descendants = INT_MAX;                                                                                  ©¦
   ©¦1814            cgrp->max_depth = INT_MAX;                                                                                        ©¦
   ©¦1815                                                                                                                              ©¦
   ©¦1816            for_each_subsys(ss, ssid)                                                                                         ©¦
   ©¦1817                    INIT_LIST_HEAD(&cgrp->e_csets[ssid]);                                                                     ©¦
   ©¦1818                                                                                                                              ©¦
   ©¦1819            init_waitqueue_head(&cgrp->offline_waitq);                                                                        ©¦
   ©¦1820            INIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);                                                      ©¦
   ©¦1821    }                                                                                                                         ©¦
   ©¦152     static inline void idr_init(struct idr *idr)                                                                              ©¦
   ©¦153     {                                                                                                                         ©¦
  >©¦154             INIT_RADIX_TREE(&idr->idr_rt, IDR_RT_MARKER);                                                                     ©¦
   ©¦155             idr->idr_next = 0;                                                                                                ©¦
   ©¦156     }                                                                                                                         ©¦
   ©¦47      static inline void arch_local_irq_disable(void)                                                                           ©¦
   ©¦48      {                                                                                                                         ©¦
  >©¦49              asm volatile(                                                                                                     ©¦
   ©¦50                      "       cpsid i                 @ arch_local_irq_disable"                                                 ©¦
   ©¦51                      :                                                                                                         ©¦
   ©¦52                      :                                                                                                         ©¦
   ©¦53                      : "memory", "cc");                                                                                        ©¦
   ©¦54      }                                                                                                                         ©¦
   ©¦2007    void __init boot_cpu_init(void)                                                                                           ©¦
   ©¦2008    {                                                                                                                         ©¦
  >©¦2009            int cpu = smp_processor_id();                                                                                     ©¦
   ©¦2010                                                                                                                              ©¦
   ©¦2011            /* Mark the boot cpu "present", "online" etc for SMP and UP case */                                               ©¦
   ©¦2012            set_cpu_online(cpu, true);                                                                                        ©¦
   ©¦2013            set_cpu_active(cpu, true);                                                                                        ©¦
   ©¦2014            set_cpu_present(cpu, true);                                                                                       ©¦
   ©¦2015            set_cpu_possible(cpu, true);                                                                                      ©¦
   ©¦2016                                                                                                                              ©¦
   ©¦2017    #ifdef CONFIG_SMP                                                                                                         ©¦
   ©¦2018            __boot_cpu_id = cpu;                                                                                              ©¦
   ©¦2019    #endif                                                                                                                    ©¦
   ©¦2020    }                                                                                                                         ©¦
   ©¦372     static void __init setup_command_line(char *command_line)                                                                 ©¦
   ©¦373     {                                                                                                                         ©¦
  >©¦374             saved_command_line =                                                                                              ©¦
   ©¦375                     memblock_virt_alloc(strlen(boot_command_line) + 1, 0);                                                    ©¦
   ©¦376             initcall_command_line =                                                                                           ©¦
   ©¦377                     memblock_virt_alloc(strlen(boot_command_line) + 1, 0);                                                    ©¦
   ©¦378             static_command_line = memblock_virt_alloc(strlen(command_line) + 1, 0);                                           ©¦
   ©¦379             strcpy(saved_command_line, boot_command_line);                                                                    ©¦
   ©¦380             strcpy(static_command_line, command_line);                                                                        ©¦
   ©¦381     }                                                                                                                         ©¦
   ©¦382                                                                                                                               ©¦
   ©¦169     __lookup_processor_type:                                                                                                  ©¦
B+>©¦170             adr     r3, __lookup_processor_type_data                                                                          ©¦
   ©¦171             ldmia   r3, {r4 - r6}                                                                                             ©¦
   ©¦172             sub     r3, r3, r4                      @ get offset between virt&phys                                            ©¦
   ©¦173             add     r5, r5, r3                      @ convert virt addresses to                                               ©¦
   ©¦174             add     r6, r6, r3                      @ physical address space                                                  ©¦
   ©¦175     1:      ldmia   r5, {r3, r4}                    @ value, mask                                                             ©¦
   ©¦176             and     r4, r4, r9                      @ mask wanted bits                                                        ©¦
   ©¦177             teq     r3, r4                                                                                                    ©¦
   ©¦178             beq     2f                                                                                                        ©¦
   ©¦179             add     r5, r5, #PROC_INFO_SZ           @ sizeof(proc_info_list)                                                  ©¦
   ©¦180             cmp     r5, r6                                                                                                    ©¦
   ©¦181             blo     1b                                                                                                        ©¦
   ©¦243     static int __get_cpu_architecture(void)                                                                                   ©¦
   ©¦244     {                                                                                                                         ©¦
   ©¦245             int cpu_arch;                                                                                                     ©¦
   ©¦246                                                                                                                               ©¦
  >©¦247             if ((read_cpuid_id() & 0x0008f000) == 0) {                                                                        ©¦
   ©¦248                     cpu_arch = CPU_ARCH_UNKNOWN;                                                                              ©¦
   ©¦249             } else if ((read_cpuid_id() & 0x0008f000) == 0x00007000) {                                                        ©¦
   ©¦250                     cpu_arch = (read_cpuid_id() & (1 << 23)) ? CPU_ARCH_ARMv4T : CPU_ARCH_ARMv3;                              ©¦
   ©¦251             } else if ((read_cpuid_id() & 0x00080000) == 0x00000000) {                                                        ©¦
   ©¦252                     cpu_arch = (read_cpuid_id() >> 16) & 7;                                                                   ©¦
   ©¦253                     if (cpu_arch)                                                                                             ©¦
   ©¦254                             cpu_arch += CPU_ARCH_ARMv3;                                                                       ©¦
   ©¦255             } else if ((read_cpuid_id() & 0x000f0000) == 0x000f0000) {                                                        ©¦
   ©¦256                     /* Revised CPUID format. Read the Memory Model Feature                                                    ©¦
   ©¦257                      * Register 0 and check for VMSAv7 or PMSAv7 */                                                           ©¦
   ©¦258                     unsigned int mmfr0 = read_cpuid_ext(CPUID_EXT_MMFR0);                                                     ©¦
   ©¦259                     if ((mmfr0 & 0x0000000f) >= 0x00000003 ||                                                                 ©¦
   ©¦690     #ifdef MULTI_CPU                                                                                                          ©¦
  >©¦691             processor = *list->proc;                                                                                          ©¦
   ©¦692     #endif                                                                                                                    ©¦
   ©¦693     #ifdef MULTI_TLB                                                                                                          ©¦
   ©¦694             cpu_tlb = *list->tlb;                                                                                             ©¦
   ©¦695     #endif                                                                                                                    ©¦
   ©¦696     #ifdef MULTI_USER                                                                                                         ©¦
   ©¦697             cpu_user = *list->user;                                                                                           ©¦
   ©¦698     #endif                                                                                                                    ©¦
   ©¦699     #ifdef MULTI_CACHE                                                                                                        ©¦
$12 = (struct proc_info_list *) 0x806714e4 <__v7_ca9mp_proc_info>
(gdb) p *list
$13 = {cpu_val = 1091551376, cpu_mask = 4279238640, __cpu_mm_mmu_flags = 3086, __cpu_io_mmu_flags = 3074, __cpu_flush = 4289359672,
  arch_name = 0x807015a8 <cpu_arch_name> "armv7", elf_name = 0x807015ae <cpu_elf_name> "v7", elf_hwcap = 32919,
  cpu_name = 0x80118340 <cpu_v7_name> "ARMv7 Processor", proc = 0x80955094 <ca9mp_processor_functions>,
  tlb = 0x80907810 <v7wbi_tlb_fns>, user = 0x8095502c <v6_user_fns>, cache = 0x80955000 <v7_cache_fns>}
   ©¦702                                                                                                                               ©¦
  >©¦703             pr_info("CPU: %s [%08x] revision %d (ARMv%s), cr=%08lx\n",                                                        ©¦
   ©¦704                     cpu_name, read_cpuid_id(), read_cpuid_id() & 15,                                                          ©¦
   ©¦705                     proc_arch[cpu_architecture()], get_cr());                                                                 ©¦
   ©¦706                                                                                                                               ©¦
   ©¦707             snprintf(init_utsname()->machine, __NEW_UTS_LEN + 1, "%s%c",                                                      ©¦
   ©¦708                      list->arch_name, ENDIANNESS);                                                                            ©¦
   ©¦709             snprintf(elf_platform, ELF_PLATFORM_SIZE, "%s%c",                                                                 ©¦
   ©¦710                      list->elf_name, ENDIANNESS);                                                                             ©¦
   ©¦711             elf_hwcap = list->elf_hwcap;                                                                                      ©¦
   ©¦712                                                                                                                               ©¦
   ©¦713             cpuid_init_hwcaps();                                                                                              ©¦
   ©¦714             patch_aeabi_idiv();                                                                                               ©¦
   ©¦136     void __init init_default_cache_policy(unsigned long pmd)                                                                  ©¦
   ©¦137     {                                                                                                                         ©¦
   ©¦138             int i;                                                                                                            ©¦
   ©¦139                                                                                                                               ©¦
  >©¦140             initial_pmd_value = pmd;                                                                                          ©¦
   ©¦141                                                                                                                               ©¦
   ©¦142             pmd &= PMD_SECT_CACHE_MASK;                                                                                       ©¦
   ©¦143                                                                                                                               ©¦
   ©¦144             for (i = 0; i < ARRAY_SIZE(cache_policies); i++)                                                                  ©¦
   ©¦145                     if (cache_policies[i].pmd == pmd) {                                                                       ©¦
   ©¦146                             cachepolicy = i;                                                                                  ©¦
   ©¦147                             break;                                                                                            ©¦
   ©¦148                     }                                                                                                         ©¦
   ©¦149                                                                                                                               ©¦
   ©¦150             if (i == ARRAY_SIZE(cache_policies))                                                                              ©¦
   ©¦151                     pr_err("ERROR: could not find cache policy\n");                                                           ©¦
   ©¦152     }                                                                                                                         ©¦
  >©¦345             pr_info("CPU: %s data cache, %s instruction cache\n",                                                             ©¦
   ©¦346                     cache_is_vivt() ? "VIVT" :                                                                                ©¦
   ©¦347                     cache_is_vipt_aliasing() ? "VIPT aliasing" :                                                              ©¦
   ©¦348                     cache_is_vipt_nonaliasing() ? "PIPT / VIPT nonaliasing" : "unknown",                                      ©¦
   ©¦349                     cache_is_vivt() ? "VIVT" :                                                                                ©¦
   ©¦350                     icache_is_vivt_asid_tagged() ? "VIVT ASID tagged" :                                                       ©¦
   ©¦351                     icache_is_vipt_aliasing() ? "VIPT aliasing" :                                                             ©¦
   ©¦352                     icache_is_pipt() ? "PIPT" :                                                                               ©¦
   ©¦353                     cache_is_vipt_nonaliasing() ? "VIPT nonaliasing" : "unknown");                                            ©¦
  >©¦553             __asm__ (                                                                                                         ©¦
   ©¦554             "msr    cpsr_c, %1\n\t"                                                                                           ©¦
   ©¦555             "add    r14, %0, %2\n\t"                                                                                          ©¦
   ©¦556             "mov    sp, r14\n\t"                                                                                              ©¦
   ©¦557             "msr    cpsr_c, %3\n\t"                                                                                           ©¦
   ©¦558             "add    r14, %0, %4\n\t"                                                                                          ©¦
   ©¦559             "mov    sp, r14\n\t"                                                                                              ©¦
   ©¦560             "msr    cpsr_c, %5\n\t"                                                                                           ©¦
   ©¦561             "add    r14, %0, %6\n\t"                                                                                          ©¦
   ©¦562             "mov    sp, r14\n\t"                                                                                              ©¦
   ©¦563             "msr    cpsr_c, %7\n\t"                                                                                           ©¦
   ©¦564             "add    r14, %0, %8\n\t"                                                                                          ©¦
   ©¦565             "mov    sp, r14\n\t"                                                                                              ©¦
   ©¦566             "msr    cpsr_c, %9"                                                                                               ©¦
   ©¦567                 :                                                                                                             ©¦
   ©¦568                 : "r" (stk),                                                                                                  ©¦
   ©¦569                   PLC (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),                                                                     ©¦
   ©¦570                   "I" (offsetof(struct stack, irq[0])),                                                                       ©¦
   ©¦571                   PLC (PSR_F_BIT | PSR_I_BIT | ABT_MODE),                                                                     ©¦
   ©¦572                   "I" (offsetof(struct stack, abt[0])),                                                                       ©¦
   ©¦573                   PLC (PSR_F_BIT | PSR_I_BIT | UND_MODE),                                                                     ©¦
   ©¦574                   "I" (offsetof(struct stack, und[0])),                                                                       ©¦
   ©¦220             const struct machine_desc *mdesc, *mdesc_best = NULL;                                                             ©¦
   ©¦221                                                                                                                               ©¦
   ©¦222     #if defined(CONFIG_ARCH_MULTIPLATFORM) || defined(CONFIG_ARM_SINGLE_ARMV7M)                                               ©¦
   ©¦223             DT_MACHINE_START(GENERIC_DT, "Generic DT based system")                                                           ©¦
   ©¦224                     .l2c_aux_val = 0x0,                                                                                       ©¦
   ©¦225                     .l2c_aux_mask = ~0x0,                                                                                     ©¦
   ©¦226             MACHINE_END                                                                                                       ©¦
   ©¦227                                                                                                                               ©¦
   ©¦228             mdesc_best = &__mach_desc_GENERIC_DT;                                                                             ©¦
   ©¦229     #endif                                                                                                                    ©¦
   ©¦230                                                                                                                               ©¦
   ©¦231             if (!dt_phys || !early_init_dt_verify(phys_to_virt(dt_phys)))                                                     ©¦
   ©¦232                     return NULL;                                                                                              ©¦
   ©¦233                                                                                                                               ©¦
   ©¦234             mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);                                                 ©¦
   ©¦235                                                                                                                               ©¦
   ©¦236             if (!mdesc) {                                                                                                     ©¦
   ©¦237                     const char *prop;                                                                                         ©¦
   ©¦238                     int size;                                                                                                 ©¦
   ©¦239                     unsigned long dt_root;                                                                                    ©¦
   ©¦240                                                                                                                               ©¦
   ©¦244     static inline unsigned long __phys_to_virt(phys_addr_t x) //__phys_to_virt                                                ©¦
   ©¦245     {                                                                                                                         ©¦
   ©¦246             unsigned long t;                                                                                                  ©¦
   ©¦247                                                                                                                               ©¦
   ©¦248             /*                                                                                                                ©¦
   ©¦249              * 'unsigned long' cast discard upper word when                                                                   ©¦
   ©¦250              * phys_addr_t is 64 bit, and makes sure that inline                                                              ©¦
   ©¦251              * assembler expression receives 32 bit argument                                                                  ©¦
   ©¦252              * in place where 'r' 32 bit operand is expected.                                                                 ©¦
   ©¦253              */                                                                                                               ©¦
  >©¦254             __pv_stub((unsigned long) x, t, "sub", __PV_BITS_31_24);                                                          ©¦
   ©¦255             return t;                                                                                                         ©¦
   ©¦256     }                                                                                                                         ©¦
   ©¦1251    bool __init early_init_dt_verify(void *params)                                                                            ©¦
   ©¦1252    {                                                                                                                         ©¦
   ©¦1253            if (!params)                                                                                                      ©¦
   ©¦1254                    return false;                                                                                             ©¦
   ©¦1255                                                                                                                              ©¦
   ©¦1256            /* check device tree validity */                                                                                  ©¦
   ©¦1257            if (fdt_check_header(params))                                                                                     ©¦
   ©¦1258                    return false;                                                                                             ©¦
   ©¦1259                                                                                                                              ©¦
   ©¦1260            /* Setup flat device-tree pointer */                                                                              ©¦
   ©¦1261            initial_boot_params = params;                                                                                     ©¦
  >©¦1262            of_fdt_crc32 = crc32_be(~0, initial_boot_params,                                                                  ©¦
   ©¦1263                                    fdt_totalsize(initial_boot_params));                                                      ©¦
   ©¦1264            return true;                                                                                                      ©¦
   ©¦1265    }                                                                                                                         ©¦
   ©¦737     int __init of_scan_flat_dt(int (*it)(unsigned long node,                                                                  ©¦
   ©¦738                                          const char *uname, int depth,                                                        ©¦
   ©¦739                                          void *data),                                                                         ©¦
   ©¦740                                void *data)                                                                                    ©¦
   ©¦741     {                                                                                                                         ©¦
  >©¦742             const void *blob = initial_boot_params;                                                                           ©¦
   ©¦743             const char *pathp;                                                                                                ©¦
   ©¦744             int offset, rc = 0, depth = -1;                                                                                   ©¦
   ©¦745                                                                                                                               ©¦
   ©¦746             if (!blob)                                                                                                        ©¦
   ©¦747                     return 0;                                                                                                 ©¦
   ©¦748                                                                                                                               ©¦
   ©¦749             for (offset = fdt_next_node(blob, -1, &depth);                                                                    ©¦
   ©¦750                  offset >= 0 && depth >= 0 && !rc;                                                                            ©¦
   ©¦751                  offset = fdt_next_node(blob, offset, &depth)) {                                                              ©¦
   ©¦752                                                                                                                               ©¦
   ©¦753                     pathp = fdt_get_name(blob, offset, NULL);                                                                 ©¦
   ©¦754                     if (*pathp == '/')                                                                                        ©¦
   ©¦755                             pathp = kbasename(pathp);                                                                         ©¦
   ©¦756                     rc = it(offset, pathp, depth, data);                                                                      ©¦
   ©¦757             }                                                                                                                 ©¦
   ©¦758             return rc;                                                                                                        ©¦
   ©¦759     }                                                                                                                         ©¦
(gdb) p mdesc
$17 = (const struct machine_desc *) 0x809435a0 <__mach_desc_VEXPRESS_DT>
(gdb) p *mdesc
$18 = {nr = 4294967295, name = 0x807bbed0 "ARM-Versatile Express", atag_offset = 0, dt_compat = 0x8095b6c8 <v2m_dt_match>, 
  nr_irqs = 0, video_start = 0, video_end = 0, reserve_lp0 = 0 '\000', reserve_lp1 = 0 '\000', reserve_lp2 = 0 '\000',
  reboot_mode = REBOOT_COLD, l2c_aux_val = 4194304, l2c_aux_mask = 4262461439, l2c_write_sec = 0x0,
  smp = 0x8095b91c <vexpress_smp_dt_ops>, smp_init = 0x80909374 <vexpress_smp_init_ops>, fixup = 0x0, dt_fixup = 0x0, pv_fixup = 0x0,
  reserve = 0x0, map_io = 0x0, init_early = 0x0, init_irq = 0x0, init_time = 0x0, init_machine = 0x0, init_late = 0x0,
  handle_irq = 0x0, restart = 0x0}
type = const struct machine_desc {
    unsigned int nr;
    const char *name;
    unsigned long atag_offset;
    const char * const *dt_compat;
    unsigned int nr_irqs;
    unsigned int video_start;
    unsigned int video_end;
    unsigned char reserve_lp0 : 1;
    unsigned char reserve_lp1 : 1;
    unsigned char reserve_lp2 : 1;
   ©¦1106            if (mdesc->reboot_mode != REBOOT_HARD)                                                                            ©¦
   ©¦1107                    reboot_mode = mdesc->reboot_mode;                                                                         ©¦
   ©¦1108                                                                                                                              ©¦
  >©¦1109            init_mm.start_code = (unsigned long) _text;                                                                       ©¦
   ©¦1110            init_mm.end_code   = (unsigned long) _etext;                                                                      ©¦
   ©¦1111            init_mm.end_data   = (unsigned long) _edata;                                                                      ©¦
   ©¦1112            init_mm.brk        = (unsigned long) _end;                                                                        ©¦
   ©¦1113                                                                                                                              ©¦
   ©¦1114            /* populate cmd_line too for later use, preserving boot_command_line */                                           ©¦
   ©¦1115            strlcpy(cmd_line, boot_command_line, COMMAND_LINE_SIZE);                                                          ©¦
   ©¦1116            *cmdline_p = cmd_line;                                                                                            ©¦
   ©¦1117                                                                                                                              ©¦
   ©¦1118            early_fixmap_init();                                                                                              ©¦
   ©¦1119            early_ioremap_init();                                                                                             ©¦
   ©¦1120                                                                                                                              ©¦
   ©¦1121            parse_early_param();                                                                                              ©¦
   ©¦611     void __init parse_early_param(void)                                                                                       ©¦
   ©¦612     {                                                                                                                         ©¦
   ©¦613             static int done __initdata;                                                                                       ©¦
   ©¦614             static char tmp_cmdline[COMMAND_LINE_SIZE] __initdata;                                                            ©¦
   ©¦615                                                                                                                               ©¦
  >©¦616             if (done)                                                                                                         ©¦
   ©¦617                     return;                                                                                                   ©¦
   ©¦618                                                                                                                               ©¦
   ©¦619             /* All fall through to do_early_param. */                                                                         ©¦
   ©¦620             strlcpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE);                                                       ©¦
   ©¦621             parse_early_options(tmp_cmdline);                                                                                 ©¦
   ©¦622             done = 1;                                                                                                         ©¦
   ©¦623     }                                                                                                                         ©¦
   ©¦164     char *parse_args(const char *doing,                                                                                       ©¦
   ©¦165                      char *args,                                                                                              ©¦
   ©¦166                      const struct kernel_param *params,                                                                       ©¦
   ©¦167                      unsigned num,                                                                                            ©¦
   ©¦168                      s16 min_level,                                                                                           ©¦
   ©¦169                      s16 max_level,                                                                                           ©¦
   ©¦170                      void *arg,                                                                                               ©¦
   ©¦171                      int (*unknown)(char *param, char *val,                                                                   ©¦
   ©¦172                                     const char *doing, void *arg))                                                            ©¦
   ©¦173     {                                                                                                                         ©¦
  >©¦174             char *param, *val, *err = NULL;                                                                                   ©¦
   ©¦175                                                                                                                               ©¦
   ©¦176             /* Chew leading spaces */                                                                                         ©¦
   ©¦177             args = skip_spaces(args);                                                                                         ©¦
   ©¦178                                                                                                                               ©¦
   ©¦179             if (*args)                                                                                                        ©¦
   ©¦180                     pr_debug("doing %s, parsing ARGS: '%s'\n", doing, args);                                                  ©¦
   ©¦181                                                                                                                               ©¦
   ©¦182             while (*args) {                                                                                                   ©¦
   ©¦183                     int ret;                                                                                                  ©¦
   ©¦184                     int irq_was_disabled;                                                                                     ©¦
   ©¦185                                                                                                                               ©¦
   ©¦186                     args = next_arg(args, &param, &val);                                                                      ©¦
   ©¦182             while (*args) {                                                                                                   ©¦
   ©¦183                     int ret;                                                                                                  ©¦
   ©¦184                     int irq_was_disabled;                                                                                     ©¦
   ©¦185                                                                                                                               ©¦
   ©¦186                     args = next_arg(args, &param, &val);                                                                      ©¦
   ©¦187                     /* Stop at -- */                                                                                          ©¦
   ©¦188                     if (!val && strcmp(param, "--") == 0)                                                                     ©¦
   ©¦189                             return err ?: args;                                                                               ©¦
   ©¦190                     irq_was_disabled = irqs_disabled();                                                                       ©¦
   ©¦191                     ret = parse_one(param, val, doing, params, num,                                                           ©¦
   ©¦192                                     min_level, max_level, arg, unknown);                                                      ©¦
   ©¦193                     if (irq_was_disabled && !irqs_disabled())                                                                 ©¦
   ©¦194                             pr_warn("%s: option '%s' enabled irq's!\n",                                                       ©¦
   ©¦195                                     doing, param);                                                                            ©¦
   ©¦196                                                                                                                               ©¦
   ©¦197                     switch (ret) {                                                                                            ©¦
   ©¦198                     case 0:                                                                                                   ©¦
   ©¦199                             continue;                                                                                         ©¦
   ©¦200                     case -ENOENT:                                                                                             ©¦
   ©¦201                             pr_err("%s: Unknown parameter `%s'\n", doing, param);                                             ©¦
   ©¦202                             break;                                                                                            ©¦
   ©¦203                     case -ENOSPC:                                                                                             ©¦
   ©¦518                     if (cpu_arch >= CPU_ARCH_ARMv7 && (cr & CR_TRE)) {                                                        ©¦
   ©¦519                             /*                                                                                                ©¦
   ©¦520                              * For ARMv7 with TEX remapping,                                                                  ©¦
   ©¦521                              * - shared device is SXCB=1100                                                                   ©¦
   ©¦522                              * - nonshared device is SXCB=0100                                                                ©¦
   ©¦523                              * - write combine device mem is SXCB=0001                                                        ©¦
   ©¦524                              * (Uncached Normal memory)                                                                       ©¦
   ©¦525                              */                                                                                               ©¦
   ©¦526                             mem_types[MT_DEVICE].prot_sect |= PMD_SECT_TEX(1);                                                ©¦
   ©¦527                             mem_types[MT_DEVICE_NONSHARED].prot_sect |= PMD_SECT_TEX(1);                                      ©¦
   ©¦528                             mem_types[MT_DEVICE_WC].prot_sect |= PMD_SECT_BUFFERABLE;                                         ©¦
   ©¦692                     mem_types[MT_CACHECLEAN].prot_sect |= PMD_SECT_WB;                                                        ©¦
   ©¦693                     break;                                                                                                    ©¦
   ©¦694             }                                                                                                                 ©¦
   ©¦695             pr_info("Memory policy: %sData cache %s\n",                                                                       ©¦
   ©¦696                     ecc_mask ? "ECC enabled, " : "", cp->policy);                                                             ©¦
   ©¦697                                                                                                                               ©¦
   ©¦698             for (i = 0; i < ARRAY_SIZE(mem_types); i++) {                                                                     ©¦
   ©¦699                     struct mem_type *t = &mem_types[i];                                                                       ©¦
   ©¦700                     if (t->prot_l1)                                                                                           ©¦
   ©¦701                             t->prot_l1 |= PMD_DOMAIN(t->domain);                                                              ©¦
   ©¦702                     if (t->prot_sect)                                                                                         ©¦
   ©¦703                             t->prot_sect |= PMD_DOMAIN(t->domain);                                                            ©¦
   ©¦704             }                                                                                                                 ©¦
   ©¦705     }                                                                                                                         ©¦
  >©¦1180            vmalloc_limit = (u64)(uintptr_t)vmalloc_min - PAGE_OFFSET + PHYS_OFFSET;                                          ©¦
   ©¦1181                                                                                                                              ©¦
   ©¦1182            for_each_memblock(memory, reg) {                                                                                  ©¦
   ©¦1183                    phys_addr_t block_start = reg->base;                                                                      ©¦
   ©¦1184                    phys_addr_t block_end = reg->base + reg->size;                                                            ©¦
   ©¦1185                                                                                                                              ©¦
   ©¦1186                    if (reg->base < vmalloc_limit) {                                                                          ©¦
   ©¦1187                            if (block_end > lowmem_limit)                                                                     ©¦
   ©¦1188                                    /*                                                                                        ©¦
   ©¦1189                                     * Compare as u64 to ensure vmalloc_limit does                                            ©¦
   ©¦1190                                     * not get truncated. block_end should always                                             ©¦
   ©¦1191                                     * fit in phys_addr_t so there should be no                                               ©¦
   ©¦1192                                     * issue with assignment.                                                                 ©¦
   ©¦1193                                     */                                                                                       ©¦
   ©¦1194                                    lowmem_limit = min_t(u64,                                                                 ©¦
   ©¦1195                                                             vmalloc_limit,                                                   ©¦
   ©¦1196                                                             block_end);                                                      ©¦
   ©¦1197                                                                                                                              ©¦
(gdb) n
build_all_zonelists (pgdat=<optimized out>) at mm/page_alloc.c:5259
(gdb) p vm_total_pages 
$37 = 0
(gdb) s
(gdb) p vm_total_pages 
$38 = 130048
   ©¦5272            pr_info("Built %i zonelists, mobility grouping %s.  Total pages: %ld\n",                                                                            ©¦
   ©¦5273                    nr_online_nodes,                                                                                                                            ©¦
   ©¦5274                    page_group_by_mobility_disabled ? "off" : "on",                                                                                             ©¦
   ©¦5275                    vm_total_pages);                                                                                                                            ©¦
   ©¦5276    #ifdef CONFIG_NUMA                                                                                                                                          ©¦
   ©¦5277            pr_info("Policy zone: %s\n", zone_names[policy_zone]);                                                                                              ©¦
  virtual void SetRowAddress(GPIO *io, int row) {
    if (row == last_row_) return;
    io->SetBits(bk_);  // Enable serial input for the shifter
    for (int r = 7; r >= 0; r--) {
      if (row % 8 == r) {
        io->SetBits(din_);
      } else {
        io->ClearBits(din_);
      }
      io->SetBits(dck_);
      io->SetBits(dck_);  // Longer clock time; tested with Pi3
      io->ClearBits(dck_);
    }
    io->ClearBits(bk_);  // Disable serial input to keep unwanted bits out of the shifters
    last_row_ = row;
    // Set bits D and E to enable the proper shifter to display the selected
    // row.
    io->WriteMaskedBits(row_lookup_[row], row_mask_);
  }
// The DirectABCDRowAddressSetter sets the address by one of
// row pin ABCD for 32Ñ16 matrix 1:4 multiplexing. The matrix has
// 4 addressable rows. Row is selected by a low level on the
// corresponding row address pin. Other row address pins must be in high level.
//
// Row addr| 0 | 1 | 2 | 3
// --------+---+---+---+---
// Line A  | 0 | 1 | 1 | 1
// Line B  | 1 | 0 | 1 | 1
// Line C  | 1 | 1 | 0 | 1
// Line D  | 1 | 1 | 1 | 0
      tos_barrier.c                                                                                                                                                                         ©¦ 
      tos_binary_heap.c                                                                                                                                                                     ©¦ 
      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_bitmap.c                                                                                                                                                                          ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_char_fifo.c                                                                                                                                                                       ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_completion.c                                                                                                                                                                      ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_completion.c                                                                                                                                                                      ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_countdownlatch.c                                                                                                                                                                  ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_event.c                                                                                                                                                                           ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_global.c                                                                                                                                                                          ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_mail_queue.c                                                                                                                                                                      ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_message_queue.c                                                                                                                                                                   ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_mmblk.c                                                                                                                                                                           ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_mmheap.c                                                                                                                                                                          ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_mutex.c                                                                                                                                                                           ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_pend.c                                                                                                                                                                            ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_priority_mail_queue.c                                                                                                                                                             ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_priority_message_queue.c                                                                                                                                                          ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_priority_queue.c                                                                                                                                                                  ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_ring_queue.c                                                                                                                                                                      ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_robin.c                                                                                                                                                                           ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_rwlock.c                                                                                                                                                                          ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_sched.c                                                                                                                                                                           ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_sem.c                                                                                                                                                                             ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_stopwatch.c                                                                                                                                                                       ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_sys.c                                                                                                                                                                             ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_task.c                                                                                                                                                                            ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_tick.c                                                                                                                                                                            ©¦>

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_time.c                                                                                                                                                                            ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_timer.c                                                                                                                                                                           ©¦ 
[tong@free ~/06_files/Download]$ cd ~/02_nvme              
ç¬¬ä¸ç«  æç¥ç®æ ä¸å¯ä¼åï¼ä½ ä¸ºä»ä¹è¿è¦åæï¼

ç¬¬äºç«  çæ¾å¼ååæ¾å¼

ç¬¬ä¸ç«  ç®æ è±ç¦»åç§¯ææç»´

ç¬¬åç«  å¹å»æ¾å¼çè½å

ç¬¬äºç«  ç®¡çä½ çææ³åæç»ª

ç¬¬å­ç«  å³äºç®æ çå¿«ææ¢æ³

ç¬¬ä¸ç«  å¦ä½è§åä½ çäººçç®æ ï¼

ç¬¬å«ç«  å«è®©åææä½ä½ æ¾å¼çèæ­¥

ç¬¬ä¹ç«  éç½®ä½ äººççæåé
Ò»µ©²»Ê¹ÓÃ Make ÖÐÄÇÐ©ÓÃÀ´Éú³É¹¹½¨Á÷³ÌµÄÌØÐÔ£¬Ninja ÕâÖÖ¹¦ÄÜ¸üÉÙ£¬½â¾öÎÊÌâ¸üÃ÷È·µÄ¹¤¾ß¾Í¸üºÏÊÊ¡£
 
Ninjia µÄÉè¼ÆÔ­Ôò¾ÍÊÇ¹¹½¨½Å±¾Ò×ÓÚÈËÔÄ¶Á£¨·½±ãµ÷ÊÔ£©£¬µ«²»Ò×ÓÚÈËÖ±½ÓÊéÐ´£¨·½±ã»úÆ÷½âÎö£©¡£Í¬Ê±£¬¹¹½¨Á÷³Ì¿ÉÒÔ»ñµÃ¸ü¸ßµÄÐ§ÂÊ¡£¼õÉÙ¹¹½¨Ê±¼äÄÜÖ±½ÓÌá¸ß¿ª·¢Ð§ÂÊ¡£
ÓÐÊ±ºò»Ø´ð²»ºÃÎÊÌâ£¬ÊÇÒòÎªÌâÃ»¶ÁÃ÷°×¡£ ÓÐÊ±ºòÐÞ²»ÁË bug£¬ÊÇÒòÎª log Ã»¶ÁÃ÷°×¡£
ÉÏÖÜ±»Í¬ÊÂ±¨ÁËÒ»¸ö¿¨¶Ù bug£¬¿´ÁËÒ»Õó·¢ÏÖ£¬Õæ»úÉÏÃ»ÓÐ£¬Ä£ÄâÆ÷ÉÏÓÐ£¬¾ÍÈÏÎªÊÇÄ£ÄâÆ÷µÄ bug£¬²»ÖØÒª£¬È»ºó¾ÍÃ»ÔÚÉîÈë£¬¾Í²»¹ÜÁË¡£
Èç¹ûÒªÎÒ¸øÄêÇáÈË½¨Òé£¬ÄÇÃ´ÎÒµÄ½¨Òé¾ÍÊÇÑ¡ÔñÊ±£¬ÒªÉ÷Ö®ÓÖÉ÷£¬ÓÈÆä¶ÔÄã²»¿É°Ñ¿ØµÄÊÂÇé¡£ºÜ¶àÊ±ºò£¬ÔÙÀ´Ò»´ÎµÄ³É±¾£¬ÕæµÄÊÇÌ«´óÁË¡£
È¥ÄêÀûÓÃÒµÓàÊ±¼ä£¬¿ª·¢ÁËÒ»¿îÆÁÄ»²âÁ¿Ó¦ÓÃ ¡ª¡ª PixelsMeasure[1]£¬ÕâÆªÎÄÕÂ×Ü½áÒ»ÏÂÕâ¶ÎÊ±¼äµÄ¾­ÀúºÍ¸ÐÎò¡£
×î½ü¿Í»§Óöµ½Ò»¸öÏßÉÏµÄÐÔÄÜÎÊÌâ£¬¿´ÁËÁ½ÌìÃ»½â¾ö£¬×îºó±»ÎÒÃÇÍ¬ÊÂÒ»¸öÐ¡Ê±¸ø·¢ÏÖÎÊÌâ£¬²¢Ìá¹©ÁËÒ»¸öÁ½ÐÐ´úÂëµÄÐÞ¸´·½°¸£¬»º½âÁËÎÊÌâ£¬ÉÏÏßºóµÃµ½ÁËÓÃ»§µÄÈÏ¿É¡£µ«ÊÇ¿Í»§ÔÚ»Ø¹ËµÄÊ±ºò£¬Ó²ËµÊÇÃ»ÓÐ·¢
ÏÖÖ÷ÒªÔ­Òò£¬Ö»ÊÇÐÞ¸´ÁËÒ»¸ö´úÂë»µÎ¶µÀµÄÎÊÌâ£¬ÈÃÈË±¶¸ÐÎÞÄÎ£¡
×î½ü³¢ÊÔÓÃÁË Debug Memory Graph ºÍ Xcode Instruments£¬²»ÓÃ²»ÖªµÀ£¬Ò»ÓÃÏÅÒ»Ìø¡£ÎÒ·¢ÏÖ PixelsMeasure[1] µÚÒ»´Î²âÁ¿ºó£¬´´½¨ÁË 30 
¶àÍò¸ö¶ÔÏó£¬È»ºó×¤ÁôÔÚÄÚ´æÖÐ¡£µ¼ÖÂ¼´Ê¹²»²âÁ¿Ê±£¬ÄÚ´æÒ²Õ¼ÓÃ¹ý´ó¡£Ò»·­ÑÐ¾¿·¢ÏÖ£¬ÊÇ×Ô¼º×Ô¶¨ÒåÁËÒ»¸öµÚÈý·½¿â³öµÄÎÊÌâ 
°ëÄêÀ´£¬ChatGPT (»ùÓÚ GPT ¼Ü¹¹¿ª·¢µÄ´óÐÍÓïÑÔÄ£ÐÍ) ³¹µ×µß¸²ÁËÈËÃÇ¶ÔÈË¹¤ÖÇÄÜµÄÈÏÊ¶£¬¸øºÜ¶àÐÐÒµ¶¼´øÀ´ÁËÇ°ËùÎ´ÓÐµÄ³å»÷¡£ÓÈÆäÔÚ±àÂë·½Ãæ£¬ÄÜÇá¶øÒ×¾ÙµØÐ´³ö¶íÂÞË¹·½¿é¡¢Ì°³ÔÉß¡¢1024 µÈÐ¡ÓÎÏ·£¬ÄÜ
Ð´³öµçÓ°ÍÆ¼öµÈ¿ÉÉÏÏßµÄÓ¦ÓÃ³ÌÐò¡£ÔÚ³öÉ«Íê³É±àÂëÈÎÎñµÄÍ¬Ê±£¬±àÂëÖÊÁ¿ºÍÐ§ÂÊ¶¼ÈÃÈËÕðº³¡£ÒÔÖÁÓÚºÜ¶àÈË¿ªÊ¼½¹ÂÇ£¬¾õµÃ³ÌÐòÔ±ÀëÏÂ¸Ú²»Ô¶ÁË¡£ÎªÁËÁË½âÆäÄÜÁ¦£¬ÎÒÉîÈëÌåÑéÁËÒ»»Ø¡£¾ªÆæµØ·¢ÏÖ£¬GPT 
Ê®·ÖÀûºÃ³ÌÐòÔ±£¬ÓÈÆäÀûºÃ³ÌÐòÔ±¡£
×î½ü¿´ÁËºÜ¶àÊÓÆµ£¬·¿³µÂÃÐÐ¡¢Ä¦ÂÃ¡¢ÆïÐÐºÍ·òÆÞÆïÐÐ£¬Õâ¸öÐÐÒµÔ½À´Ô½¾íÁË¡£µ«ÊÇÎÒÓÖºÜÏÛÄ½ËûÃÇ£¬ÄÜ³Ë×ÅÄêÇáµÄÊ±ºò£¬×öÕâÐ©ÊÂÇé£¬ÅÄÕâÐ©ÊÓÆµ£¬Õâ¾ÍÊÇËûÃÇÈËÉúµÄ¼ÇÂ¼£¬ÊÇËûÃÇµÄ×÷Æ·¡£
¸ÕìÅÒ«ÁËÒ»²¨×Ô¼ºµÄË¯ÃßÖÊÁ¿£¬½á¹ûÕâÖÜ¾ÍÓöµ½ÁËÎÊÌâ¡£²»ÖªµÀÊÇºÈÁË¿§·È£¬»¹ÊÇ½¹ÂÇ£¬×ÜÖ®£¬ÍíÉÏË¯²»×ÅÁË¡£
~
×î½ü±» Keyboardshortcuts ¿¨ÁËÈýÖÜ£¬ÕâÖÖÖÕÓÚÕÒµ½ÁË·½°¸£¬Áø°µ»¨Ã÷¡£×öÒ»¼þÊÂÇé£¬ÕæµÄÊÇ²»ÄÜÌ«ÄÑ£¬Ì«ÄÑÁËÈÝÒ×·ÅÆú£¬»òÕßÍÏÑÓ¡£Ò²²»ÄÜÌ«¼òµ¥£¬Ì«¼òµ¥»á¾õµÃÎÞÁÄ¡£Keyboardshortcuts 
µÄ·½°¸ËäÈ»²»ÍêÃÀ£¬µ«ÊÇÒ²ÃãÇ¿ÄÜÓÃ£¬ÄÜ´ïµ½ÕýÈ·µÄÊ¹ÓÃËü£¬¾Í»á·¢ÏÖËüÄÜÓÃ¡£Èç¹ûÄãÍæµÄ»¨Ò»µã£¬Ëü¿ÉÄÜ²»Õý³£¹¤×÷¡£ÎªÁË´ó²¿·ÖÈËÄÜÓÃ£¬ÏÈÕâÑù°É¡£
ËÄÖÜÇ°·¢ÏÖ£¬×Ô¼º¶Ô¹ÜÀíÖªÊ¶Ò»ÎÞËùÖª¡£½Ó×Å±¨ÁËÍø¿Î£¬Ñ§ÁË¼¸½Ú¿Î£¬×î´óµÄÊÕ»ñ¾ÍÊÇ¿ªÀ«ÁËÑÛ½ç£¬²¢ÖªµÀÁËÓÐÒ»±¾¾Ã¸ºÊ¢ÃûµÄ¹ÜÀíÑ§Êé¼®¡¶×¿ÓÐ³ÉÐ§µÄ¹ÜÀíÕß¡·£¬Ëæ¼´ÂòÁË¡£
´Óºó¶Ë×ªÐÐ iOS ¿ª·¢Ò»ÄêÁË£¬Ò»Ö±Ã»ÓÐÑÐ¾¿¹ýÍøÂçÇëÇóµÄ API£¨ÏîÄ¿ÉÏÓÐÏÖ³ÉµÄ·â×°£©¡£Ö®Ç°ÊÖÐ´ÏîÄ¿µÄÊ±ºò£¬×Ü¸Ð¾õ¶Ô URLSession 
Ò»Öª°ë½â£¬ÓÌÔ¥ÁËºÜ¶à´Î¡£Õâ´ÎÀûÓÃ¼ÙÆÚ£¬ÖÕÓÚÓÐ»ú»áÄÜÍêÕûµÄ¶ÁÁËÒ»±é¹Ù·½ÎÄµµ£¬×Ü½áÁËÒ»ÏÂ£¬ÓÚÊÇÓÐÁËÕâÆªÎÄÕÂ¡¶URL ¼ÓÔØÏµÍ³£¨URL Loading System£©¡·[1]¡£Á·Ï°ÁËÒ»°Ñ£¬ÓÚÊÇÓÐÁËÕâ¸ö repo 
zddhub/url-loading-system[2]¡£Íê³ÉºóÍøÉÏËÑÁËÒ»°Ñ£¬·¢ÏÖ´ó¶¼ÊÇÕÕ°á¹Ù·½ÎÄµµ£¬»òÕßÊÇ¼¸ÄêÇ°µÄÀÏÎÄÕÂ£¬»¹ÊÇÓÐÂúÂúµÄ³É¾Í¸Ð¡£ËüÖÁÉÙÊÇ´ïµ½ÁËÎÒÐ´ÎÄÕÂµÄÄ¿µÄ ¡ª¡ª ¶Ô×Ô¼ºÓÐÓÃ¡£
Ö÷¶¯Ñ§Ï°ÐèÒªºÜÇ¿µÄ×ÔÖÆÁ¦£¬ÎÒºÜÄÑ×öµ½£¬»ØÍ·¿´¿´×Ô¼ºµÄ³É³¤£¬±»¶¯Ñ§Ï°Õ¼ÁËÖØÒªµÄÒ»¿é¡£
uint16_t u16AverageFilter(uint16_t Value[])
{
  uint16_t val, average;
  uint8_t min;
  uint32_t sum;
  if (Value[0] < Value[1])
  {
    val = Value[0];
    min = 0;
  }
  else
  {
    val = Value[1];
    min = 1;
  }
  if (Value[2] < val)
  {
    val = Value[2];
    min = 2;
  }
  sum = (uint32_t)Value[0] + Value[1] + Value[2];
  average = sum / 3;
  if ((average - Value[min]) > 10)
  {
    average = (sum - Value[min]) / 2;
  }
  return average;
}
/* æå·æ°ç¼å­åå¥ 6ä¸ª CGRAMä¸­ */
void Write6CGRAM(unsigned char x)
{
	unsigned char i,j;

    j = x + 40;
	gpio_set_level(PIN_NUM_CS,0);//CSæä½
	usleep(1);
	VFDWriteData(0x40 + 0);//å°åå¯å­å¨èµ·å§ä½ç½®	
	for (i = x; i < j; i++)
	{
		VFDWriteData(refreshData[i]);
	}
	gpio_set_level(PIN_NUM_CS,1);//CSæé«
    usleep(2);
}
void BootAnimation()
{
	unsigned char cnt,i;
	unsigned char G1Temp[5][5] = {
   {0x03, 0x0b, 0x0b, 0x03, 0x03},// 
   {0x03, 0x07, 0x0b, 0x01, 0x05},//
   {0x03, 0x03, 0x0f, 0x07, 0x01},//
   {0x0f, 0x03, 0x0b, 0x01, 0x01},//
   {0x00, 0x00, 0x00, 0x00, 0x00},//
};

	i = 0;
	memset(ADbuff,0xff,13);
	//ä¸æ¾ç¤ºç¹
	ADbuff[6] &= 0xfe;
	ADbuff[7] &= 0xfe;
	ADbuff[8] &= 0xfe;
	ADbuff[9] &= 0xfe;
	ADbuff[10] &= 0xfe;
	ADbuff[11] &= 0xfe;
	VFDWriteAllADRAMAndShow(ADbuff);
	//BootSound();
	for (cnt = 1; cnt < 13; cnt++)
	{
		VFDWriteStrAndShow(cnt, ">");
		WriteCGRAM(6,&G1Temp[0][0],i);
		VFDWriteOneDIYCharAndShow(0,6);//æCGRAM 6çç¼å­æ¾ç¤ºå°G1ä¸
		i++;
		if(i >= 4) i = 0;
		vTaskDelay(50 / portTICK_PERIOD_MS);
	}
	//DDiDi();

	vTaskDelay(200 / portTICK_PERIOD_MS);
	DisappearingAnimation();//æ¾ç¤ºæ¶å¤±å¨ç»

	/*
	VFDWriteStrAndShow(0, " ");
	//WriteCGRAM(6,&G1AnimationTemp[0][0],4);//å³é­G1æ¾ç¤º
	//VFDWriteOneDIYCharAndShow(0,6);//æCGRAM 6çç¼å­æ¾ç¤ºå°G1ä¸
	vTaskDelay(20 / portTICK_PERIOD_MS);

	//å³é­ADæ¾ç¤º
	memset(ADbuff,0x00,13);
	for (cnt = 0; cnt < 13; cnt++)
	{
		VFDWriteOneADRAMAndShow(cnt,ADbuff[cnt]);
		vTaskDelay(20 / portTICK_PERIOD_MS);
	}
	*/
}
A

The Application profile defines an architecture aimed at high performance
processors, supporting a virtual memory system using a Memory Management
Unit (MMU) and therefore capable of running fully featured operating systems.
Support for the ARM and Thumb instruction sets is provided.
ARMv7-A, the Application profile, is implemented by all Cortex-A series
processors, and by processors developed by companies who have licensed the
ARM architecture. At the beginning of 2014, just under three billion Cortex-A
Series chips had been shipped.
The ARMv8-A architecture, which is not described in this book, supports the
AArch32 state, a 32-bit implementation of the architecture that is backwards
compatible with ARMv7-A.

ARM DEN0013D
ID012214

R

The Real-time profile defines an architecture aimed at systems that require
deterministic timing and low interrupt latency. There is no support for a virtual
memory system, but memory regions can be protected using a simple Memory
Protection Unit (MPU).

M

The Microcontroller profile defines an architecture aimed at low cost systems,
where low-latency interrupt processing is vital. It uses a different exception
handling model to the other profiles and supports only a variant of the Thumb
instruction set.

Copyright Â© 2011 â 2013 ARM. All rights reserved.
Non-Confidential
The Cortex-A8 processor
The ARM Cortex-A8 processor, has the ability to scale in speed from 600MHz to greater than
1GHz. The Cortex-A8 processor can meet the requirements for power-optimized mobile
devices needing operation in less than 300mW; and performance-optimized consumer
applications requiring 2000 Dhrystone MIPS. It is available in a number of different devices,
including the S5PC100 from Samsung, the OMAP3530 from Texas Instruments and the
The Cortex-A9 processor
The ARM Cortex-A9 processor is a power-efficient and popular high performance choice in low
power or thermally constrained cost-sensitive devices.
It is currently shipping in large volumes for smartphones, digital TV, consumer and enterprise
applications. The Cortex-A9 processor provides an increase in performance of greater than 50%
compared to the Cortex-A8 processor. The Cortex-A9 processor can be configured with up to
four cores delivering peak performance when required. Configurability and flexibility makes
the Cortex-A9 processor suitable for wide variety of markets and applications.
// º¯ÊýÓÃÓÚ¼ì²âÁ´±íÖÐÊÇ·ñÓÐ»·£¬²¢·µ»Ø»·µÄÆðÊ¼½Úµã                                                                                      
ListNode* detectCycle(ListNode* head) {                                                                                                
    if (head == NULL || head->next == NULL) return NULL;           
                                 
    ListNode *slow = head, *fast = head->next;                                                                                         
    while (slow != fast) {                                                                                                             
        if (fast == NULL || fast->next == NULL) return NULL; // Èç¹ûfast»òfast->nextµ½Á´±íÎ²²¿£¬ÔòÎÞ»·                                 
        slow = slow->next;        // ÂýÖ¸ÕëÏòÇ°×ßÒ»²½              
        fast = fast->next->next;  // ¿ìÖ¸ÕëÏòÇ°×ßÁ½²½                                                                                  
    }                                                                                                                                  
                                 
    // µ±fastºÍslowÏàÓöÊ±£¬ÖØÖÃfastÎªhead£¬È»ºófastºÍslowÒ»ÆðÏòÇ°×ß£¬Ö±µ½ÔÙ´ÎÏàÓö                                                      
    fast = head;                                                   
    while (fast != slow) {                                                                                                             
        fast = fast->next;                                         
        slow = slow->next;                                                                                                             
    }                                                              
                                                                                                                                       
    // ÔÙ´ÎÏàÓöµÄµØ·½¼´Îª»·µÄÆðÊ¼½Úµã                                                                                                  
    return fast;                                                   
}                                                                  
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {                                                 
    struct ListNode *pA = headA, *pB = headB;                                                                                          
    int lenA = 0, lenB = 0;                                                                                                            
                                                                                                                                       
    // Step 1: Traverse both lists to find out their lengths                                                                           
    while (pA) {                                                                                                                       
        pA = pA->next;                                                                                                                 
        lenA++;                                                                                                                        
    }                                                                                                                                  
    while (pB) {                                                                                                                       
        pB = pB->next;                                                                                                                 
        lenB++;                                                                                                                        
    }                                                                                                                                  
                                                                                                                                       
    // Step 2: Align nodes of both lists                                                                                               
    int diff = lenA - lenB;                                                                                                            
    if (lenA > lenB) {                                                                                                                 
        while (diff--) pA = pA->next;                                                                                                  
    } else {                                                       
        while (diff++) pB = pB->next;                                                                                                  
    }                                                                                                                                  
                                                                                                                                       
    // Step 3: Traverse both lists together to find intersection                                                                       
    while (pA && pB) {                                             
        if (pA == pB) {                                                                                                                
            return pA; // Found the intersection                   
        }
        pA = pA->next;
        pB = pB->next;
    }

    return NULL; // No intersection
}
// ¼ì²éÁ´±íÊÇ·ñÊÇ»ØÎÄ                                                                                                                  
int isPalindrome(ListNode* head) {
    if (head == NULL || head->next == NULL) return 1;
     
    // ¿ìÂýÖ¸ÕëÕÒµ½ÖÐµã
    ListNode *slow = head, *fast = head;
    while (fast->next != NULL && fast->next->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }
     
    // ·´×ªÁ´±íµÄºó°ë²¿·Ö
    ListNode *prev = NULL;
    while (slow->next != NULL) {
        ListNode *temp = slow->next;
        slow->next = prev;
        prev = slow;
        slow = temp;
    }
     
    // Èç¹ûfastÖ¸Õë²»Îª¿Õ£¬slowÖ¸ÏòµÄÊÇÖÐµã£¬ÐèÒªÌø¹ýÖÐµã
    if (fast->next != NULL) slow = slow->next;
     
    // ±È½ÏÇ°°ë²¿·ÖºÍºó°ë²¿·Ö
    ListNode *p1 = head, *p2 = prev;
    while (p2 != NULL) {
        if (p1->val != p2->val) return 0;
        p1 = p1->next;
        p2 = p2->next;
    }
     
    return 1;
}
struct ListNode* removeDuplicateNodes(struct ListNode* head) {
    if (head == NULL) return NULL;
     
    struct ListNode *prev = head, *curr = head->next, *temp = NULL; 
    while (curr) {
        if (prev->val == curr->val) {
            temp = curr;
            prev->next = curr->next;
            curr = curr->next;
            free(temp);
        } else {
            prev = curr;
            curr = curr->next;
        }
    }
    return head;
}
struct ListNode* removeDuplicateNodes(struct ListNode* head) {
    if (head == NULL) return NULL;
     
    struct ListNode *prev = head, *curr = head->next, *temp = NULL; 
    while (curr) {
        if (prev->val == curr->val) {
            temp = curr;
            prev->next = curr->next;
            curr = curr->next;
            free(temp);
        } else {
            prev = curr;
            curr = curr->next;
        }
    }
    return head;
}
bool isFlipedString(char *s1, char *s2) {
    // ½« s1 Æ´½Óµ½×ÔÉí
    char *combined = malloc(strlen(s1) * 2 + 1);
    strcpy(combined, s1);
    strcat(combined, s1);
     
    // ¼ì²é s2 ÊÇ·ñÊÇÆ´½ÓºóµÄ×Ö·û´®µÄ×Ó´®
    bool result = strstr(combined, s2) != NULL;
     
    // ÊÍ·ÅÄÚ´æ
    free(combined);
     
    return result;
}
char* compressString(char* S) {                                                                                                        
    int len = strlen(S);                                                                                                               
    if (len <= 1) return S; // Èç¹û×Ö·û´®³¤¶ÈÐ¡ÓÚµÈÓÚ1£¬Ö±½Ó·µ»ØÔ­×Ö·û´®                                                               
                                                                                                                                       
    char *compressed = (char *)malloc(len + 1); // ÎªÑ¹ËõºóµÄ×Ö·û´®·ÖÅä¿Õ¼ä                                                            
    int j = 0; // compressedµÄË÷Òý                                                                                                     
    for (int i = 0; i < len; i++) {                                                                                                    
        char currentChar = S[i];                                                                                                       
        // ¼ÆËãµ±Ç°×Ö·ûÖØ¸´µÄ´ÎÊý                                                                                                      
        int count = 1;                                                                                                                 
        while (i + 1 < len && S[i + 1] == currentChar) {                                                                               
            i++;                                                                                                                       
            count++;                                                                                                                   
        }                                                                                                                              
        // ½«×Ö·ûºÍÆäÖØ¸´´ÎÊýÌí¼Óµ½Ñ¹Ëõ×Ö·û´®ÖÐ                                                                                        
        compressed[j++] = currentChar;                                                                                                 
        if (count > 1) {                                                                                                               
            sprintf(&compressed[j], "%d", count);                                                                                      
            j += strlen(&compressed[j]); // ¸üÐÂË÷ÒýÎ»ÖÃ                                                                               
        }                                                                                                                              
    }                                                                                                                                  
    compressed[j] = '\0'; // È·±£×Ö·û´®ÒÔ¿Õ×Ö·û½áÎ²                                                                                    
                                                                                                                                       
    // ±È½ÏÔ­Ê¼×Ö·û´®ºÍÑ¹Ëõ×Ö·û´®µÄ³¤¶È£¬·µ»Ø½Ï¶ÌµÄÒ»¸ö                                                                                
    if (j >= len) {                                                                                                                    
        free(compressed);                                                                                                              
        return S;                                                                                                                      
    }                                                                                                                                  
    return compressed;                                                                                                                 
} 
void replaceSpaces(char *str, int length) {
    int spaceCount = 0;
    int i, j;
     
    // ¼ÆËã¿Õ¸ñÊýÁ¿
    for (i = 0; i < length; i++) {
        if (str[i] == ' ') spaceCount++;
    }
     
    // ´Ó×Ö·û´®Ä©Î²¿ªÊ¼£¬ÎªÃ¿¸ö¿Õ¸ñÌæ»»Îª"%20"
    for (i = length - 1, j = length + spaceCount * 2 - 1; i >= 0; i--) {
        if (str[i] == ' ') {
            str[j--] = '0';
            str[j--] = '2';
            str[j] = '%';
        } else {
            str[j--] = str[i];
        }
    }
}
bool checkPermutation(char *s1, char *s2) {
    if (strlen(s1) != strlen(s2)) return false;                                                                                        
                                                                                                                                       
    int count[26] = {0}; // ¼ÙÉèÖ»°üº¬Ð¡Ð´×ÖÄ¸
                                                                                                                                       
    // Í³¼Æs1ÖÐÃ¿¸ö×Ö·ûµÄ¸öÊý                                      
    for (int i = 0; s1[i] != '\0'; i++) {                                                                                              
        count[s1[i] - 'a']++;    
    }                                                                                                                                  
                                                                   
    // Í³¼Æs2ÖÐÃ¿¸ö×Ö·ûµÄ¸öÊý£¬²¢¼ì²éÊÇ·ñÓës1ÏàÍ¬
    for (int i = 0; s2[i] != '\0'; i++) {
        count[s2[i] - 'a']--;                                      
        if (count[s2[i] - 'a'] < 0) return false; // Èç¹û³öÏÖ¸ºÊý£¬ÔòËµÃ÷s2ÓÐ¶àÓàµÄ×Ö·û
    }
     
    return true; // Èç¹ûËùÓÐ¼ÆÊý¶¼Îª0£¬ÔòËµÃ÷ÊÇ×Ö·ûÖØÅÅ
}
int countWays(int *nums, int numsSize, int target) {
    // dpÊý×é£¬dp[i]±íÊ¾ÐÎ³ÉiµÄ×éºÏÊýÁ¿
    int dp[target + 1];                                                                                                                
    // ³õÊ¼»¯dpÊý×é£¬0µÄ×éºÏÊýÎª1
    for (int i = 0; i <= target; i++) {
        dp[i] = 0;                                                                                                                     
    }
    dp[0] = 1; // ºÍÎª0µÄ×éºÏÊýÎª1

    // ±éÀúÊý×é£¬¸üÐÂdpÊý×é
    for (int i = 0; i < numsSize; i++) {
        for (int j = target; j >= nums[i]; j--) {
            dp[j] += dp[j - nums[i]];
        }
    }

    return dp[target];
}
int countSpecialCharacters(const char* word) {                                                                                         
    int count = 0;                                                                                                                     
    bool exists[26][2] = {false}; // ÓÃÓÚ¼ÇÂ¼Ã¿¸ö×Ö·ûµÄ´óÐ¡Ð´ÐÎÊ½ÊÇ·ñ´æÔÚ                                                              
                                                                                                                                       
    // ±éÀú×Ö·û´®£¬¼ÇÂ¼Ã¿¸ö×Ö·ûµÄ´óÐ¡Ð´ÐÎÊ½                                                                                            
    for (int i = 0; word[i] != '\0'; i++) {                                                                                            
        char lower = tolower(word[i]);                                                                                                 
        char upper = toupper(word[i]);                                                                                                 
        if (lower == upper) continue; // Èç¹ûÊÇÍ¬Ò»¸ö×Ö·ûµÄ´óÐ¡Ð´ÐÎÊ½£¬Ìø¹ý                                                            
                                                                                                                                       
        // ¼ì²éÁíÒ»¸öÐÎÊ½ÊÇ·ñ´æÔÚ                                                                                                      
        int index = lower - 'a';                                   
        if (!exists[index][0] && !exists[index][1]) {                                                                                  
            exists[index][lower == word[i]] = true; // ±ê¼Ç´æÔÚ                                                                        
        }                                                                                                                              
    }                                                              
                                                                                                                                       
    // ¼ÆËãÌØÊâ×Ö·ûµÄÊýÁ¿                                                                                                              
    for (int i = 0; i < 26; i++) {                                 
        if (exists[i][0] && exists[i][1]) count++;                                                                                     
    }

    return count;
}
int findPermutationDifference(char *s, char *t) {                                                                                      
    int index[26] = {0}; // ¼ÙÉèsºÍt¶¼ÊÇÐ¡Ð´×ÖÄ¸                                                                                       
    int sum = 0;                                                                                                                       
    int sLength = strlen(s);                                                                                                           
    int tLength = strlen(t);                                                                                                           
                                                                   
    // ¼ÇÂ¼sÖÐ×Ö·ûµÄÎ»ÖÃ                                                                                                               
    for (int i = 0; i < sLength; i++) {                                                                                                
        index[s[i] - 'a'] = i;                                                                                                         
    }                                                                                                                                  
                                                                                                                                       
    // ¼ÆËãÅÅÁÐ²î                                                                                                                      
    for (int i = 0; i < tLength; i++) {                                                                                                
        sum += abs(index[t[i] - 'a'] - i);                                                                                             
    }                                                                                                                                  
                                                                                                                                       
    return sum;                                                                                                                        
}                                                                                                                                      
int findWinningPlayer(int* skills, int skillsSize, int k) {                                                                            
    int queue[skillsSize], head = 0, tail = 0;                                                                                         
    // ³õÊ¼»¯¶ÓÁÐ£¬½«ËùÓÐÍæ¼Ò±àºÅÒÀ´Î·ÅÈë¶ÓÁÐ                                                                                          
    for (int i = 0; i < skillsSize; ++i) {                                                                                             
        queue[tail++] = i;                                                                                                             
    }                                                                                                                                  
    int winStreak[skillsSize] = {0}; // ¼ÇÂ¼Ã¿¸öÍæ¼ÒµÄÁ¬Ê¤´ÎÊý                                                                         
    int winner = -1, maxStreak = 0; // ¼ÇÂ¼Ó®¼ÒºÍ×î´óÁ¬Ê¤´ÎÊý                                                                          
                                                                                                                                       
    while (head != tail) {                                                                                                             
        // È¡³ö¶ÓÁÐÍ·²¿µÄÁ½¸öÍæ¼Ò±àºÅ                                                                                                  
        int player1 = queue[head++];                                                                                                   
        int player2 = queue[head++];                                                                                                   
        // Ä£Äâ±ÈÈü£¬¼¼ÄÜµÈ¼¶¸ßµÄÊ¤³ö                                                                                                  
        if (skills[player1] > skills[player2]) {                                                                                       
            winStreak[player1]++;                                                                                                      
            if (winStreak[player1] > maxStreak) {                                                                                      
                winner = player1;                                                                                                      
                maxStreak = winStreak[player1];                                                                                        
            }                                                                                                                          
        } else {                                                                                                                       
            winStreak[player2]++;                                                                                                      
            if (winStreak[player2] > maxStreak) {                                                                                      
                winner = player2;                                                                                                      
                maxStreak = winStreak[player2];                                                                                        
            }                                                                                                                          
        }                                                                                                                              
        // Ê¤Õß»Øµ½¶ÓÁÐÍ·²¿                                                                                                            
        queue[tail++] = (player1 == winner) ? player1 : player2;                                                                       
    }                                                                                                                                  
    return winner;                                                                                                                     
}                                                                                                                                      
bool checkIfGridSatisfiesConditions(int** grid, int gridSize, int* gridColSize) {                                                     
    for (int i = 0; i < gridSize; ++i) {                                                                                               
        for (int j = 0; j < gridColSize[i]; ++j) {
            // ¼ì²éÏÂÃæµÄ¸ñ×Ó
            if (i < gridSize - 1 && grid[i][j] != grid[i + 1][j]) { 
                return false;
            }
            // ¼ì²éÓÒ±ßµÄ¸ñ×Ó
            if (j < gridColSize[i] - 1 && grid[i][j] == grid[i][j + 1]) {
                return false;
            }
        }
    }
    return true;
}
int sumDigitDifferences(int* nums, int numsSize) {                                                                                     
    int result = 0;                                                                                                                    
    int maxNum = nums[0];                                                                                                              
                                                                                                                                       
    // ÕÒ³öÊý×éÖÐµÄ×î´óÊý£¬ÒÔÈ·¶¨ÊýÎ»³¤¶È                                                                                              
    for (int i = 1; i < numsSize; ++i) {                                                                                               
        if (nums[i] > maxNum) {                                                                                                        
            maxNum = nums[i];                                                                                                          
        }                        
    }                                                                                                                                  
     
    int digitLength = (int)log10(maxNum) + 1;
     
    // ¶ÔÓÚÃ¿¸öÊýÎ»
    for (int j = 0; j < digitLength; ++j) {
        int* count = (int*)calloc(10, sizeof(int)); // ³õÊ¼»¯Ã¿¸öÊý×Ö³öÏÖµÄ´ÎÊý
         
        // Í³¼ÆÃ¿Ò»Î»ÉÏÃ¿¸öÊý×Ö³öÏÖµÄ´ÎÊý
        for (int i = 0; i < numsSize; ++i) {
            int digit = (nums[i] / pow(10, j)) % 10;
            count[digit]++;
        }
         
        // ¼ÆËãÃ¿Ò»Î»ÉÏÊý×Ö²»Í¬¶ÔµÄÊýÁ¿
        for (int i = 0; i < 10; ++i) {
            result += count[i] * (numsSize - count[i]);
        }
         
        free(count);
    }
     
    return result;
}
#include <stdlib.h>                                                                                                                    
                                                                                                                                       
int* findOccurrences(int* nums, int numsSize, int* queries, int queriesSize, int x, int* returnSize) {                                 
    // ¶¯Ì¬·ÖÅäÊý×éÒÔ´æ´¢²éÑ¯½á¹û                                                                                                      
    int* answer = (int*)malloc(queriesSize * sizeof(int));                                                                             
    *returnSize = queriesSize;                                                                                                         
                                                                                                                                       
    // ±éÀúËùÓÐ²éÑ¯                                                                                                                    
    for (int i = 0; i < queriesSize; ++i) {                                                                                            
        int count = 0; // ÓÃÓÚ¼ÆÊýx³öÏÖµÄ´ÎÊý                                                                                          
        // ÔÚnumsÖÐ²éÕÒx                                                                                                               
        for (int j = 0; j < numsSize; ++j) {                                                                                           
            if (nums[j] == x) {                                                                                                        
                ++count;                                                                                                               
                // ¼ì²éÊÇ·ñÊÇËùÐèµÄµÚk¸öx                                                                                              
                if (count == queries[i]) {                                                                                             
                    answer[i] = j; // ±£´æË÷Òý                                                                                         
                    break; // Ìø³öÄÚ²ãÑ­»·                                                                                             
                }                                                                                                                      
            }                                                      
        }                                                                                                                              
        // Èç¹ûx³öÏÖ´ÎÊý²»×ãqueries[i]£¬ÔòÉèÖÃ´ð°¸Îª-1                                                                                 
        if (count < queries[i]) {                                                                                                      
            answer[i] = -1;                                                                                                            
        }
    }
     
    return answer;
}
#define MOD (1000000007)                                                                                                               
                                                                                                                                       
int maxSumSubsequence(int *nums, int numsSize, int *queries, int queriesSize) {                                                        
    long long dp[50010]; // ¼ÙÉèÊý×é³¤¶È²»»á³¬¹ý50000                                                                                  
    long long sum = 0;                                                                                                                 
    long long prefixSum[50010] = {0};                                                                                                  
                                                                                                                                       
    // ³õÊ¼»¯dpÊý×éºÍÇ°×ººÍ
    for (int i = 0; i < numsSize; i++) {
        prefixSum[i + 1] = (prefixSum[i] + nums[i] + MOD) % MOD;
        dp[i] = (i > 0) ? (prefixSum[i] - prefixSum[i - 1] + MOD) % MOD : nums[0];
        sum = (sum + dp[i]) % MOD;
    }

    // ´¦Àí²éÑ¯
    for (int i = 0; i < queriesSize; i++) {
        int pos = queries[2 * i]; 
        int val = queries[2 * i + 1];
        // ¸üÐÂnumsÊý×éºÍÇ°×ººÍ
        nums[pos] = val;
        prefixSum[pos + 1] = (prefixSum[pos] + val + MOD) % MOD;
        // ÖØÐÂ¼ÆËãdpÊý×é
        for (int j = pos; j < numsSize; j++) {
            dp[j] = (j > 0) ? (prefixSum[j] - prefixSum[j - 1] + MOD) % MOD : nums[j];
            sum = (sum + dp[j]) % MOD;
        }
    }

    return (int)sum;
}
bool isSpecialArray(int *nums, int numsSize, int *queries, int queriesSize, int *answer, int answerSize) {                             
    for (int i = 0; i < queriesSize; ++i) {                                                                                            
        int from = queries[i * 2];                                                                                                     
        int to = queries[i * 2 + 1];                                                                                                   
        bool isSpecial = true;                                                                                                         
        for (int j = from; j < to && isSpecial; ++j) {                                                                                 
            if ((nums[j] % 2) == (nums[j + 1] % 2)) {                                                                                  
                isSpecial = false;
            }
        }
        answer[i] = isSpecial;
    }
    return true;
}
int findTheXOR(int* nums, int numsSize) {                                                                                              
    int xorAll = 0;                                                                                                                    
    for (int i = 0; i < numsSize; i++) {                                                                                               
        xorAll ^= nums[i]; // ¼ÆËãËùÓÐÊý×ÖµÄXOR                                                                                        
    }                                                                                                                                  
    int xorOnce = 0;                                                                                                                   
    for (int i = 0; i < numsSize; i++) {                                                                                               
        int count = 0;                                                                                                                 
        for (int j = 0; j < numsSize; j++) {                                                                                           
            if (nums[i] == nums[j]) count++;                                                                                           
            if (count > 1) break;                                                                                                      
        }
        if (count == 1) xorOnce ^= nums[i]; // ¼õÈ¥³öÏÖÒ»´ÎµÄÊý×ÖµÄXOR
    }
    return xorAll ^ xorOnce; // ·µ»Ø×îÖÕ½á¹û
}
                                                                                                                                       
// ±È½Ïº¯Êý£¬ÓÃÓÚÅÅÐò                                                                                                                  
int compare(const void *a, const void *b) {                                                                                            
    int *meetA = (int *)a;                                                                                                             
    int *meetB = (int *)b;                                                                                                             
    return meetA[0] - meetB[0];                                                                                                        
}                                                                                                                                      

// Ö÷º¯Êý
int countDaysWithoutMeetings(int days, int **meetings, int meetingsSize) {
    // ÌØÊâÇé¿ö´¦Àí
    if (days < 1 || meetingsSize == 0) return days;
     
    // ¶Ô»áÒéÊý×é½øÐÐÅÅÐò
    qsort(meetings, meetingsSize, sizeof(int[2]), compare);
     
    int count = 0;
    int start = 1, end = 0;
     
    // ±éÀú»áÒéÊý×é£¬ºÏ²¢ÖØµþµÄ»áÒé
    for (int i = 0; i < meetingsSize; i++) {
        if (meetings[i][0] > end) {
            // Èç¹ûµ±Ç°»áÒé¿ªÊ¼Ê±¼ä´óÓÚÉÏÒ»¸ö»áÒéµÄ½áÊøÊ±¼ä£¬¼ÆËã¼ä¸ôÌìÊý
            count += meetings[i][0] - start - 1;
            start = meetings[i][1] + 1; // ¸üÐÂ¿ªÊ¼Ê±¼ä
            end = meetings[i][1]; // ¸üÐÂ½áÊøÊ±¼ä
        } else {
            // ·ñÔò£¬ºÏ²¢»áÒéÊ±¼ä¶Î
            end = (meetings[i][1] > end) ? meetings[i][1] : end;
        }
    }
     
    // ×îºóÒ»¸ö»áÒé½áÊøºóµ½days½áÊøµÄÌìÊý
    count += (days > end) ? (days - end) : 0;
     
    return count;
}
// ¶¯Ì¬¹æ»®½â¾öÕÒ³ö·ÖÊý×îµÍµÄÅÅÁÐÎÊÌâ                              
int findMinScorePermutation(int n, int nums[]) {                   
    // ×´Ì¬±íÊ¾£ºdp[i] ±íÊ¾ÒÔ i ½áÎ²µÄÅÅÁÐµÄ×îÐ¡·ÖÊý                                                                                   
    int dp[15] = {0};                                              
    // ¼ÇÂ¼Ã¿¸öÊý×ÖµÄÎ»ÖÃ                                          
    int indices[15] = {0};                                         
    for (int i = 0; i < n; ++i) {                                  
        indices[nums[i]] = i;                                                                                                          
    }                                                                                                                                  
                                                                                                                                       
    // ³õÊ¼»¯×´Ì¬£¬ÒÔÃ¿¸öÊý×Ö½áÎ²µÄÅÅÁÐµÄ³õÊ¼·ÖÊý                  
    for (int i = 0; i < n; ++i) {                                                                                                      
        int j = indices[i];                                        
        if (i > 0) {                                                                                                                   
            dp[j] = dp[indices[i - 1]] + abs(i - nums[j]);         
        } else {                                                                                                                       
            dp[j] = 0;                                                                                                                 
        }                                                                                                                              
    }                                                                                                                                  
                                                                   
    // ¶¯Ì¬¹æ»®£¬¸üÐÂ×´Ì¬
    for (int mask = 1; mask < (1 << n); ++mask) {
        int last = __builtin_ctz(mask); // ÕÒµ½×îµÍÎ»µÄ1
        for (int i = 0; i < n; ++i) {
            if (!(mask & (1 << i))) { // i ²»ÔÚµ±Ç°maskÖÐ
                int next = indices[(i + 1) % n];
                if (dp[next] > dp[indices[last]] + abs(last - i)) { 
                    dp[next] = dp[indices[last]] + abs(last - i);
                }
            }
        }
    }
     
    // ·µ»Ø×îÓÅ½â
    return dp[indices[0]];
}

void findTwoSum(int* nums, int numsSize, int target, int* indices) {                                                                   
    int i;                                                                                                                             
    // ´´½¨Ò»¸ö¹þÏ£±í£¬ÓÃÓÚ´æ´¢ÒÑ¾­±éÀú¹ýµÄÊý×Ö¼°ÆäË÷Òý            
    int hashTable[101] = {0}; // ¼ÙÉèÊý×éÔªËØ²»»á³¬¹ý100    
                                                                   
    for (i = 0; i < numsSize; i++) {                                                                                                   
        // ¼ì²é target ¼õÈ¥µ±Ç°ÔªËØµÄÖµÊÇ·ñ´æÔÚÓÚ¹þÏ£±íÖÐ                                                                              
        if (hashTable[target - nums[i]] != 0) {                    
            // Èç¹û´æÔÚ£¬·µ»ØÕâÁ½¸öÔªËØµÄË÷Òý                                                                                          
            indices[0] = hashTable[target - nums[i]] - 1; // Êý×éË÷Òý´Ó0¿ªÊ¼                                                           
            indices[1] = i;                                        
            return;                                                                                                                    
        }                                                                                                                              
                                                                                                                                       
        // Èç¹û²»´æÔÚ£¬½«µ±Ç°ÔªËØ¼°ÆäË÷Òý´æÈë¹þÏ£±í
        hashTable[nums[i]] = i + 1; // ´æ´¢Ë÷Òý+1£¬ÒòÎªÊý×éË÷Òý´Ó0¿ªÊ¼
    }
}
void findTwoSum(int* nums, int numsSize, int target, int* indices) {                                                                   
    int i;                                                                                                                             
    // ´´½¨Ò»¸ö¹þÏ£±í£¬ÓÃÓÚ´æ´¢ÒÑ¾­±éÀú¹ýµÄÊý×Ö¼°ÆäË÷Òý            
    int hashTable[101] = {0}; // ¼ÙÉèÊý×éÔªËØ²»»á³¬¹ý100    
                                                                   
    for (i = 0; i < numsSize; i++) {                                                                                                   
        // ¼ì²é target ¼õÈ¥µ±Ç°ÔªËØµÄÖµÊÇ·ñ´æÔÚÓÚ¹þÏ£±íÖÐ                                                                              
        if (hashTable[target - nums[i]] != 0) {                    
            // Èç¹û´æÔÚ£¬·µ»ØÕâÁ½¸öÔªËØµÄË÷Òý                                                                                          
            indices[0] = hashTable[target - nums[i]] - 1; // Êý×éË÷Òý´Ó0¿ªÊ¼                                                           
            indices[1] = i;                                        
            return;                                                                                                                    
        }                                                                                                                              
                                                                                                                                       
        // Èç¹û²»´æÔÚ£¬½«µ±Ç°ÔªËØ¼°ÆäË÷Òý´æÈë¹þÏ£±í
        hashTable[nums[i]] = i + 1; // ´æ´¢Ë÷Òý+1£¬ÒòÎªÊý×éË÷Òý´Ó0¿ªÊ¼
    }
}
int minimumDifference(int *nums, int numsSize, int k) {                                                                                
    // ³õÊ¼»¯¹þÏ£±í£¬Ê¹ÓÃÊý×éÄ£Äâ                                                                                                      
    int hashTable[32] = {0}; // ¼ÙÉèintÎª32Î»                                                                                          
    hashTable[0] = 1; // °´Î»»òµÄ³õÊ¼ÖµÎª0                                                                                             
                                                                                                                                       
    int minDiff = __INT_MAX__; // ´æ´¢×îÐ¡¾ø¶Ô²îÖµ                                                                                     
    int prefixOr = 0; // °´Î»»òµÄÇ°×ººÍ                                                                                                
                                                                                                                                       
    for (int i = 0; i < numsSize; ++i) {                                                                                               
        prefixOr |= nums[i]; // ¸üÐÂÇ°×º°´Î»»ò½á¹û                                                                                     
        // ¼ì²é¹þÏ£±íÖÐÊÇ·ñ´æÔÚprefixOr - k£¬¸üÐÂ×îÐ¡¾ø¶Ô²îÖµ                                                                          
        if (hashTable[prefixOr ^ k]) {                                                                                                 
            minDiff = (minDiff < abs(k - prefixOr) ? minDiff : abs(k - prefixOr));                                                     
        }                                                          
        // ¸üÐÂµ±Ç°prefixOrÔÚ¹þÏ£±íÖÐµÄ³öÏÖ´ÎÊý                    
        hashTable[prefixOr]++;                                     
                                                                   
        // ÌØÊâÇé¿ö´¦Àí£ºÈç¹ûprefixOrÒÑ¾­ÊÇk£¬Ö±½Ó·µ»Ø0                                                                                
        if (prefixOr == k) {                                       
            return 0;                                                                                                                  
        }
    }

    return minDiff;
}
int maxTotalReward(int* rewardValues, int rewardValuesSize) {                                                                          
    // ÏÈ¶ÔÊý×é½øÐÐ½µÐòÅÅÐò                                                                                                            
    qsort(rewardValues, rewardValuesSize, sizeof(int), compare);                                                                       
                                                                                                                                       
    int totalReward = 0;                                                                                                               
    int i = 0;                                                                                                                         
    while (i < rewardValuesSize) {                                                                                                     
        // Èç¹ûµ±Ç°½±ÀøÖµ´óÓÚ×Ü½±Àø£¬ÔòÀÛ¼Ó                                                                                            
        if (rewardValues[i] > totalReward) {                                                                                           
            totalReward += rewardValues[i];                                                                                            
        } else {                                                                                                                       
            // ·ñÔòÌø¹ýµ±Ç°½±ÀøÖµ                                                                                                      
            break;                                                                                                                     
        }                                                                                                                              
        i++;                                                                                                                           
    }                                                                                                                                  
    return totalReward;                                                                                                                
}                                                                                                                                      
                                                                                                                                       
// ÓÃÓÚqsortµÄ±È½Ïº¯Êý                                                                                                                 
int compare(const void *a, const void *b) {                                                                                            
    return (*(int*)b - *(int*)a);                                                                                                      
}                                                                                                                                      
int maxTotalReward(int* rewardValues, int rewardValuesSize) {
    // åå¯¹æ°ç»è¿è¡éåºæåº
    qsort(rewardValues, rewardValuesSize, sizeof(int), compare);
    
    int totalReward = 0;
    int i = 0;
    while (i < rewardValuesSize) {
        // å¦æå½åå¥å±å¼å¤§äºæ»å¥å±ï¼åç´¯å 
        if (rewardValues[i] > totalReward) {
            totalReward += rewardValues[i];
        } else {
            // å¦åè·³è¿å½åå¥å±å¼
            break;
        }
        i++;
    }
    return totalReward;
}

// ç¨äºqsortçæ¯è¾å½æ°
int compare(const void *a, const void *b) {
    return (*(int*)b - *(int*)a);
}
int numberOfPairs(int* nums1, int nums1Size, int* nums2, int nums2Size, int k) {
    int result = 0;
    int *count = calloc(1000001, sizeof(int)); // åè®¾nums1ånums2çåç´ ä¸ä¼è¶è¿1000000

    // ç»è®¡nums2ä¸­æ¯ä¸ªæ°åå¶kåæ°çåºç°æ¬¡æ°
    for (int i = 0; i < nums2Size; i++) {
        count[nums2[i]]++; // åå§æ°åºç°æ¬¡æ°
        count[nums2[i] * k]++; // kåæ°åºç°æ¬¡æ°
    }

    // è®¡ç®ä¼è´¨æ°å¯¹çæ°é
    for (int i = 0; i < nums1Size; i++) {
        if (nums1[i] % k == 0) { // å¦ænums1[i]ä¸æ¯kçåæ°ï¼åä¸å¯è½å½¢æä¼è´¨æ°å¯¹
            result += count[nums1[i] / k];
        }
    }

    free(count);
    return result;
}
char* removeStars(char* s) {
    int len = strlen(s);
    char result[len + 1]; // +1 for null terminator
    int resultIndex = 0;
    int i = 0;

    while (i < len) {
        if (s[i] == '*') {
            // Find the smallest character on the left of '*'
            int minIndex = i - 1;
            while (minIndex >= 0 && s[minIndex] == '*') {
                minIndex = resultIndex - (i - minIndex) - 1;
            }
            if (minIndex >= 0) {
                for (int j = i - 1; j > minIndex; --j) {
                    if (s[j] < s[minIndex]) {
                        minIndex = j;
                    }
                }
                result[resultIndex++] = s[minIndex];
            }
            // Skip over the '*' and the character we are removing
            i = i + 2;
        } else {
            result[resultIndex++] = s[i++];
        }
    }
    result[resultIndex] = '\0'; // Null-terminate the result string
    strcpy(s, result); // Copy result back to the input string
    return s;
}
char *clearDigits(char *s) {
    int len = strlen(s);
    int i = 0, j = 0;
    char *result = (char *)malloc(len + 1);
    if (!result) return NULL;

    while (i < len) {
        if (s[i] >= '0' && s[i] <= '9') {
            // æ¾å°æ°å­ï¼åå·¦æ¾å°æè¿çéæ°å­å­ç¬¦
            int left = i;
            while (left > 0 && isdigit(s[left - 1])) --left;
            // è®¡ç®è¦è·³è¿çå­ç¬¦æ°
            int skip = i - left + 1;
            // è·³è¿è¿äºå­ç¬¦
            i += skip;
            // æ´æ°jçä½ç½®ï¼å ä¸ºiå·²ç»ç§»å¨äº
            j -= skip;
        } else {
            // å¤å¶éæ°å­å­ç¬¦å°ç»æå­ç¬¦ä¸²
            result[j++] = s[i];
        }
        i++;
    }
    result[j] = '\0'; // ç¡®ä¿ç»æå­ç¬¦ä¸²ä»¥ç©ºå­ç¬¦ç»å°¾
    return result;
}
int maxConsecutiveAvailable(int* seats, int seatsSize) {
    int maxCount = 0;
    int count = 0; // è®°å½å½åè¿ç»­ç©ºä½åº§ä½çæ°é

    for (int i = 0; i < seatsSize; i++) {
        if (seats[i] == 1) {
            count++; // ç©ºåº§ï¼è¿ç»­è®¡æ°å 1
        } else {
            maxCount = (count > maxCount) ? count : maxCount; // æ¯è¾å¹¶æ´æ°æå¤§è¿ç»­ç©ºä½åº§ä½æ°é
            count = 0; // éç½®è®¡æ°å¨
        }
    }
    
    // æ£æ¥æåä¸ä¸ªè¿ç»­åºå
    maxCount = (count > maxCount) ? count : maxCount;
    return maxCount;
}
## è§£é¢æè·¯
è¿ä¸ªé®é¢å¯ä»¥éè¿é¢å¤çåè´ªå¿ç­ç¥æ¥è§£å³ãé¦åï¼æä»¬éè¦çè§£æ±æè·ç¦»çæ¦å¿µï¼å³ä¸¤ä¸ªæ°å¨äºè¿å¶è¡¨ç¤ºä¸­ä¸åä½æ°çä¸ªæ°ãä¸ºäºæå¤§åæ±æè·ç¦»ï¼æä»¬åºè¯¥å¯»æ¾å·®å¼æå¤§çä¸¤ä¸ªæ°ã

// å½æ°ç¨äºè®¡ç®ä¸¤ä¸ªæ°çæ±æè·ç¦»
int hammingDistance(int x, int y) {
    int dist = 0, xorRes = x ^ y;
    while (xorRes) {
        if (xorRes & 1) dist++;
        xorRes >>= 1;
    }
    return dist;
}

// å½æ°ç¨äºæ¾å°æå¤§æ±æè·ç¦»çä¸å¯¹æ°
int maxHammingDistance(int* nums, int numsSize, int m) {
    int maxDist = 0, xorSum = 0;
    // è®¡ç®æææ°çå¼æç»æ
    for (int i = 0; i < numsSize; i++) {
        xorSum ^= nums[i];
    }
    // å¯»æ¾æ±æè·ç¦»æå¤§çä¸å¯¹æ°
    for (int i = 0; i < numsSize; i++) {
        maxDist = max(maxDist, hammingDistance(nums[i], xorSum ^ nums[i]));
    }
    return maxDist;
}

// è¾å©å½æ°ï¼ç¨äºæ¯è¾ä¸¤ä¸ªæ´æ°
int max(int a, int b) {
    return a > b ? a : b;
}
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

int findMinSumTreeLevel(TreeNode* root) {
    if (!root) return 0;
    
    int minSum = INT_MAX, minLevel = 0;
    int level = 0; // è®°å½å½åå±çº§
    struct TreeNode **queue = malloc(sizeof(TreeNode*) * 10000); // åè®¾èç¹æ°ä¸ä¼è¶è¿10000
    int front = 0, rear = 0;
    
    queue[rear++] = root;
    
    while (front < rear) {
        int count = rear - front; // å½åå±çèç¹æ°
        int levelSum = 0;
        while (count--) {
            TreeNode *node = queue[front++];
            levelSum += node->val;
            if (node->left) {
                queue[rear++] = node->left;
            }
            if (node->right) {
                queue[rear++] = node->right;
            }
        }
        if (levelSum < minSum) {
            minSum = levelSum;
            minLevel = level;
        }
        level++;
    }
    
    free(queue);
    return minLevel;
}
// å½æ°ç¨äºè®¡ç®ç¸é»åç´ çæä½æç»æ
int* getBitwiseOR(int* nums, int numsSize, int* returnSize) {
    // åéä¸ä¸ªæ°ç»ç¨äºå­å¨ç»æï¼å¶å¤§å°ä¸ºnumsSize-1
    int* result = (int*)malloc(sizeof(int) * (numsSize - 1));
    *returnSize = numsSize - 1;

    // åå§åç¬¬ä¸ä¸ªç»æä¸ºç¬¬ä¸ä¸ªåç´ 
    result[0] = nums[0];

    // éåæ°ç»ï¼ä»ç¬¬äºä¸ªåç´ å¼å§
    for (int i = 1; i < numsSize; i++) {
        // å¯¹æ¯å¯¹ç¸é»åç´ æ§è¡æä½ææä½
        result[i - 1] = nums[i - 1] | nums[i];
    }

    return result;
}

int main() {
    // ç¤ºä¾æ°ç»
    int nums[] = {1, 3, 7, 15};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int returnSize = 0;

    // è°ç¨å½æ°å¹¶æå°ç»æ
    int* res = getBitwiseOR(nums, numsSize, &returnSize);
    for (int i = 0; i < returnSize; i++) {
        printf("%d ", res[i]);
    }
    printf("\n");

    // éæ¾åéçåå­
    free(res);

    return 0;
}
// å®ä¹å¾çé»æ¥åè¡¨ç»æ
typedef struct {
    int **edges;
    int size;
} Graph;

// åå»ºå¾
Graph createGraph(int size) {
    Graph graph;
    graph.edges = (int **)malloc(size * sizeof(int *));
    for (int i = 0; i < size; i++) {
        graph.edges[i] = (int *)malloc(0 * sizeof(int)); // åå§åä¸ºç©ºæ°ç»
    }
    graph.size = size;
    return graph;
}

// æ·»å è¾¹
void addEdge(Graph *graph, int start, int end) {
    int index = start;
    graph->edges[index] = (int *)realloc(graph->edges[index], (1 + graph->edges[index][0]) * sizeof(int));
    graph->edges[index][graph->edges[index][0] + 1] = end;
    graph->edges[index][0]++;
}

// æ·±åº¦ä¼åæç´¢æ¥æ¾è·¯å¾
bool dfs(int start, int target, int *visited, Graph graph) {
    if (start == target) return true;
    visited[start] = 1;
    for (int i = 1; i <= graph.edges[start][0]; i++) {
        int next = graph.edges[start][i];
        if (!visited[next] && dfs(next, target, visited, graph)) {
            return true;
        }
    }
    return false;
}

// æ£æ¥èç¹é´æ¯å¦å­å¨éè·¯
bool findWhetherExistsPath(int n, int **graph, int start, int target) {
    if (n <= 0 || !graph || start < 0 || target < 0) return false;
    
    // è½¬æ¢è¾å¥æ ¼å¼
    Graph g = createGraph(n);
    for (int i = 0; i < n; i++) {
        int vertex = i;
        for (int j = 0; j < graph[i][0]; j++) {
            addEdge(&g, vertex, graph[i][j]);
        }
    }
    
    int *visited = (int *)calloc(n, sizeof(int)); // æ è®°æ°ç»
    return dfs(start, target, visited, g);
}

// ç¤ºä¾æµè¯
int main() {
    int n1 = 3;
    int graph1[1][2] = {{0, 1}, {0, 2}, {1, 2}, {1, 2}};
    int start1 = 0, target1 = 2;
    printf("Path exists: %s\n", findWhetherExistsPath(n1, graph1, start1, target1) ? "true" : "false");

    int n2 = 5;
    int graph2[6][2] = {{0, 1}, {0, 2}, {0, 4}, {0, 4}, {1, 3}, {1, 4}, {1, 3}, {2, 3}, {3, 4}};
    int start2 = 0, target2 = 4;
    printf("Path exists: %s\n", findWhetherExistsPath(n2, graph2, start2, target2) ? "true" : "false");

    return 0;
}
#include <stdlib.h>
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// åå»ºæå°é«åº¦æ çéå½å½æ°
TreeNode* sortedArrayToBST(int* nums, int left, int right) {
    if (left > right) return NULL;
    
    // éæ©ä¸­é´ä½ç½®çåç´ ä½ä¸ºæ ¹èç¹
    int mid = (left + right) / 2;
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
    node->val = nums[mid];
    node->left = sortedArrayToBST(nums, left, mid - 1);
    node->right = sortedArrayToBST(nums, mid + 1, right);
    
    return node;
}

// æå»ºæå°é«åº¦æ çæ¥å£å½æ°
TreeNode* sortedArrayToBSTLCCI(int* nums, int numsSize) {
    return sortedArrayToBST(nums, 0, numsSize - 1);
}
   - åå§åä¸ä¸ªéåï¼å°æ ¹èç¹å å¥éåã
   - ä½¿ç¨ä¸ä¸ªè®¡æ°å¨è®°å½å½åæ·±åº¦ã
   - å½éåéç©ºæ¶ï¼è¿è¡ä»¥ä¸æä½ï¼
     - è®°å½å½åæ·±åº¦çèç¹æ°éã
     - åå»ºå½åæ·±åº¦çé¾è¡¨ã
     - éåéåä¸­çææèç¹ï¼å°å®ä»¬æ·»å å°å½åæ·±åº¦çé¾è¡¨ä¸­ï¼å¹¶å¤çå®ä»¬çå­èç¹ï¼å°å­èç¹å å¥éåã

5. **å®ç°ç»è**ï¼å¨Cè¯­è¨ä¸­ï¼æä»¬éè¦å®ä¹åéçç»æä½æ¥è¡¨ç¤ºäºåæ èç¹åé¾è¡¨èç¹ã

## Cè¯­è¨ä»£ç å®ç°ï¼

```c
#include <stdlib.h>

// å®ä¹äºåæ èç¹
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// å®ä¹é¾è¡¨èç¹
typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

// åå»ºé¾è¡¨
ListNode* createListNode(int val) {
    ListNode* node = (ListNode*)malloc(sizeof(ListNode));
    node->val = val;
    node->next = NULL;
    return node;
}

// ä¸ºç¹å®æ·±åº¦åå»ºé¾è¡¨
ListNode** createLinkedLists(TreeNode* root, int* depths, int depthCount) {
    ListNode **lists = (ListNode**)malloc(sizeof(ListNode*) * depthCount);
    for (int i = 0; i < depthCount; i++) {
        lists[i] = NULL;
    }
    if (!root) return lists;

    // ä½¿ç¨éåå®ç°BFS
    int currentDepth = 0;
    int index = 0;
    TreeNode *node, *left, *right;
    ListNode *listNode, *prev = NULL;
    while (root != NULL) {
        int levelSize = 0; // å½åæ·±åº¦çèç¹æ°é
        for (node = root; node != NULL; node = node->right) {
            levelSize++;
            if (lists[currentDepth] == NULL) {
                lists[currentDepth] = createListNode(node->val);
                prev = lists[currentDepth];
            } else {
                prev->next = createListNode(node->val);
                prev = prev->next;
            }
        }
        root = NULL; // éç½®rootä¸ºNULLï¼ä»¥ä¾¿ä¸ä¸è½®å±çº§éå
        for (node = root; node != NULL; node = node->left) {
            if (node->left != NULL) {
                if (!root) root = node->left;
                else root = node->left->right;
                node->left = root;
            }
            if (node->right != NULL) {
                if (!root) root = node->right;
                else root = node->right->right;
                node->right = root;
            }
        }
        currentDepth++;
    }
    return lists;
}

// éæ¾é¾è¡¨åå­
void freeLinkedLists(ListNode** lists, int count) {
    for (int i = 0; i < count; i++) {
        ListNode *node = lists[i], *next;
        while (node != NULL) {
            next = node->next;
            free(node);
            node = next;
        }
    }
    free(lists);
}

// ç¤ºä¾ä½¿ç¨
int main() {
    // æå»ºç¤ºä¾äºåæ 
    TreeNode *root = NULL; // åè®¾è¿éå·²ç»æå»ºäºäºåæ 
    // ...

    // è·åæ·±åº¦
    int depth;
    // è°ç¨å½æ°åå»ºé¾è¡¨
    ListNode **lists = createLinkedLists(root, &depth, /* depthCount */);

    // ä½¿ç¨é¾è¡¨...

    // éæ¾é¾è¡¨åå­
    freeLinkedLists(lists, depth);

    return 0;
}
TreeNode* lowestCommonAncestorIV(TreeNode* root, int x, int y) {
    // å¦ææ ä¸ºç©ºæèå½åèç¹æ¯è¦æ¾çèç¹ä¹ä¸
    if (!root || root->val == x || root->val == y) {
        return root;
    }
    
    // å¨å·¦å­æ ä¸­æ¥æ¾
    TreeNode *left = lowestCommonAncestorIV(root->left, x, y);
    // å¨å³å­æ ä¸­æ¥æ¾
    TreeNode *right = lowestCommonAncestorIV(root->right, x, y);
    
    // å¦æå·¦å³å­æ é½ä¸ºç©ºï¼è¯´æä¸¤ä¸ªèç¹é½ä¸å¨å­æ ä¸­ï¼è¿åNULL
    if (!left && !right) return NULL;
    
    // å¦æå·¦å­æ åå³å­æ é½éç©ºï¼è¯´æä¸¤ä¸ªèç¹åå«å¨å·¦å³å­æ ä¸­ï¼å½åèç¹æ¯LCA
    if (left && right) return root;
    
    // å¦æå·¦å­æ éç©ºï¼è¯´æxåyé½å¨å·¦å­æ ä¸­
    // å¦æå³å­æ éç©ºï¼è¯´æxåyé½å¨å³å­æ ä¸­
    return left ? left : right;
}
int longestPalindromeSubseq(char *s) {
    int len = strlen(s);
    int *dp = (int *)malloc(sizeof(int) * len * len);
    memset(dp, 0, sizeof(int) * len * len);

    for (int i = len - 1; i >= 0; --i) {
        dp[i][i] = 1;
        for (int j = i + 1; j < len; ++j) {
            if (s[i] == s[j]) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = (dp[i + 1][j] > dp[i][j - 1]) ? dp[i + 1][j] : dp[i][j - 1];
            }
        }
    }

    int result = dp[0][len - 1];
    free(dp);
    return result;
}
int largestSubarraySum(int* nums, int numsSize, int k) {
    if (numsSize < k) return 0;
    
    int maxSum = 0, windowSum = 0;
    
    // åå§åçªå£å
    for (int i = 0; i < k; ++i) {
        windowSum += nums[i];
    }
    maxSum = windowSum;
    
    // ç§»å¨çªå£ï¼æ´æ°çªå£å
    for (int i = k; i < numsSize; ++i) {
        windowSum += nums[i] - nums[i - k];
        maxSum = (maxSum > windowSum) ? maxSum : windowSum;
    }
    
    return maxSum;
}
// å½æ°ç¨äºè¿åé¿åº¦ä¸º k çæå¤§å­æ°ç»çå
int largestSubarraySum(int* nums, int numsSize, int k) {
    if (numsSize < k) return 0;
    
    int maxSum = 0, windowSum = 0;
    
    // åå§åçªå£å
    for (int i = 0; i < k; ++i) {
        windowSum += nums[i];
    }
    maxSum = windowSum;
    
    // ç§»å¨çªå£ï¼æ´æ°çªå£å
    for (int i = k; i < numsSize; ++i) {
        windowSum += nums[i] - nums[i - k];
        maxSum = (maxSum > windowSum) ? maxSum : windowSum;
    }
    
    return maxSum;
}
### è§£é¢æè·¯
1. **BFSï¼å¹¿åº¦ä¼åæç´¢ï¼**ï¼ç±äºæä»¬éè¦æ¾å°æç­è·¯å¾ï¼BFSæ¯ä¸ä¸ªèªç¶çéæ©ï¼å ä¸ºå®æå±çº§éåèç¹ï¼å¯ä»¥æ¾å°ä»èµ·ç¹å°ç»ç¹çæç­è·¯å¾ã
2. **ç¶æè¡¨ç¤º**ï¼ä½¿ç¨ä¸ä¸ªäºç»´æ°ç»æ¥è¡¨ç¤ºç½æ ¼ï¼å¶ä¸­`grid[i][j]`è¡¨ç¤ºä»èµ·ç¹å°å½åä½ç½®çæå°æ­¥æ°ã
3. **éç¢ç©å¤ç**ï¼å¦æéå°éç¢ç©ï¼`-1`ï¼ï¼åä¸è½éè¿è¯¥ä½ç½®ï¼éè¦ç»éèè¡ã

### Cè¯­è¨å®ç°
```c
#include <stdio.h>
#define MAXN 301

int shortestPathInHiddenGrid(int** grid, int gridSize, int *gridColSize) {
    // åå§åæ¹åæ°ç»ï¼è¡¨ç¤ºåå³ååä¸çç§»å¨
    int dir[2][2] = {{1, 0}, {0, 1}};
    int visited[MAXN][MAXN]; // è®¿é®æ°ç»ï¼é¿åéå¤è®¿é®
    int queue[MAXN * MAXN][2]; // éåå­å¨ä½ç½®åæ­¥æ°
    int head = 0, tail = 0; // éåçå¤´åå°¾

    // å°èµ·ç¹å å¥éåï¼å¹¶æ è®°ä¸ºå·²è®¿é®
    queue[tail][0] = 0;
    queue[tail][1] = 0;
    tail++;
    visited[0][0] = 1;

    while (head < tail) {
        int x = queue[head][0];
        int y = queue[head][1];
        head++;

        // æ£æ¥æ¯å¦å°è¾¾ç»ç¹
        if (x == gridSize - 1 && y == gridColSize - 1) {
            return visited[x][y];
        }

        // éååä¸ªæ¹å
        for (int k = 0; k < 2; k++) {
            int newX = x + dir[k][0];
            int newY = y + dir[k][1];

            // æ£æ¥æ°ä½ç½®æ¯å¦ææ
            if (newX >= 0 && newY >= 0 && newX < gridSize && newY < *gridColSize && !visited[newX][newY] && grid[newX][newY] != -1) {
                queue[tail][0] = newX;
                queue[tail][1] = newY;
                tail++;
                visited[newX][newY] = visited[x][y] + 1;
            }
        }
    }

    return -1; // å¦ææ²¡ææ¾å°è·¯å¾ï¼åè¿å-1
}
int maximumBeauty(int* flowers, int flowersSize, int k) {
    int maxBeauty = 0;
    int sum = 0;
    for (int i = 0; i < k; i++) {
        sum += flowers[i];
    }
    maxBeauty = sum;
    
    for (int i = k; i < flowersSize; i++) {
        sum += flowers[i] - flowers[i - k];
        maxBeauty = (maxBeauty > sum) ? maxBeauty : sum;
    }
    
    return maxBeauty;
}
æ¨æå°çé®é¢æ¯LeetCodeä¸ç1804é¢ï¼å®ç° Trie ï¼åç¼æ ï¼ IIãè¿ä¸ªé®é¢è¦æ±å®ç°ä¸ä¸ªTrieæ ï¼ä¹ç§°ä¸ºåç¼æ ï¼å®æ¯ä¸ç§ç¨äºæ£ç´¢å­ç¬¦ä¸²æ°æ®éä¸­çé®çç¹æ®ç±»åçæç´¢æ ãTrieæ çæ¯ä¸ªèç¹åå«è¥å¹²å­èç¹ï¼éå¸¸æ¯26ä¸ªï¼å¯¹åºä»aå°zçå­æ¯ãTrieæ å¸¸ç¨äºæ¼åæ£æ¥ãæç´¢å¼æçèªå¨è¡¥å¨ãIPè·¯ç±ç­åºæ¯ã

// å®ä¹ç½æ ¼åç¸å³åé
int grid[M][N]; // åè®¾MxNæ¯ç½æ ¼çå¤§å°
int visited[M][N]; // æ è®°è®¿é®ç¶æ
int start, end; // èµ·ç¹åç»ç¹

// æ§è¡BFSæç´¢
void bfs(int start_x, int start_y) {
    queue<int> q;
    int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // åä¸ªæ¹å
    q.push(start_x * N + start_y);
    visited[start_x][start_y] = 1;

    while (!q.empty()) {
        int current = q.front();
        q.pop();
        int x = current / N;
        int y = current % N;

        if (x == end_x && y == end_y) {
            // æ¾å°ç»ç¹ï¼è¿åè·¯å¾æ¶è
            return;
        }

        for (int i = 0; i < 4; ++i) {
            int new_x = x + directions[i][0];
            int new_y = y + directions[i][1];
            if (new_x >= 0 && new_x < M && new_y >= 0 && new_y < N && !visited[new_x][new_y]) {
                q.push(new_x * N + new_y);
                visited[new_x][new_y] = 1;
            }
        }
    }
}
int maxIceCream(int costs[], int costsSize, int coins) {
    int count[100001] = {0}; // è®¡æ°æ°ç»ï¼ç¨äºè®¡æ°æåº
    for (int i = 0; i < costsSize; i++) {
        count[costs[i]]++; // ç»è®¡æ¯ä¸ªä»·æ ¼çéªç³æ°é
    }
    
    int total = 0; // è®¡ç®è½ä¹°å°çéªç³æ»æ°
    for (int price = 1; price <= 100000 && coins > 0; price++) {
        while (count[price] > 0 && coins >= price) {
            total++; // è´­ä¹°éªç³
            coins -= price; // åå»ç¸åºçé±
            count[price]--; // åå°è¯¥ä»·æ ¼çéªç³æ°é
        }
    }
    return total;
}
int isBeautifulSubstring(const char* word, int length) {
    int max_length = 0;
    int vowels_count[5] = {0}; // è®°å½æ¯ä¸ªåé³çä¸ªæ°
    int required_vowels = 5; // éè¦çåé³å­æ¯ç§ç±»æ°

    // å®ä¹å·¦å³æé
    int left = 0, right = 0;

    while (right < length) {
        char current = word[right];

        // å¢å å½åå­ç¬¦å¯¹åºçåé³è®¡æ°
        vowels_count[current - 'a']++;

        // å¦æå½åå­ç¬¦æ¯åé³ï¼æ£æ¥æ¯å¦æ»¡è¶³æ¡ä»¶
        if (current == 'a' || vowels_count[current - 'a'] > 1) {
            while (left <= right && required_vowels > 0) {
                if (word[left] == 'a') {
                    required_vowels--;
                }
                vowels_count[word[left++] - 'a']--;
            }
        }

        // æ´æ°æå¤§é¿åº¦
        max_length = max_length > right - left ? max_length : right - left;
        right++;
    }

    return max_length;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// å®ä¹ä¸ä¸ªç»æä½æ¥å­å¨åè¯åå®çç´¢å¼
typedef struct {
    char word[201]; // å­å¨åè¯
    int index;      // å­å¨ç´¢å¼
} WordIndex;

// æ¯è¾å½æ°ï¼ç¨äº qsort
int compare(const void *a, const void *b) {
    WordIndex *word1 = (WordIndex *)a;
    WordIndex *word2 = (WordIndex *)b;
    return word1->index - word2->index;
}

char *sortSentence(char *s) {
    int len = strlen(s);
    int wordCount = 0;
    WordIndex words[9]; // ç±äºé¢ç®éå¶åè¯æ°éä¸è¶è¿9ä¸ª

    // è®¡ç®åè¯æ°éå¹¶æååè¯åç´¢å¼
    for (int i = 0; i < len; i++) {
        if (s[i] == ' ') {
            s[i] = '\0'; // æ¿æ¢ç©ºæ ¼ä¸ºå­ç¬¦ä¸²ç»æç¬¦
            words[wordCount].index = atoi(words[wordCount].word + strlen(words[wordCount].word) - 1) - 1; // æåç´¢å¼
            wordCount++;
        }
        else if (s[i] != '\0') {
            words[wordCount].word[strlen(words[wordCount].word)] = s[i]; // æ¼æ¥åè¯
        }
    }

    // æåºåè¯
    qsort(words, wordCount, sizeof(WordIndex), compare);

    // æé å¹¶è¿åç»æå¥å­
    for (int i = 0; i < wordCount; i++) {
        if (i > 0) {
            strcat(s, " "); // æ·»å ç©ºæ ¼
        }
        strcat(s, words[i].word); // æ¼æ¥åè¯
    }
    return s;
}

int main() {
    char s[] = "is2 sentence4 This1 a3";
    char *sorted = sortSentence(s);
    printf("Sorted Sentence: %s\n", sorted);
    return 0;
}
#include <stdio.h>

// å®ä¹ä¸ä¸ªç»æä½æ¥ä¿å­ç»æ
typedef struct {
    int crashTime;    // ç¨åºå´©æºçæ¶é´
    int memory1Crash; // åå­æ¡1å´©æºæ¶çå©ä½åå­
    int memory2Crash; // åå­æ¡2å´©æºæ¶çå©ä½åå­
} Result;

Result incrementallyLeakMemory(int memory1, int memory2) {
    Result result = {0, memory1, memory2}; // åå§åç»æç»æä½
    int second = 1; // ä»ç¬¬1ç§å¼å§

    // å½ä¸¤ä¸ªåå­æ¡é½è¿æåå­æ¶ï¼ç»§ç»­åéåå­
    while (memory1 >= 0 && memory2 >= 0) {
        int allocateMemory = second; // å½åç§æ°å³ä¸ºè¦åéçåå­ä½æ°
        if (memory1 >= memory2) {
            memory1 -= allocateMemory; // åå­æ¡1åéåå­
        } else {
            memory2 -= allocateMemory; // åå­æ¡2åéåå­
        }
        second++; // ç§æ°å¢å 
    }

    // æ ¹æ®åå­åéæåµæ´æ°å´©æºæ¶çåå­æ°
    result.crashTime = second - 1;
    if (memory1 < 0) {
        result.memory1Crash = 0;
    } else {
        result.memory2Crash = 0;
    }

    return result;
}

int main() {
    int memory1 = 2, memory2 = 2;
    Result result = incrementallyLeakMemory(memory1, memory2);
    printf("Crash Time: %d, Memory1: %d, Memory2: %d\n", result.crashTime, result.memory1Crash, result.memory2Crash);
    return 0;
}
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// å½æ°ç¨äºå¤æ­å­ç¬¦ä¸²ä»ç´¢å¼iå¼å§çé¨åæ¯å¦ä¸ºéåçè¿ç»­å¼
int isDecreasingSubsequence(char *s, int i) {
    int num = 0;
    for (int j = i; j < strlen(s); j++) {
        num = num * 10 + (s[j] - '0');
    }
    // æ£æ¥æåçç¬¬ä¸ä¸ªæ°æ¯å¦ä¸ºéåçèµ·å§ç¹
    if (i == 0 || num > s[i - 1] - 1) {
        return 1;
    }
    return 0;
}

// å½æ°ç¨äºå¤æ­å­ç¬¦ä¸²sæ¯å¦è½å¤æè¦æ±æå
int canSplit(char *s, int index) {
    if (index == strlen(s)) return 1;  // å°è¾¾å­ç¬¦ä¸²æ«å°¾ï¼è¿åtrue
    if (s[index] == '0') return 0;  // éå°0ï¼æ æ³å½¢æéååºåï¼è¿åfalse

    // å°è¯ä»å½åç´¢å¼å¼å§æå
    for (int len = 1; len <= strlen(s) - index; len++) {
        int num = 0;
        // æå»ºå½åå­å­ç¬¦ä¸²çæ°å¼
        for (int j = 0; j < len; j++) {
            num = num * 10 + (s[index + j] - '0');
        }

        // å¦æå½åå­å­ç¬¦ä¸²çæ°å¼ä¸åä¸ä¸ªæ°å¼ç¸å·®1ï¼ç»§ç»­éå½æ£æ¥
        if (isDecreasingSubsequence(s, index) && canSplit(s, index + len)) {
            return 1;
        }
    }
    return 0;
}

int splitString(char *s) {
    return canSplit(s, 0);
}

int main() {
    char s1[] = "1234";
    char s2[] = "050043";
    char s3[] = "9080701";
    char s4[] = "10009998";

    printf("%s -> %d\n", s1, splitString(s1));
    printf("%s -> %d\n", s2, splitString(s2));
    printf("%s -> %d\n", s3, splitString(s3));
    printf("%s -> %d\n", s4, splitString(s4));

    return 0;
}
#include <stdio.h>

// å®ä¹åºé´ç»æä½
typedef struct {
    int left, right;
} Interval;

// æ¯è¾å½æ°ï¼ç¨äºå¯¹åºé´çç»æç¹è¿è¡æåº
int compare(const void *a, const void *b) {
    Interval *ia = (Interval *)a;
    Interval *ib = (Interval *)b;
    return ia->right - ib->right; // æç»æç¹æåº
}

int* minInterval(int** intervals, int intervalsSize, int* queries, int queriesSize, int* returnSize) {
    // åå§åè¿åæ°ç»
    int *result = (int *)malloc(sizeof(int) * queriesSize);
    *returnSize = queriesSize;

    // å­å¨åºé´çç»æç¹
    int ends[intervalsSize];
    for (int i = 0; i < intervalsSize; ++i) {
        ends[i] = intervals[i][1];
    }
    
    // å¯¹åºé´çç»æç¹è¿è¡æåº
    qsort(ends, intervalsSize, sizeof(int), compare);

    // ç¨äºå­å¨å½åæ¥è¯¢çæå°åºé´é¿åº¦
    int minLen = -1;
    int minLeft = 0;

    // éåæææ¥è¯¢
    for (int i = 0; i < queriesSize; ++i) {
        int query = queries[i];
        // ä»å½åæå°åºé´å¼å§äºåæ¥æ¾åå«queryçæå°åºé´
        int left = 0, right = intervalsSize - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (intervals[mid][0] <= query && query <= intervals[mid][1]) {
                // æ£æ¥æ¯å¦æ¯æå°çåºé´
                if (mid > 0 && intervals[mid - 1][1] >= query) {
                    left = mid + 1;
                } else {
                    // æ¾å°æå°åºé´ï¼æ´æ°ç»æ
                    result[i] = intervals[mid][1] - intervals[mid][0] + 1;
                    break;
                }
            } else if (query < intervals[mid][0]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        // å¦ææ²¡ææ¾å°åºé´ï¼ç»æä¸º-1
        if (result[i] == 0) {
            result[i] = -1;
        }
    }

    return result;
}
int getMinSwaps(char* num, int k) {
    int len = strlen(num);
    int count = 0;
    int swaps[len];
    memset(swaps, 0, sizeof(swaps));

    // å°numè½¬æ¢ä¸ºæ´æ°æ°ç»å¹¶è¿è¡æåº
    int nums[len];
    for (int i = 0; i < len; ++i) {
        nums[i] = num[i] - '0';
    }
    for (int i = 0; i < len - 1; ++i) {
        for (int j = i + 1; j < len; ++j) {
            if (nums[i] > nums[j]) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }
    }

    // æ¾å°ç¬¬kä¸ªæå°å¦æ°
    for (int i = 0; i < k; ++i) {
        int smallest = len - 1;
        while (nums[smallest] <= nums[smallest - 1]) {
            --smallest;
        }
        if (smallest != len - 1) {
            int temp = nums[smallest];
            nums[smallest] = nums[len - 1];
            nums[len - 1] = temp;
            ++count;
            swaps[len - 1] = 1;
        }
        // å°æ°ç»çæåä¸ä¸ªåç´ ç§»å°åé¢ç»§ç»­å¯»æ¾
        for (int j = len - 1; j > smallest; --j) {
            nums[j] = nums[j - 1];
            swaps[j] = swaps[j - 1] + 1;
        }
        nums[smallest] = INT_MAX; // æ è®°ä¸ºå·²ä½¿ç¨
    }

    return swaps[len - 1];
}
// Definition for singly-linked list.
struct ListNode {
    int val;
    struct ListNode *next;
};

struct ListNode* deleteDuplicatesUnsorted(struct ListNode* head) {
    if (head == NULL) return NULL;
    
    // åå»ºä¸ä¸ªåå¸è¡¨ç¨äºè®°å½éå¤åç´ 
    // åè®¾æä»¬æä¸ä¸ªåå¸è¡¨å®ç°ï¼è¿éç¨ä¸ä¸ªç®åçæ°ç»æ¨¡æ
    int existed[101] = {0}; // åè®¾é¾è¡¨ä¸­åç´ çå¼åä¸º0å°100
    struct ListNode *dummy = (struct ListNode *)malloc(sizeof(struct ListNode)); // åå»ºåèç¹
    struct ListNode *prev = dummy, *curr = head;
    
    while (curr != NULL) {
        if (!existed[curr->val]) {
            existed[curr->val] = 1; // æ è®°åç´ å·²å­å¨
            prev->next = curr; // å°å½åèç¹æ·»å å°ç»æé¾è¡¨
            prev = prev->next;
        } else {
            // å¦æåç´ å·²å­å¨ï¼æ´æ°å½åèç¹çæé
            curr = curr->next;
        }
    }
    prev->next = NULL; // ç»æ­¢é¾è¡¨
    
    return dummy->next; // è¿åç»æé¾è¡¨çå¤´èç¹
}
// æ£æµç¯çå­å¨
int hasCycle(int *colors, int **edges, int n, int m) {
    int *visited = (int *)malloc(n * sizeof(int)); // 0: unvisited, 1: visiting, 2: visited
    for (int i = 0; i < n; ++i) {
        if (!visited[i]) {
            if (dfs(i, visited, colors, edges, n, m)) {
                free(visited);
                return 1;
            }
        }
    }
    free(visited);
    return 0;
}

int dfs(int node, int *visited, char *colors, int **edges, int n, int m) {
    visited[node] = 1; // æ è®°ä¸ºvisiting
    for (int i = 0; i < m; ++i) {
        if (edges[i][0] == node) {
            int nextNode = edges[i][1];
            if (!visited[nextNode]) {
                if (dfs(nextNode, visited, colors, edges, n, m)) return 1;
            } else if (visited[nextNode] == 1) {
                return 1; // æ£æµå°ç¯
            }
        }
    }
    visited[node] = 2; // æ è®°ä¸ºvisited
    return 0;
}

// æææåº
void topologicalSort(int **edges, int n, int m, int *sorted) {
    int *inDegree = (int *)calloc(n, sizeof(int));
    for (int i = 0; i < m; ++i) {
        inDegree[edges[i][1]]++;
    }

    int index = 0;
    for (int i = 0; i < n; ++i) {
        if (inDegree[i] == 0) sorted[index++] = i;
    }

    while (index < n) {
        int node = sorted[index - 1];
        for (int i = 0; i < m; ++i) {
            if (edges[i][0] == node) {
                int nextNode = edges[i][1];
                inDegree[nextNode]--;
                if (inDegree[nextNode] == 0) {
                    sorted[index++] = nextNode;
                }
            }
        }
    }
    free(inDegree);
}

// å¨æè§åæ±è§£æå¤§é¢è²å¼
int largestColorValue(int *colors, int **edges, int n, int m) {
    if (hasCycle(colors, edges, n, m)) return -1;

    int *dp = (int *)calloc(n, sizeof(int));
    int *sorted = (int *)malloc(n * sizeof(int));
    topologicalSort(edges, n, m, sorted);

    for (int i = 0; i < n; ++i) {
        int node = sorted[i];
        dp[node] = 1; // è³å°åå«èªèº«
        for (int j = 0; j < m; ++j) {
            if (edges[j][0] == node) {
                int nextNode = edges[j][1];
                if (colors[node] == colors[nextNode]) {
                    dp[nextNode] = max(dp[nextNode], dp[node] + 1);
                }
            }
        }
    }

    int maxColorValue = 0;
    for (int i = 0; i < n; ++i) {
        maxColorValue = max(maxColorValue, dp[i]);
    }

    free(dp);
    free(sorted);
    return maxColorValue;
}

// è¾å©å½æ°ï¼æ±æå¤§å¼
int max(int a, int b) {
    return a > b ? a : b;
}

#include <stdio.h>
#include <string.h>
#include <stdbool.h>

int countGoodSubstrings(char *s) {
    int count = 0;
    int len = strlen(s);
    bool unique[256] = {false}; // åè®¾å­ç¬¦éå¤§å°ä¸º256

    for (int i = 0; i < len - 2; ++i) {
        // éç½®uniqueæ°ç»
        memset(unique, false, sizeof(unique));
        // æ£æ¥ä»ç´¢å¼iå¼å§çä¸ä¸ªå­ç¬¦æ¯å¦å¯ä¸
        for (int j = i; j < i + 3; ++j) {
            if (unique[s[j]]) {
                break; // å¦æå­ç¬¦éå¤ï¼åéç½®è®¡æ°å¨å¹¶è·³åºå¾ªç¯
                count = 0;
            }
            unique[s[j]] = true;
        }
        // å¦ææ²¡æéå¤å­ç¬¦ï¼åå¢å è®¡æ°å¨
        if (i + 2 < len && !unique[s[i + 2]]) {
            count++;
        }
    }
    return count;
}

int main() {
    char s[] = "aababcabc";
    printf("Good substrings count: %d\n", countGoodSubstrings(s));
    return 0;
}
int minSwaps(char* s) {
    int n = strlen(s);
    int zeroFirst = 0, oneFirst = 0;
    for (int i = 0; i < n; i += 2) {
        if (s[i] == '0') zeroFirst++;
    }
    for (int i = 1; i < n; i += 2) {
        if (s[i] == '1') oneFirst++;
    }
    int swaps = 0;
    char expected = '0';
    for (int i = 0; i < n; i++) {
        if (s[i] != expected) {
            swaps++;
        }
        expected = (expected == '0') ? '1' : '0';
    }
    return swaps > (n / 2) ? (n / 2) - (zeroFirst < oneFirst ? zeroFirst : oneFirst) : swaps;
}
int rearrangeSticks(int n, int k) {
    if (k > n) return 0;
    int MOD = 1e9 + 7;
    int dp[n + 1][k + 1];
    memset(dp, 0, sizeof(dp));
    dp[1][1] = 1;

    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= k; j++) {
            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD;
            if (j > 0) {
                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * (i - j)) % MOD;
            }
        }
    }

    return dp[n][k];
}
bool checkZeroOnes(char *s) {
    int maxOnes = 0, maxZeros = 0, curOnes = 0, curZeros = 0;
    char lastChar = s[0]; // åå§å­ç¬¦

    for (int i = 0; s[i] != '\0'; i++) {
        if (s[i] == '1' && lastChar == '1') {
            curOnes++;
        } else if (s[i] == '1') {
            curOnes = 1;
            curZeros = 0; // éç½®0çè®¡æ°
        } else if (s[i] == '0' && lastChar == '0') {
            curZeros++;
        } else if (s[i] == '0') {
            curZeros = 1;
            curOnes = 0; // éç½®1çè®¡æ°
        }
        
        maxOnes = maxOnes < curOnes ? curOnes : maxOnes; // æ´æ°æé¿1çè®¡æ°
        maxZeros = maxZeros < curZeros ? curZeros : maxZeros; // æ´æ°æé¿0çè®¡æ°
        
        lastChar = s[i]; // æ´æ°lastCharä¸ºå½åå­ç¬¦
    }
    
    return maxOnes > maxZeros; // å¦ææé¿ç1çåºåæ¯0çåºåé¿ï¼åè¿åtrue
}
#include <stdio.h>

int minSpeedToArriveOnTime(int dist[], int n, double hour) {
    // ä½¿ç¨äºåæ¥æ¾æ¥ç¡®å®æå°æ¶é
    double left = 1.0, right = 1e7; // åççéåº¦èå´
    while (left < right) {
        double mid = left + (right - left) / 2.0;
        // è®¡ç®å½åéåº¦ä¸æéçæ»æ¶é´
        double totalTime = 0.0;
        for (int i = 0; i < n; ++i) {
            totalTime += (double)dist[i] / mid; // æ¯è¶åè½¦æéæ¶é´
            if (i < n - 1) { // å¦æä¸æ¯æåä¸è¶åè½¦ï¼éè¦ç­å¾å°æ´ç¹
                totalTime += ((double)totalTime - (int)totalTime) > 0 ? 1.0 - ((double)totalTime - (int)totalTime) : 0.0;
            }
        }
        // å¦æå½åéåº¦ä¸æéçæ¶é´å°äºç­äºç»å®æ¶é´ï¼åå°è¯åå°éåº¦
        if (totalTime <= hour) {
            right = mid;
        } else {
            left = mid + 1.0;
        }
    }
    // æ£æ¥æ¯å¦æ¾å°å¯è¡çæ¶éï¼å¦ææ²¡æï¼åè¿å-1
    return (int)left;
}

int main() {
    int dist[] = {1, 3, 2};
    double hour = 3.0;
    printf("Minimum Speed: %d\n", minSpeedToArriveOnTime(dist, sizeof(dist) / sizeof(dist[0]), hour));
    return 0;
}
bool canReach(char *s, int minJump, int maxJump) {
    int n = strlen(s);
    bool visited[n];  // è®°å½å·²ç»è®¿é®è¿çç´¢å¼
    memset(visited, 0, sizeof(visited));
    visited[0] = true;  // åå§ä½ç½®å·²ç»è®¿é®

    // éåç¨äºå­å¨å¯ä»¥è·³è·çä½ç½®
    int queue[n];
    int front = 0, rear = 0;
    queue[rear++] = 0;  // å¥éåå§ä½ç½®

    while (front < rear) {
        int current = queue[front++];  // ååºéååç«¯çåç´ 
        for (int jump = minJump; jump <= maxJump && current + jump < n; ++jump) {
            int next = current + jump;
            if (s[next] == '0' && !visited[next]) {
                visited[next] = true;
                queue[rear++] = next;  // å°ä¸ä¸ä¸ªå¯ä»¥è·³çä½ç½®å¥é
            }
        }
        // å¦æå·²ç»è®¿é®äºæåä¸ä¸ªä½ç½®ï¼ç´æ¥è¿åtrue
        if (visited[n - 1]) return true;
    }

    return false;  // å¦æéåä¸ºç©ºï¼è¯´ææ æ³å°è¾¾æåä¸ä¸ªä½ç½®
}
int* distinctNumbers(int* nums, int numsSize, int k, int* returnSize) {
    int* result = malloc(sizeof(int) * numsSize); // ä¸ºç»ææ°ç»åéåå­
    if (!result) return NULL; // å¦æåå­åéå¤±è´¥ï¼åè¿åNULL

    // åå§åçªå£çå·¦å³è¾¹ç
    int left = 0, right = 0;
    // åå§ååå¸è¡¨ï¼è¿éä½¿ç¨ç®åçæ°ç»æ¨¡æåå¸è¡¨
    int hashTable[101] = {0}; // åè®¾æ°å­èå´å¨0å°100ä»¥å
    int count = 0; // è®°å½çªå£ä¸­ä¸åæ°å­çæ°é

    while (right < numsSize) {
        // å°æ°è¿å¥çªå£çæ°å­å å¥åå¸è¡¨ï¼å¹¶æ´æ°ç§ç±»æ°
        hashTable[nums[right]]++;
        if (hashTable[nums[right]] == 1) count++; // å¦ææ¯æ°æ°å­ï¼ç§ç±»æ°å ä¸

        // å½çªå£å¤§å°è¾¾å°kæ¶ï¼å¼å§å¤çç»æ
        if (right - left + 1 == k) {
            result[left] = count; // å°å½åçªå£çç§ç±»æ°å å¥ç»ææ°ç»
            // ç§»å¨çªå£ï¼å é¤å·¦è¾¹ççæ°å­
            hashTable[nums[left]]--;
            if (hashTable[nums[left]] == 0) count--; // å¦ææ°å­ç§ç±»æ°åè³0ï¼ç§ç±»æ°åä¸
            left++; // ç§»å¨å·¦è¾¹ç
        }
        right++; // ç§»å¨å³è¾¹ç
    }

    *returnSize = numsSize - k + 1; // è®¾ç½®è¿åæ°ç»çå¤§å°
    return result; // è¿åç»ææ°ç»
}
char* convertDate(char* date) {
    char month[5], day[5], year[5];
    sscanf(date, "%[^-]-%[^-]-%s", year, month, day); // ä½¿ç¨ sscanf å½æ°åå²æ¥æ
    sprintf(date, "%s-%s-%s", month, day, year); // éæ°ç»åå­ç¬¦ä¸²
    return date;
}
int findStudentToReplaceChalk(int chalk[], int k, int n) {
    int total = 0;
    for (int i = 0; i < n; i++) {
        total += chalk[i];
    }
    int i = 0;
    while (k >= 0 && i < n) {
        if (k < chalk[i]) {
            return i;
        }
        k -= chalk[i];
        i = (i + 1) % n; // å¾ªç¯å°æ°ç»çå¼å§
    }
    return -1; // å¦ææ²¡æå­¦çéè¦è¡¥åç²ç¬ï¼è¿å-1
}
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// å½æ°ç¨äºå°å­ç¬¦ä¸²è½¬æ¢ä¸ºæ°å¼
int wordToValue(char *word) {
    int value = 0;
    for (int i = 0; word[i] != '\0'; i++) {
        value = value * 10 + (word[i] - 'a');
    }
    return value;
}

// å¤æ­ä¸¤ä¸ªåè¯çæ°å¼ä¹åæ¯å¦ç­äºç®æ åè¯çæ°å¼
bool isSumEqual(char *firstWord, char *secondWord, char *targetWord) {
    int sum = wordToValue(firstWord) + wordToValue(secondWord);
    return sum == wordToValue(targetWord);
}

int main() {
    // ç¤ºä¾æµè¯
    char *firstWord = "acb";
    char *secondWord = "cba";
    char *targetWord = "cdb";
    
    if (isSumEqual(firstWord, secondWord, targetWord)) {
        printf("true\n");
    } else {
        printf("false\n");
    }
    return 0;
}
char* maxValueAfterInsertion(char* n, int x) {
    int len = strlen(n);
    char maxEnd[11]; // æå¤§é¿åº¦ä¸º10 + 1ï¼ç»æç¬¦ï¼
    int maxEndLen = 0;
    int isNegative = (n[0] == '-');
    
    // å¦ææ¯è´æ°ï¼åè·³è¿è´å·
    int start = isNegative ? 1 : 0;

    for (int i = start; i <= len; ++i) {
        char temp[11];
        int tempLen = 0;
        
        // æé ä¸åå«å½åä½ç½®çå­ç¬¦ä¸²
        for (int j = 0; j < i; ++j) {
            temp[tempLen++] = n[j];
        }
        
        // æå¥æ°å­x
        temp[tempLen++] = 'x';
        
        // æé å©ä½çå­ç¬¦ä¸²
        for (int j = i; j < len; ++j) {
            temp[tempLen++] = n[j];
        }
        temp[tempLen] = '\0'; // æ·»å å­ç¬¦ä¸²ç»æç¬¦
        
        // å¦æå½åæ¯è´æ°ï¼éè¦å¨ç¬¬äºä½ä¹åæå¥x
        if (isNegative) {
            memmove(&temp[2], &temp[1], tempLen - 1);
            temp[1] = 'x';
        }
        
        // æ¯è¾å¹¶æ´æ°æå¤§å­ç¬¦ä¸²
        if (maxEndLen < tempLen - 1 || strcmp(&maxEnd[isNegative], &temp[isNegative]) < 0) {
            strncpy(maxEnd, temp, sizeof(maxEnd));
            maxEndLen = tempLen - 1;
        }
    }
    
    // æ¿æ¢ 'x' ä¸ºå®éçæ°å­ x
    maxEnd[maxEndLen - (isNegative ? 2 : 1)] = '0' + x;
    
    return strdup(maxEnd); // ä½¿ç¨ strdup å¤å¶å­ç¬¦ä¸²ï¼å ä¸ºåå­ç¬¦ä¸²å¯è½ä¼è¢«ä¿®æ¹
}
int reductionOperations(int* nums, int numsSize) {
    int maxValue = 0, secondMaxValue = 0, count = 0;
    for (int i = 0; i < numsSize; ++i) {
        if (nums[i] > maxValue) {
            secondMaxValue = maxValue;
            maxValue = nums[i];
        } else if (nums[i] > secondMaxValue && nums[i] < maxValue) {
            secondMaxValue = nums[i];
        }
    }
    for (int i = 0; i < numsSize; ++i) {
        if (nums[i] == maxValue) {
            count += maxValue - secondMaxValue;
            nums[i] = secondMaxValue;
        }
    }
    return count;
}
bool canBeIncreasing(int* nums, int numsSize) {
    // é¦åæ£æ¥æ°ç»æ¯å¦å·²ç»æ¯ä¸¥æ ¼éå¢ç
    for (int i = 1; i < numsSize; ++i) {
        if (nums[i - 1] >= nums[i]) {
            break;
        }
    }
    
    // å¦ææ²¡ææ¾å°ä¸æ¯ä¸¥æ ¼éå¢çå°æ¹ï¼è¯´ææ°ç»å·²ç»æ¯ä¸¥æ ¼éå¢ç
    if (numsSize - 1 > 0 && nums[numsSize - 2] < nums[numsSize - 1]) {
        return true;
    }
    
    // å¯»æ¾ééå¢çå°æ¹
    for (int i = 0; i < numsSize - 1; ++i) {
        if (nums[i] >= nums[i + 1]) {
            // å°è¯å é¤ nums[i]
            if (i == 0 || nums[i - 1] < nums[i + 1]) {
                return true;
            }
            // å°è¯å é¤ nums[i + 1]
            if (i == numsSize - 2 || nums[i] < nums[i + 2]) {
                return true;
            }
            // å¦æä¸¤ä¸ªæ¡ä»¶é½ä¸æ»¡è¶³ï¼è¯´ææ æ³éè¿å é¤ä¸ä¸ªåç´ ä½¿æ°ç»ä¸¥æ ¼éå¢
            return false;
        }
    }
    
    // å¦ææ²¡ææ¾å°ééå¢çå°æ¹ï¼è¯´ææ°ç»å·²ç»æ¯ä¸¥æ ¼éå¢ç
    return true;
}
char* removeOccurrences(char* s, char* part) {
    int lenS = strlen(s);
    int lenPart = strlen(part);
    char *temp = (char *)malloc(sizeof(char) * (lenS + 1));
    int j = 0;

    for (int i = 0; i <= lenS; ++i) {
        // å¦ææ¾å°äºpartçå­ä¸²
        if (i + lenPart <= lenS && strncmp(s + i, part, lenPart) == 0) {
            i += lenPart - 1; // è·³è¿å·²å¹éçpartå­ç¬¦ä¸²
        } else {
            if (j < lenS) {
                temp[j++] = s[i]; // å°å½åå­ç¬¦å¤å¶å°tempï¼å¹¶è·³è¿part
            }
        }
    }

    temp[j] = '\0'; // ç¡®ä¿å­ç¬¦ä¸²ä»¥ç©ºå­ç¬¦ç»å°¾
    char *result = (char *)malloc(sizeof(char) * (j + 1));
    strcpy(result, temp);
    free(temp);
    return result;
}
int maxAlternatingSum(int* nums, int numsSize) {
    if (numsSize == 0) return 0;
    
    int even = nums[0], odd = 0;
    for (int i = 1; i < numsSize; ++i) {
        if (i % 2 == 0) {
            // å¯¹äºå¶æ°ä½ç½®ï¼å¯ä»¥éæ©ä¸åå«åä¸ä¸ªåç´ 
            even = nums[i] + max(even, odd);
        } else {
            // å¯¹äºå¥æ°ä½ç½®ï¼å¯ä»¥éæ©ä¸åå«åä¸ä¸ªåç´ 
            odd = nums[i] - max(even, odd);
        }
    }
    
    return max(even, odd);
}
// å½æ°ç¨äºå¤æ­æ¯å¦å¯ä»¥éæ°åéå­ç¬¦
// 定义结构体来存储区间的起始和结束
typedef struct {
    int start;
    int end;
} Range;

// 比较函数，用于排序
int compare(const void *a, const void *b) {
    Range *rangeA = (Range *)a;
    Range *rangeB = (Range *)b;
    return rangeA->start - rangeB->start;
}

// 函数来找出最大未覆盖区间
void findMaximalUncoveredRanges(Range *ranges, int size, int n) {
    if (size == 0) {
        printf("0 0\n");
        return;
    }

    // 首先按照区间的起始位置排序
    qsort(ranges, size, sizeof(Range), compare);

    // 初始化变量
    int maxRangeEnd = -1;
    int prevEnd = ranges[0].end;

    // 遍历区间，找出最大的未覆盖区间
    for (int i = 1; i < size; i++) {
        if (ranges[i].start > prevEnd) {
            if (maxRangeEnd < 0 || maxRangeEnd - ranges[i].start < prevEnd - ranges[i].start) {
                maxRangeEnd = ranges[i].start - 1;
            }
            prevEnd = ranges[i].end;
        }
    }

    // 检查最后一个区间之后是否还有未覆盖的区间
    if (maxRangeEnd < n && prevEnd < n) {
        maxRangeEnd = n - 1;
    }

    printf("%d %d\n", maxRangeEnd - (maxRangeEnd > 0), maxRangeEnd);
}

int main() {
    // 示例输入
    Range ranges[] = {{3, 5}, {7, 8}};
    int size = sizeof(ranges) / sizeof(ranges[0]);
    int n = 10;

    // 调用函数
    findMaximalUncoveredRanges(ranges, size, n);

    return 0;
}
int isLeapYear(int year) {
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}

// 获取月份的最大天数
int getMaxDay(int year, int month) {
    switch (month) {
        case 1: case 3: case 5: case 7: case 8: case 10: case 12:
            return 31;
        case 4: case 6: case 9: case 11:
            return 30;
        case 2:
            return isLeapYear(year) ? 29 : 28;
        default:
            return 0;
    }
}

// 计算下一天的日期
void nextDay(char *date) {
    int year, month, day;
    sscanf(date, "%d-%d-%d", &year, &month, &day); // 解析日期

    int maxDay = getMaxDay(year, month); // 获取该月的最大天数
    if (day < maxDay) { // 如果没有超出本月天数
        day++;
    } else {
        day = 1;
        if (month < 12) {
            month++;
        } else {
            month = 1;
            year++;
        }
    }

    // 格式化输出下一天的日期
    printf("%04d-%02d-%02d\n", year, month, day);
}

int main() {
    char date[] = "2014-06-30"; // 测试日期
    nextDay(date); // 计算下一天
    return 0;
}
#include <stdlib.h>

// 方向数组，表示骑士的八个可能移动方向
int moves[8][2] = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}};

// 检查当前位置是否有效
int isValid(int x, int y, int m, int n, int *visited) {
    return x >= 0 && y >= 0 && x < m && y < n && !visited[x * n + y];
}

// 骑士巡逻的递归函数
int *knightTour(int m, int n, int r, int c, int *visited, int *returnSize) {
    int *path = malloc(m * n * sizeof(int)); // 存储路径的数组
    if (!path) return NULL;
    int pathIndex = 0, i, tx, ty;

    // 从起点开始递归搜索
    visited[r * n + c] = 1;
    path[pathIndex++] = r * n + c;

    for (int count = 1; count < m * n; count++) {
        for (i = 0; i < 8; i++) {
            tx = r + moves[i][0];
            ty = c + moves[i][1];
            if (isValid(tx, ty, m, n, visited)) {
                visited[tx * n + ty] = 1;
                path[pathIndex++] = tx * n + ty;
                if (knightTour(m, n, tx, ty, visited, returnSize) != NULL) {
                    return path;
                }
                visited[tx * n + ty] = 0; // 回溯
            }
        }
        if (i == 7) { // 如果所有方向都无效，回溯
            break;
        }
    }
    free(path); // 当前起点无法完成巡逻，释放内存
    return NULL;
}

// 封装函数，初始化visited数组并调用knightTour
int *dfs(int m, int n, int r, int c, int *returnSize) {
    int *visited = (int *)calloc(m * n, sizeof(int)); // 初始化访问数组
    if (!visited) return NULL;
    int *result = knightTour(m, n, r, c, visited, returnSize);
    if (!result) *returnSize = 0;
    free(visited);
    return result;
}

// 用于输出结果的辅助函数
void printResult(int *path, int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", path[i]);
    }
    printf("\n");
}
// Definition for a Node.
typedef struct Node {
    int val;
    struct Node *next;
} Node;

Node* splitList(Node* head, int val) {
    Node *dummy1 = malloc(sizeof(Node)); // 创建一个哑节点，用于存放所有小于val的节点
    Node *dummy2 = malloc(sizeof(Node)); // 创建另一个哑节点，用于存放所有大于等于val的节点
    Node *tail1 = dummy1, *tail2 = dummy2;
    while (head) {
        if (head->val < val) {
            tail1->next = head;
            tail1 = tail1->next;
        } else {
            tail2->next = head;
            tail2 = tail2->next;
        }
        head = head->next;
    }
    tail1->next = dummy2->next; // 连接两个哑节点的列表
    tail2->next = NULL; // 循环链表的尾部设置为NULL
    dummy1->next = dummy2->next; // 将哑节点1的next指向哑节点2的next，形成循环链表
    return dummy1->next; // 返回新的循环链表的头节点
}
#include <stdio.h>
#include <stdlib.h>

// 定义一个结构体来模拟对象
typedef struct {
    // 使用动态数组存储键值对
    char **keys;
    int *values;
    int size;
} Object;

// 初始化对象
Object createObject(int size) {
    Object obj;
    obj.keys = (char **)malloc(size * sizeof(char *));
    obj.values = (int *)malloc(size * sizeof(int));
    obj.size = size;
    return obj;
}

// 添加属性到对象
void addObjectProperty(Object *obj, char *key, int value) {
    if (obj->size > 0) {
        obj->keys[--obj->size] = key;  // 使用引用，简化内存管理
        obj->values[obj->size] = value;
    }
}

int main() {
    // 示例输入
    char *keys[] = {"a", "b", "c"};
    int values[] = {1, 2, 3};
    int n = sizeof(keys) / sizeof(keys[0]);

    // 创建对象
    Object obj = createObject(n);

    // 填充对象属性
    for (int i = 0; i < n; ++i) {
        addObjectProperty(&obj, keys[i], values[i]);
    }

    // 输出结果
    for (int i = 0; i < obj.size; ++i) {
        printf("%s: %d\n", obj.keys[i], obj.values[i]);
    }

    // 释放内存
    for (int i = 0; i < obj.size; ++i) {
        free(obj.keys[i]);
    }
    free(obj.keys);
    free(obj.values);

    return 0;
}
void findTwoSum(int* nums, int numsSize, int target, int* indices) {
    // 使用一个哈希表存储已经遍历过的数字及其索引
    int *hashTable = (int *)malloc(sizeof(int) * 1010); // 假设索引不会超过1000
    for (int i = 0; i < numsSize; ++i) {
        int complement = target - nums[i];
        if (hashTable[complement] != -1) {
            indices[0] = hashTable[complement];
            indices[1] = i;
            return;
        }
        hashTable[nums[i]] = i;
    }
}
int maxHouses(int* street, int streetSize, int k) {
    int maxCount = 0;
    int sum = 0;
    int left = 0;
    
    for (int right = 0; right < streetSize; ++right) {
        sum += street[right];  // 将右侧房屋的人数加到窗口的总和中
        
        while (sum > k) {
            sum -= street[left];  // 如果总和超过k，则从左侧减去人数
            left++;  // 移动左侧窗口
        }
        
        maxCount = max(maxCount, right - left + 1);  // 更新最大房屋数量
    }
    
    return maxCount;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// 用于存储单词和出现次数的结构体
typedef struct {
    char *word;
    int count;
} WordCount;

// 比较两个WordCount结构体的函数，用于排序
int compare(const void *a, const void *b) {
    return strcmp(((WordCount *)a)->word, ((WordCount *)b)->word);
}

// 插入或更新单词计数
void insertOrUpdate(WordCount *wordCounts, int *size, char *word) {
    for (int i = 0; i < *size; i++) {
        if (strcmp(wordCounts[i].word, word) == 0) {
            wordCounts[i].count++;
            return;
        }
    }
    // 如果单词不在列表中，添加新单词
    wordCounts[*size].word = strdup(word); // 复制单词字符串
    wordCounts[*size].count = 1;
    (*size)++;
}

// 读取文件并统计词频
void countWordOccurrences(const char *filename, WordCount *wordCounts, int *size) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        perror("Error opening file");
        return;
    }

    char word[1024];
    while (fscanf(file, "%s", word) == 1) {
        // 预处理单词
        for (int i = 0; word[i]; i++) {
            word[i] = tolower(word[i]);
        }
        insertOrUpdate(wordCounts, size, word);
    }
    fclose(file);
}

int main() {
    const char *filename = "hello.txt"; // 替换为实际文件名
    WordCount wordCounts[1000]; // 假设最多有1000个不同的单词
    int size = 0;

    countWordOccurrences(filename, wordCounts, &size);

    // 根据单词出现次数排序
    qsort(wordCounts, size, sizeof(WordCount), compare);

    // 打印结果
    for (int i = 0; i < size; i++) {
        printf("%s: %d\n", wordCounts[i].word, wordCounts[i].count);
        free(wordCounts[i].word); // 释放分配的内存
    }

    return 0;
}
int countSubstringsWithoutRepeatingCharacters(char *s) {
    int len = strlen(s);
    int count = 0;
    int left = 0;
    int right = 0;
    int lastOccurrence[256] = {-1}; // 存储字符最后出现的位置，假设ASCII字符集

    while (right < len) {
        // 移动右指针直到遇到重复字符
        while (right < len && lastOccurrence[(unsigned char)s[right]] == -1) {
            lastOccurrence[(unsigned char)s[right]] = right;
            right++;
        }
        
        // 当右指针遇到重复字符时，移动左指针
        while (left < len && lastOccurrence[(unsigned char)s[left]] != left) {
            lastOccurrence[(unsigned char)s[left]] = -1; // 重置字符出现位置
            left++;
        }
        
        // 更新结果，从left到right-1都是不重复的子串
        count += right - left;
    }

    return count;
}
// 函数用于计算表达式的值
int calculateExpression(const char* fn, int* args, int argsSize) {
    // 解析函数表达式，这里简化处理，假设表达式格式已知且正确
    // 例如："(a, b, c) => b + a - c"，我们直接按照顺序获取参数b, a, c
    int values[3] = {0}; // 假设最多三个参数
    for (int i = 0; i < argsSize; ++i) {
        // 根据参数索引设置值，这里简化处理，假设args索引与表达式参数索引一致
        values[i] = args[i];
    }
    // 计算表达式结果
    int result = values[1] + values[0] - values[2]; // 根据示例"b + a - c"
    return result;
}

int partial(int* args, int argsSize, const char* restArgs) {
    // 忽略restArgs，因为我们只关注args数组中的值
    return calculateExpression("(a, b, c) => b + a - c", args, argsSize);
}
// 用于存储反转后对象的键值对
typedef struct {
    char *key;
    char *value;
} KeyValuePair;

// 函数用于反转对象
char* invertObject(char* obj) {
    // 分割字符串，获取键值对
    char *temp = strdup(obj); // 使用strdup来复制obj，避免修改原始字符串
    char *key;
    char *value;
    char *start = temp;
    KeyValuePair *kvs = NULL;
    int count = 0;
    
    while ((key = strsep(&start, ","))) {
        value = strchr(key, ':');
        if (value) {
            *value = '\0'; // 将冒号替换为字符串结束符
            value++; // 移动到值的开始位置
            kvs = realloc(kvs, (count + 1) * sizeof(KeyValuePair)); // 重新分配内存
            kvs[count].key = strdup(value); // 复制值
            kvs[count].value = strdup(key); // 复制键
            count++;
        }
    }
    
    // 构建反转后的对象字符串
    char *result = malloc(1024 * (count + 1)); // 假设结果不会超过这个大小
    *result = '\0'; // 初始化为空字符串
    for (int i = 0; i < count; i++) {
        char pair[256];
        sprintf(pair, "%s:%s,", kvs[i].key, kvs[i].value);
        strcat(result, pair);
    }
    if (strlen(result) > 0) {
        result[strlen(result) - 1] = '\0'; // 移除最后一个逗号
    }
    
    // 释放分配的内存
    for (int i = 0; i < count; i++) {
        free(kvs[i].key);
        free(kvs[i].value);
    }
    free(kvs);
    free(temp);
    
    return result;
}

int main() {
    char obj[] = "a:1,b:2,c:3,d:4";
    char *inverted = invertObject(obj);
    printf("Inverted Object: %s\n", inverted);
    free(inverted); // 释放反转后的对象字符串
    return 0;
}
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 计算特殊二叉树的高度
int heightOfTree(TreeNode* root) {
    if (root == NULL) {
        return 0; // 如果节点为空，高度为0
    }
    if (root->left == NULL && root->right == NULL) {
        return 1; // 如果是叶子节点，高度为1
    }
    int leftHeight = heightOfTree(root->left); // 计算左子树的高度
    int rightHeight = heightOfTree(root->right); // 计算右子树的高度
    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1; // 返回左右子树高度的最大值加1
}
int numberOfCategories(int n, int* categoryHandler) {
    // 创建一个足够大的数组作为哈希表
    int hashTable[101] = {0}; // 假设类别数不会超过100
    int uniqueCategories = 0;
    
    // 遍历数组，使用哈希表记录类别出现次数
    for (int i = 0; i < n; i++) {
        if (hashTable[categoryHandler[i]] == 0) {
            // 如果类别是第一次出现，增加不同类别的数量
            uniqueCategories++;
        }
        // 将类别出现次数加1
        hashTable[categoryHandler[i]]++;
    }
    
    // 返回不同类别的数量
    return uniqueCategories;
}
#include <stdio.h>
#include <stdbool.h>

// 函数用于检查一个数字是否是幸运数字
bool isLucky(int num) {
    while (num > 0) {
        if (num % 10 == 4 || num % 10 == 7) {
            return false;
        }
        num /= 10;
    }
    return true;
}

// 函数用于找出第K个幸运数字
int findKthLuckyNumber(int k) {
    int count = 0; // 已找到的幸运数字数量
    int num = 1;   // 当前检查的数字

    // 循环直到找到第K个幸运数字
    while (count < k) {
        if (isLucky(num)) {
            count++;
            if (count == k) {
                return num;
            }
        }
        num++;
    }

    return -1; // 如果没有找到，返回-1
}

int main() {
    int k = 10; // 假设我们要找第10个幸运数字
    printf("The %d-th lucky number is: %d\n", k, findKthLuckyNumber(k));
    return 0;
}
#include <stdio.h>
#include <string.h>
#define MAX_ROW 100
#define MAX_COL 100

int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

int minimumTimeToReachDestination(char land[MAX_ROW][MAX_COL], int rows, int cols) {
    // 检查输入参数
    if (rows <= 0 || cols <= 0) return -1;

    // 定义访问状态数组，初始化为0
    int visited[MAX_ROW][MAX_COL] = {0};
    int queue[MAX_ROW * MAX_COL][2]; // 存储节点和步数
    int front = 0, rear = 0; // 队列的前后指针

    // 寻找起点'S'，初始化队列
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (land[i][j] == 'S') {
                queue[rear][0] = i;
                queue[rear][1] = j;
                rear++;
                visited[i][j] = 1; // 标记为已访问
                break;
            }
        }
    }

    // BFS核心逻辑
    while (front < rear) {
        int x = queue[front][0], y = queue[front][1];
        front++;

        for (int i = 0; i < 4; ++i) {
            int nx = x + directions[i][0], ny = y + directions[i][1];
            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols &&
                !visited[nx][ny] && land[nx][ny] != 'D') {
                if (land[nx][ny] == 'E') {
                    return (visited[nx][ny] = 1) + 1; // 到达终点
                }
                queue[rear][0] = nx;
                queue[rear][1] = ny;
                rear++;
                visited[nx][ny] = 1; // 标记为已访问
            }
        }
    }

    return -1; // 无法到达终点
}
// 定义网格大小
#define N 3

// 检查是否越界
int is_valid(int x, int y) {
    return x >= 0 && x < N && y >= 0 && y < N;
}

// 移动石头的函数
void move_stone(int grid[N][N], int x, int y, int *count) {
    // 寻找可移动的相邻格子
    for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
            if (i == 0 && j == 0) continue; // 跳过自身位置
            int new_x = x + i, new_y = y + j;
            if (is_valid(new_x, new_y) && grid[new_x][new_y] == 0) {
                grid[new_x][new_y] = 1; // 移动石头
                (*count)++; // 增加移动次数
                move_stone(grid, new_x, new_y, count); // 递归移动
                grid[new_x][new_y] = 0; // 回溯
                (*count)--; // 减少移动次数
            }
        }
    }
}

// 计算最少移动次数的函数
int minMovesToSpreadStones(int grid[N][N]) {
    int count = 0; // 初始化移动次数
    memset(grid, 0, sizeof(grid)); // 初始化网格
    int stones = 0; // 石头总数
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (grid[i][j] > 1) {
                stones += grid[i][j] - 1;
                grid[i][j] = 1; // 每个格子只能有一个石头
            }
        }
    }
    move_stone(grid, 0, 0, &count); // 从(0,0)开始移动
    return count + stones; // 返回总移动次数
}

int main() {
    int grid[N][N] = {{1,1,0},{1,1,1},{1,2,1}};
    printf("Minimum moves: %d\n", minMovesToSpreadStones(grid));
    return 0;
}
#include <stdio.h>

int minOperations(int *nums, int numsSize) {
    int maxVal = 0;
    for (int i = 0; i < numsSize; ++i) {
        maxVal = maxVal > nums[i] ? maxVal : nums[i];
    }
    
    // 存储每个数字出现的次数
    int *count = (int *)malloc((maxVal + 1) * sizeof(int));
    for (int i = 0; i <= maxVal; ++i) {
        count[i] = 0;
    }
    for (int i = 0; i < numsSize; ++i) {
        count[nums[i]]++;
    }
    
    int operations = 0;
    for (int i = 1; i <= maxVal; ++i) {
        // 贪心地使用第二种操作，然后使用第一种操作处理剩余的元素
        operations += count[i] / 3;
        if (count[i] % 3 > 0) {
            operations++;
        }
    }
    
    free(count);
    return operations;
}

int main() {
    int nums[] = {2, 3, 3, 2, 2, 4, 2, 3, 4};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    printf("Minimum operations: %d\n", minOperations(nums, numsSize));
    return 0;
}
#include <limits.h>

int maxAlloys(int n, int k, int budget, int composition[][n], int stock[], int cost[]) {
    int maxAlloy = 0;
    // 计算制造一份合金需要的金属总量
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < k; ++j) {
            maxAlloy += composition[j][i] * cost[i];
        }
    }
    // 使用二分查找确定最大合金数
    int left = 0, right = maxAlloy, mid, result = 0;
    while (left <= right) {
        mid = left + (right - left) / 2;
        if (canMakeAlloys(k, n, budget, composition, stock, mid)) {
            result = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}

// 检查是否可以在mid的花费下制造合金
int canMakeAlloys(int k, int n, int budget, int composition[][n], int stock[], int mid) {
    int need = 0;
    for (int i = 0; i < k; ++i) {
        int machineNeed = 0;
        for (int j = 0; j < n; ++j) {
            machineNeed += (composition[i][j] - stock[j]) * cost[j];
        }
        if (machineNeed > mid) return 0; // 如果一种金属的需要量就超过了mid，则直接返回0
        need += machineNeed;
    }
    return need <= budget;
}

int main() {
    int n = 3, k = 2, budget = 15;
    int composition[2][3] = {{1,1,1},{1,1,10}};
    int stock[3] = {0,0,0};
    int cost[3] = {1,2,3};
    printf("Maximum number of alloys: %d\n", maxAlloys(n, k, budget, composition, stock, cost));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// Define the structure for the result pair
typedef struct {
    int index1;
    int index2;
} ResultPair;

ResultPair twoSum(int* nums, int numsSize, int target) {
    // Create a hash table to store the numbers and their indices
    int *hashTable = (int *)malloc(sizeof(int) * (target + 1));
    for (int i = 0; i < target + 1; ++i) {
        hashTable[i] = -1; // Initialize with -1 indicating not found
    }

    for (int i = 0; i < numsSize; ++i) {
        int complement = target - nums[i];
        if (hashTable[complement] != -1) {
            // If the complement is found, return the indices
            return (ResultPair){hashTable[complement], i};
        }
        // Store the index of the current number in the hash table
        hashTable[nums[i]] = i;
    }

    // In case no pair is found (should not happen as per problem statement)
    ResultPair errorPair = {-1, -1};
    return errorPair;
}

int main() {
    int nums[] = {2, 7, 11, 15};
    int target = 9;
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    ResultPair result = twoSum(nums, numsSize, target);
    printf("Index1: %d, Index2: %d\n", result.index1, result.index2);
    return 0;
}
#include <stdio.h>

// 函数用于返回和为目标值的最长子序列的长度
int lengthOfLongestSubsequence(int *nums, int numsSize, int target) {
    // dp数组，dp[i]表示到当前元素结束，和为i的子序列的最大长度
    int dp[target + 1] = {0};
    int maxLength = 0;

    // 遍历数组
    for (int i = 0; i < numsSize; i++) {
        // 从target往回退，找到小于等于nums[i]的最大的和
        for (int j = target; j >= nums[i]; j--) {
            // 如果dp[j - nums[i]]存在，则更新dp[j]的值
            if (dp[j - nums[i]] != -1) {
                dp[j] = (dp[j] == -1 || dp[j - nums[i]] + 1 > dp[j]) ? dp[j - nums[i]] + 1 : dp[j];
                maxLength = (maxLength > dp[j]) ? maxLength : dp[j];
            }
        }
        // 将dp[target - nums[i]]置为-1，避免使用当前元素多次
        dp[target - nums[i]] = -1;
    }
    return maxLength;
}

int main() {
    int nums[] = {1, 2, 3, 4, 5};
    int target = 9;
    int size = sizeof(nums) / sizeof(nums[0]);
    printf("The length of the longest subsequence is: %d\n", lengthOfLongestSubsequence(nums, size, target));
    return 0;
}
#include <stdio.h>

// 函数用于返回和为目标值的最长子序列的长度
int lengthOfLongestSubsequence(int *nums, int numsSize, int target) {
    // dp数组，dp[i]表示到当前元素结束，和为i的子序列的最大长度
    //int dp[target + 1] = {0};
    int* dp = (int*)malloc((target + 1) * sizeof(int));
    int maxLength = 0;

    // 遍历数组
    for (int i = 0; i < numsSize; i++) {
        // 从target往回退，找到小于等于nums[i]的最大的和
        for (int j = target; j >= nums[i]; j--) {
            // 如果dp[j - nums[i]]存在，则更新dp[j]的值
            if (dp[j - nums[i]] != -1) {
                dp[j] = (dp[j] == -1 || dp[j - nums[i]] + 1 > dp[j]) ? dp[j - nums[i]] + 1 : dp[j];
                maxLength = (maxLength > dp[j]) ? maxLength : dp[j];
            }
        }
        // 将dp[target - nums[i]]置为-1，避免使用当前元素多次
        dp[target - nums[i]] = -1;
    }
    return maxLength;
}

int main() {
    int nums[] = {1, 2, 3, 4, 5};
    int target = 9;
    int size = sizeof(nums) / sizeof(nums[0]);
    printf("The length of the longest subsequence is: %d\n", lengthOfLongestSubsequence(nums, size, target));
    return 0;
}
int maxSpending(int** values, int valuesSize, int* valuesColSize) {
    int m = valuesSize;
    int n = *valuesColSize;
    int dailyCost[m * n]; // 存储每天的开销
    int totalCost = 0; // 总开销
    int itemIndex = 0; // 物品索引

    for (int d = 1; d <= m * n; d++) {
        int maxVal = 0, maxI = -1, maxJ = -1;
        for (int i = 0; i < m; i++) {
            for (int j = n - 1; j >= 0; j--) {
                if (values[i][j] > maxVal && (itemIndex < n || values[i][j] != dailyCost[itemIndex])) {
                    maxVal = values[i][j];
                    maxI = i;
                    maxJ = j;
                }
            }
        }
        dailyCost[itemIndex++] = maxVal * d;
        totalCost += dailyCost[itemIndex - 1];
        // 标记为已购买，通过设置为负数来简化逻辑
        values[maxI][maxJ] = -1;
    }

    return totalCost;
}
#include <stdio.h>
#include <vector>
#include <utility> // for std::pair

using namespace std;

// 辅助函数，判断一个数是否是质数
bool isPrime(int num) {
    if (num <= 1) return false;
    for (int i = 2; i * i <= num; i++) {
        if (num % i == 0) return false;
    }
    return true;
}

// DFS 函数，找出合法路径并计数
void dfs(vector<vector<int>>& tree, int node, int n, vector<bool>& primes, int& count, int primeNode) {
    if (isPrime(node)) {
        primeNode = node;
    }
    count += primes[node];
    for (int nextNode : tree[node]) {
        if (nextNode == primeNode) {
            dfs(tree, nextNode, n, primes, count, primeNode);
        } else {
            dfs(tree, nextNode, n, primes, count, primeNode);
        }
    }
}

// 主函数，构建树并求解
int countValidPaths(int n, vector<vector<int>>& edges) {
    vector<vector<int>> tree(n + 1); // 树的邻接表表示
    vector<bool> primes(n + 1, false); // 标记质数
    int count = 0;

    // 构建树
    for (auto& edge : edges) {
        tree[edge[0]].push_back(edge[1]);
        tree[edge[1]].push_back(edge[0]);
    }

    // 找出所有的质数节点
    for (int i = 2; i <= n; i++) {
        primes[i] = isPrime(i);
    }

    // 从每个节点开始 DFS，找出合法路径
    for (int i = 1; i <= n; i++) {
        int primeNode = 0;
        dfs(tree, i, n, primes, count, primeNode);
    }

    return count;
}

int main() {
    int n = 5;
    vector<vector<int>> edges = {{1, 2}, {1, 3}, {2, 4}, {2, 5}};
    printf("The number of valid paths is: %d\n", countValidPaths(n, edges));
    return 0;
}
#include <stdlib.h>

// 定义图的结构
typedef struct {
    int **edges;
    int n; // 节点的数量
} Graph;

// 创建图
Graph *createGraph(int n) {
    Graph *graph = (Graph *)malloc(sizeof(Graph));
    graph->n = n;
    graph->edges = (int **)malloc(sizeof(int *) * n);
    for (int i = 0; i < n; i++) {
        graph->edges[i] = (int *)malloc(sizeof(int) * 1); // 每个节点至少有一个边
        graph->edges[i][0] = -1; // 初始化为-1，表示没有边
    }
    return graph;
}

// 添加边
void addEdge(Graph *graph, int start, int end) {
    int *temp = graph->edges[start];
    int newSize = 1 + sizeof(temp) / sizeof(temp[0]);
    graph->edges[start] = (int *)realloc(temp, newSize * sizeof(int));
    graph->edges[start][newSize - 1] = end;
}

// 释放图的内存
void freeGraph(Graph *graph) {
    for (int i = 0; i < graph->n; i++) {
        free(graph->edges[i]);
    }
    free(graph->edges);
    free(graph);
}

// 深度优先搜索，计算从节点i开始可以访问的不同节点数
int dfs(Graph *graph, int i, int *visited) {
    int count = 1; // 访问当前节点
    visited[i] = 1;
    for (int j = 0; graph->edges[i][j] != -1; j++) {
        int end = graph->edges[i][j];
        if (!visited[end]) {
            count += dfs(graph, end, visited);
        }
    }
    return count;
}

// 计算所有节点的访问计数
int *countVisitedNodes(Graph *graph, int n) {
    int *answer = (int *)malloc(sizeof(int) * n);
    int *visited = (int *)calloc(n, sizeof(int)); // 初始化所有节点为未访问
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            answer[i] = dfs(graph, i, visited);
        }
    }
    free(visited);
    return answer;
}

int main() {
    // 示例输入
    int n = 4;
    Graph *graph = createGraph(n);
    addEdge(graph, 0, 1);
    addEdge(graph, 1, 2);
    addEdge(graph, 2, 0);
    addEdge(graph, 3, 0);

    // 计算访问计数
    int *answer = countVisitedNodes(graph, n);

    // 输出结果
    for (int i = 0; i < n; i++) {
        printf("%d ", answer[i]);
    }
    printf("\n");

    // 释放内存
    freeGraph(graph);
    free(answer);

    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_N 100
#define MAX_M 100
#define DIRS 4

int visited[MAX_N][MAX_M];
int grid[MAX_N][MAX_M];
int directions[DIRS][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

int is_valid(int x, int y, int n, int m) {
    return x >= 0 && x < n && y >= 0 && y < m && !visited[x][y] && grid[x][y] != -1;
}

void bfs(int x, int y, int n, int m, int *sum) {
    int q[MAX_N * MAX_M];
    int head = 0, tail = 0;
    q[tail++] = x;
    q[tail++] = y;
    visited[x][y] = 1;
    *sum += abs(grid[x][y]);

    while (head < tail) {
        int cx = q[head++];
        int cy = q[head++];
        for (int i = 0; i < DIRS; ++i) {
            int nx = cx + directions[i][0];
            int ny = cy + directions[i][1];
            if (is_valid(nx, ny, n, m)) {
                visited[nx][ny] = 1;
                *sum += abs(grid[nx][ny]) + 1;
                q[tail++] = nx;
                q[tail++] = ny;
            }
        }
    }
}

long long sumOfRemoteness(int** grid, int gridRowSize, int gridColSize) {
    long long sum = 0;
    memset(visited, 0, sizeof(visited));
    for (int i = 0; i < gridRowSize; ++i) {
        for (int j = 0; j < gridColSize; ++j) {
            if (grid[i][j] == 0 && !visited[i][j]) {
                bfs(i, j, gridRowSize, gridColSize, &sum);
            }
        }
    }
    return sum;
}

int main() {
    // 示例输入
    int grid[MAX_N][MAX_M] = {
        {-1, 1, -1},
        {5, -1, 4},
        {-1, 3, -1}
    };
    int n = 3, m = 3;
    int** g = (int**)malloc(n * sizeof(int*));
    for (int i = 0; i < n; ++i) {
        g[i] = grid[i];
    }
    long long result = sumOfRemoteness(g, n, m);
    printf("%lld\n", result);
    free(g);
    return 0;
}
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// 比较两个字符串的字典序
int compare(const char* a, const char* b) {
    return strcmp(a, b);
}

// 找到最短且字典序最小的美丽子字符串
char* shortestBeautifulSubstring(char* s, int k) {
    int len = strlen(s);
    char* result = NULL;
    int minLen = len + 1; // 初始化为不可能的长度

    for (int i = 0; i < len; ++i) {
        int count = 0; // 用于计数1的数量
        for (int j = i; j < len; ++j) {
            if (s[j] == '1') ++count;
            if (count == k && j - i + 1 < minLen) {
                // 找到更短或相同长度但字典序更小的字符串
                result = (char*)realloc(result, (j - i + 2) * sizeof(char));
                strncpy(result, s + i, j - i + 1);
                result[j - i + 1] = '\0'; // 确保字符串结束符
                minLen = j - i + 1;
            }
        }
    }

    return result;
}

int main() {
    char s[] = "100011101";
    int k = 3;
    char* beautifulStr = shortestBeautifulSubstring(s, k);
    printf("最短且字典序最小的美丽子字符串: %s\n", beautifulStr);
    free(beautifulStr); // 释放之前分配的内存
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int cmp(const void *a, const void *b) {
    return (*(int*)b - *(int*)a);
}

int minimumProcessingTime(int *processorTime, int processorTimeSize, int *tasks, int tasksSize) {
    // 对任务执行时间进行排序
    qsort(tasks, tasksSize, sizeof(int), cmp);
    // 对处理器空闲时间排序
    qsort(processorTime, processorTimeSize, sizeof(int), cmp);
    
    int i = 0, j = 0, maxTime = 0;
    while (j < tasksSize) {
        // 为当前处理器分配任务
        for (int k = 3; k > 0 && i < processorTimeSize && j < tasksSize; --k) {
            int timeTaken = processorTime[i] + tasks[j];
            if (timeTaken > maxTime) {
                maxTime = timeTaken;
            }
            j++;
        }
        i++;
    }
    return maxTime;
}

int main() {
    int processorTime[] = {8, 10};
    int tasks[] = {2, 2, 3, 1, 8, 7, 4, 5};
    int n = sizeof(processorTime) / sizeof(processorTime[0]);
    int result = minimumProcessingTime(processorTime, n, tasks, 4 * n);
    printf("Minimum processing time: %d\n", result);
    return 0;
}
#include <stdio.h>

int maxSum(int* nums, int numsSize, int k) {
    int mod = 1000000007;
    // 排序数组，根据元素中1的个数降序排列
    int count[32] = {0}; // 假设int最大为32位
    for (int i = 0; i < numsSize; ++i) {
        int num = nums[i];
        while (num > 0) {
            count[31 - __builtin_clz(num)]++;
            num &= (num - 1); // 清除最低位的1
        }
    }
    int total = 0;
    // 选择具有最多1的前k个数
    for (int i = 31; i >= 0; --i) {
        if (k > count[i]) {
            k -= count[i];
            total += (1 << i) * count[i];
        } else {
            total += (1 << i) * k;
            break;
        }
    }
    // 计算平方和
    long long sum = 0;
    for (int i = 0; i < k; ++i) {
        sum += (long long)(total % mod) * (total % mod);
    }
    return (int)(sum % mod);
}

int main() {
    int nums[] = {2, 6, 5, 8};
    int k = 2;
    printf("Maximum sum of squares: %d\n", maxSum(nums, sizeof(nums) / sizeof(nums[0]), k));
    return 0;
}
#include <stdio.h>

// 定义结构体用于存储步数和日期
typedef struct {
    int user_id;
    int steps_count;
    char steps_date[11];
} Step;

// 计算滚动平均值的函数
double* rollingAverage(Step* steps, int stepsSize, int k, int* returnSize) {
    // 动态分配数组存储滚动平均值
    double* averages = malloc(sizeof(double) * (stepsSize - k + 1));
    int sum = 0; // 当前窗口的步数总和
    for (int i = 0; i < k; i++) {
        sum += steps[i].steps_count;
    }
    // 初始化滚动平均值数组的第一个元素
    averages[0] = (double)sum / k;
    *returnSize = stepsSize - k + 1;
    
    // 遍历步数列表，计算滚动平均值
    for (int i = k; i < stepsSize; i++) {
        sum += steps[i].steps_count - steps[i - k].steps_count; // 更新窗口总和
        averages[i - k + 1] = (double)sum / k;
    }
    
    return averages;
}

int main() {
    // 示例测试用例
    Step steps[] = {
        {1, 687, "2021-09-02"},
        {1, 395, "2021-09-04"},
        {1, 499, "2021-09-05"}
        // ... 更多步数记录
    };
    int k = 3;
    int returnSize;
    double* result = rollingAverage(steps, sizeof(steps) / sizeof(steps[0]), k, &returnSize);
    
    // 打印结果
    for (int i = 0; i < returnSize; i++) {
        printf("Day %d rolling average steps: %.2f\n", i + 1, result[i]);
    }
    
    // 释放内存
    free(result);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int sumOfSquares(int* nums, int numsSize) {
    int result = 0;
    int mod = 1000000007;
    int prefix[101][101] = {0}; // 存储前缀和，索引为不同计数和当前索引
    int count[101] = {0}; // 存储每个不同计数出现的次数

    // 初始化第一个元素
    prefix[1][0] = nums[0];
    count[1] = 1;

    for (int i = 1; i < numsSize; ++i) {
        int num = nums[i];
        // 记录当前元素出现的次数
        for (int j = 1; j <= i; ++j) {
            if (prefix[j][i - 1] == num) {
                prefix[j][i] = prefix[j][i - 1];
                count[j] = count[j] % mod;
            } else {
                prefix[j][i] = (prefix[j][i - 1] + 1) % mod;
                count[j] = (count[j] + 1) % mod;
            }
        }
    }

    // 计算所有不同计数的平方和
    for (int i = 1; i <= numsSize; ++i) {
        result = (result + (count[i] * (count[i] * i * i))) % mod;
    }

    return result;
}

int main() {
    int nums[] = {1, 2, 1};
    int size = sizeof(nums) / sizeof(nums[0]);
    printf("Sum of Squares: %d\n", sumOfSquares(nums, size));
    return 0;
}
int* lastVisited(int* nums, int numsSize, int* returnSize) {
    // 初始化seen和ans数组
    int capacity = 100;
    int* seen = (int*)malloc(capacity * sizeof(int));
    int* ans = (int*)malloc(capacity * sizeof(int));
    int seenSize = 0, ansSize = 0;

    // 遍历nums数组
    for (int i = 0; i < numsSize; i++) {
        if (nums[i] > 0) {
            // 正整数添加到seen数组的开头
            if (seenSize == capacity) {
                capacity *= 2;
                seen = (int*)realloc(seen, capacity * sizeof(int));
            }
            for (int j = seenSize; j > 0; j--) {
                seen[j] = seen[j - 1];
            }
            seen[0] = nums[i];
            seenSize++;
        } else {
            // 处理-1
            int k = 1;
            while (i + k < numsSize && nums[i + k] == -1) {
                k++;
            }
            if (k <= seenSize) {
                // 如果k小于等于seen数组的长度
                if (ansSize == capacity) {
                    capacity *= 2;
                    ans = (int*)realloc(ans, capacity * sizeof(int));
                }
                ans[ansSize++] = seen[seenSize - k];
            } else {
                // 如果k大于seen数组的长度
                if (ansSize == capacity) {
                    capacity *= 2;
                    ans = (int*)realloc(ans, capacity * sizeof(int));
                }
                ans[ansSize++] = -1;
            }
        }
    }

    // 调整ans数组大小
    ans = (int*)realloc(ans, ansSize * sizeof(int));
    *returnSize = ansSize;
    free(seen); // 释放seen数组
    return ans;
}
int* findIndices(int* nums, int numsSize, int indexDifference, int valueDifference, int* returnSize) {
    int *answer = (int *)malloc(2 * sizeof(int)); // 预先分配两个整数的空间
    for (int i = 0; i < numsSize; ++i) {
        for (int j = i + 1; j < numsSize; ++j) { // 从i+1开始，确保索引差至少为1
            if (abs(i - j) >= indexDifference && abs(nums[i] - nums[j]) >= valueDifference) {
                answer[0] = i; // 赋值i到answer的第一个位置
                answer[1] = j; // 赋值j到answer的第二个位置
                *returnSize = 2; // 设置返回数组的大小为2
                return answer; // 直接返回结果
            }
        }
    }
    answer[0] = -1; // 如果没有找到合适的索引对，设置答案为[-1, -1]
    answer[1] = -1;
    *returnSize = 2;
    return answer;
}
int minimum_number_of_groups(int *balls, int ballsSize) {
    // 统计每个数字出现的次数
    int max_val = 0;
    for (int i = 0; i < ballsSize; ++i) {
        if (balls[i] > max_val) {
            max_val = balls[i];
        }
    }
    int *count = (int *)calloc(max_val + 1, sizeof(int));
    for (int i = 0; i < ballsSize; ++i) {
        count[balls[i]]++;
    }

    // 对出现次数进行排序
    int temp;
    for (int i = 0; i < max_val; ++i) {
        for (int j = i + 1; j < max_val + 1; ++j) {
            if (count[i] < count[j]) {
                temp = count[i];
                count[i] = count[j];
                count[j] = temp;
            }
        }
    }

    // 分配盒子
    int boxes = 0;
    int j = max_val;
    while (j > 0) {
        int i = 1;
        while (i <= j && count[i] > 0) {
            count[i] -= (j - 1);
            i++;
            boxes++;
        }
        j--;
    }

    free(count);
    return boxes;
}
#include <stdio.h>
#include <stdlib.h>

// 用于比较两个整数的函数，供 qsort 使用
int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

// 找出满足条件的下标对
int* findIndices(int* nums, int numsSize, int indexDifference, int valueDifference, int* returnSize) {
    // 初始化返回数组和返回数组的大小
    int* result = (int*)malloc(2 * sizeof(int));
    *returnSize = 2;

    // 对数组进行排序
    qsort(nums, numsSize, sizeof(int), compare);

    // 使用双指针查找满足条件的下标对
    for (int i = 0, j = indexDifference; j < numsSize; i++, j++) {
        if (nums[j] - nums[i] >= valueDifference) {
            result[0] = i;
            result[1] = j;
            return result;
        }
    }

    // 如果没有找到满足条件的下标对，返回 [-1, -1]
    result[0] = -1;
    result[1] = -1;
    return result;
}

int main() {
    int nums[] = {5, 1, 4, 1};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int indexDifference = 2;
    int valueDifference = 4;
    int returnSize = 0;

    int* result = findIndices(nums, numsSize, indexDifference, valueDifference, &returnSize);

    printf("Indices: [%d, %d]\n", result[0], result[1]);
    free(result);

    return 0;
}
int minSumEqualize(int* nums1, int m, int* nums2, int n) {
    int sum1 = 0, sum2 = 0, diff = 0, zeros1 = 0, zeros2 = 0;
    
    // 计算两个数组的和以及0的个数
    for (int i = 0; i < m; i++) {
        sum1 += nums1[i];
        if (nums1[i] == 0) zeros1++;
    }
    for (int i = 0; i < n; i++) {
        sum2 += nums2[i];
        if (nums2[i] == 0) zeros2++;
    }
    
    // 计算差值
    diff = abs(sum1 - sum2);
    
    // 替换0以达到和相等
    if (diff > 0) {
        // 如果sum1大于sum2，从nums1中替换0
        diff = (diff <= zeros1) ? diff : -1;
    } else if (diff < 0) {
        // 如果sum2大于sum1，从nums2中替换0
        diff = (-diff <= zeros2) ? -diff : -1;
    }
    
    // 更新和
    if (diff != -1) {
        if (sum1 > sum2) {
            sum1 -= diff;
        } else {
            sum2 += diff;
        }
    }
    
    // 返回最小相等和或-1
    return (sum1 == sum2) ? (sum1 + diff - 1) : -1;
}
#include <stdio.h>
#include <string.h>

int minChanges(char *s) {
    int len = strlen(s);
    int changes = 0;
    
    for (int i = 0; i < len; i += 2) {
        // 检查长度为2的子串中的两个字符是否相同
        if (s[i] != s[i + 1]) {
            changes++;
        }
    }
    
    return changes;
}

int main() {
    char s[] = "1001";
    printf("最少修改次数: %d\n", minChanges(s));
    return 0;
}
int minimumSum(int* nums, int numsSize) {
    int minSum = 51; // 初始化为一个大于50的数
    int i, j, k;

    // 寻找峰值并检查山形三元组
    for (j = 1; j < numsSize - 1; j++) {
        if (nums[j - 1] < nums[j] && nums[j] > nums[j + 1]) {
            // 峰值左侧找到最大的数
            for (i = j - 1; i >= 0; i--) {
                if (nums[i] < nums[j]) {
                    break;
                }
            }
            // 峰值右侧找到最小的数
            for (k = j + 1; k < numsSize; k++) {
                if (nums[k] < nums[j]) {
                    break;
                }
            }
            // 计算当前山形三元组的和，并更新最小和
            int currentSum = nums[i] + nums[j] + nums[k];
            if (currentSum < minSum) {
                minSum = currentSum;
            }
        }
    }

    return (minSum == 51) ? -1 : minSum; // 如果没有找到，则返回-1
}
#include <stdio.h>
#include <stdlib.h>

int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int minimizeArrayAfterReplacements(int* nums, int numsSize, int k) {
    qsort(nums, numsSize, sizeof(int), compare);
    int i = 0;
    while (k--) {
        if (i >= numsSize - 1) break; // 如果只剩下一个元素，结束操作
        int minIndex = (i == 0) ? i : (nums[i - 1] < nums[i] ? i - 1 : i);
        // 选择当前最小的两个数进行乘法操作
        nums[minIndex] *= nums[minIndex + 1];
        // 由于乘法操作可能使得新的元素成为最小值，需要重新排序
        qsort(nums, numsSize, sizeof(int), compare);
        // 更新索引位置
        i = minIndex > 0 ? minIndex : 0;
    }
    return nums[0]; // 返回数组最小化后的第一个元素
}

int main() {
    int nums[] = {2, 3, 3, 7, 3, 5};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int k = 2;
    printf("Minimized array after %d replacements is: %d\n", k, minimizeArrayAfterReplacements(nums, numsSize, k));
    return 0;
}
int maxScore(int* prices, int pricesSize) {
    int maxScore = 0;
    // 计算累积和
    int* prefixSum = (int*)malloc(pricesSize * sizeof(int));
    prefixSum[0] = 0;
    for (int i = 1; i < pricesSize; ++i) {
        prefixSum[i] = prefixSum[i - 1] + prices[i] - prices[i - 1];
    }

    // 使用双指针查找最大得分
    for (int i = 0; i < pricesSize; ++i) {
        int minPrefixSum = prefixSum[i];
        for (int j = i; j < pricesSize; ++j) {
            minPrefixSum = fmin(minPrefixSum, prefixSum[j]);
            int score = prefixSum[j] - minPrefixSum - (j - i) * prices[i];
            maxScore = fmax(maxScore, score);
        }
    }

    free(prefixSum);
    return maxScore;
}
#include <stdio.h>

int findKOr(int* nums, int numsSize, int k) {
    int result = 0;
    for (int bit = 0; bit < 32; ++bit) {
        int count = 0;
        for (int i = 0; i < numsSize; ++i) {
            if ((nums[i] >> bit) & 1) {
                count++;
            }
        }
        if (count >= k) {
            result |= (1 << bit);
        }
    }
    return result;
}

int main() {
    int nums[] = {7, 12, 9, 8, 9, 15};
    int k = 4;
    printf("The K-or value is: %d\n", findKOr(nums, sizeof(nums) / sizeof(nums[0]), k));
    return 0;
}
int maxBalancedSubsequenceSum(int* nums, int numsSize) {
    if (numsSize == 0) return 0;
    
    // 初始化dp数组
    int dp[numsSize];
    dp[0] = nums[0];
    int maxSum = dp[0];
    
    // 动态规划求解
    for (int i = 1; i < numsSize; i++) {
        dp[i] = nums[i];
        for (int j = 0; j < i; j++) {
            if (nums[i] - nums[j] >= i - j) {
                dp[i] = max(dp[i], nums[i] + dp[j]);
            }
        }
        maxSum = max(maxSum, dp[i]);
    }
    
    return maxSum;
}
// 函数用于计算最大利润
int maxProfit(int* prices, int pricesSize) {
    if (pricesSize < 3) return 0;

    int minPrice = prices[0]; // 记录最小买入价格
    int maxProfit = 0; // 记录最大利润

    for (int i = 1; i < pricesSize; i++) {
        // 更新最小买入价格
        if (prices[i] < minPrice) {
            minPrice = prices[i];
        } else {
            // 当前价格大于最小价格，检查是否为卖出点以获取利润
            maxProfit = maxProfit > 0 ? maxProfit : 0;
            maxProfit = max(maxProfit, prices[i] - minPrice);
        }
    }

    return maxProfit;
}
int findChampion(int** grid, int gridRowSize, int gridColSize) {
    for (int i = 0; i < gridRowSize; i++) {
        int isChampion = 1; // 假设当前队伍是冠军
        for (int j = 0; j < gridColSize; j++) {
            if (i != j && grid[i][j] == 1) {
                // 如果存在其他队伍能击败当前队伍，则当前队伍不是冠军
                isChampion = 0;
                break;
            }
        }
        if (isChampion) {
            return i; // 返回冠军队伍的编号
        }
    }
    return -1; // 如果没有队伍能成为冠军，返回-1（这种情况在题目中是不会出现的）
}
#include <stdio.h>
#include <stdlib.h>

typedef struct Edge {
    int to;
    struct Edge* next;
} Edge;

typedef struct {
    Edge* head;
    int inDegree;
} Node;

int findChampion(int n, int** edges, int* edgesRowSize, int* edgesColSize) {
    Node nodes[n];
    for (int i = 0; i < n; ++i) {
        nodes[i].head = NULL;
        nodes[i].inDegree = 0;
    }

    // 构建图
    for (int i = 0; i < edgesRowSize[0]; ++i) {
        int from = edges[0][i];
        int to = edges[1][i];
        Edge* edge = (Edge*)malloc(sizeof(Edge));
        edge->to = to;
        edge->next = nodes[from].head;
        nodes[from].head = edge;
        nodes[to].inDegree++;
    }

    int count = 0;
    int champion = -1;
    // 拓扑排序查找冠军
    for (int i = 0; i < n; ++i) {
        if (nodes[i].inDegree == 0) {
            count++;
            champion = i;
            // 检查是否是唯一冠军
            for (int j = 0; j < n; ++j) {
                if (nodes[j].head != NULL && j != i) {
                    Edge* temp = nodes[j].head;
                    while (temp != NULL) {
                        if (temp->to == i) {
                            break;
                        }
                        temp = temp->next;
                    }
                    if (temp != NULL) break;
                }
            }
            if (count > 1) break;
        }
    }

    return count == 1 ? champion : -1;
}
#include <stdio.h>
#include <string.h>

int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int* findWordsContainingCharacter(char** words, int wordsSize, char x, int* returnSize) {
    int *result = malloc(sizeof(int) * wordsSize);
    *returnSize = 0;
    
    for (int i = 0; i < wordsSize; i++) {
        if (strchr(words[i], x) != NULL) {
            result[*returnSize] = i;
            (*returnSize)++;
        }
    }
    
    qsort(result, *returnSize, sizeof(int), compare);
    
    return result;
}

int main() {
    char* words[] = {"leet", "code"};
    int wordsSize = sizeof(words) / sizeof(words[0]);
    char x = 'e';
    int returnSize = 0;
    
    int *result = findWordsContainingCharacter(words, wordsSize, x, &returnSize);
    
    for (int i = 0; i < returnSize; i++) {
        printf("%d ", result[i]);
    }
    
    free(result);
    return 0;
}
#include <stdio.h>
#include <string.h>

int minimumSwaps(char* s) {
    int length = strlen(s);
    int zeroCount = 0; // 记录 '0' 的数量
    int swapCount = 0; // 交换次数

    for (int i = 0; i < length; ++i) {
        if (s[i] == '0') {
            zeroCount++;
        } else {
            swapCount += zeroCount;
        }
    }

    return swapCount;
}

int main() {
    char s[] = "101";
    printf("Minimum swaps: %d\n", minimumSwaps(s));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 比较函数，用于qsort
int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

// 二分查找可能的众数
int bsearch(int *nums, int n, int k) {
    int left = 0, right = n - 1;
    int mid, res = 0;
    while (left <= right) {
        mid = left + (right - left) / 2;
        int moves = 0;
        // 计算将mid作为众数时需要的操作次数
        for (int i = 0; i < n; ++i) {
            if (i < mid) {
                moves += mid - nums[i];
            } else if (i > mid) {
                moves += nums[i] - mid;
            }
        }
        // 如果操作次数小于等于k，尝试扩大众数的范围
        if (moves <= k) {
            res = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return res;
}

// 计算最大频率分数
int maxFrequencyScore(int *nums, int numsSize, int k) {
    // 对数组进行排序
    qsort(nums, numsSize, sizeof(int), compare);
    // 使用二分查找可能的众数，并计算最大频率分数
    int mode = bsearch(nums, numsSize, k);
    // 计算以mode为众数时的频率
    int count = 0, maxCount = 0;
    for (int i = 0; i < numsSize; ++i) {
        if (nums[i] == mode) ++count;
        else if (nums[i] > mode) {
            maxCount = max(maxCount, count);
            count = 0;
        }
    }
    maxCount = max(maxCount, count); // 包括数组末尾的连续mode
    return maxCount;
}

// 辅助函数，用于计算两个数的最大值
int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    int nums[] = {1, 2, 6, 4};
    int k = 3;
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    printf("The maximum frequency score is: %d\n", maxFrequencyScore(nums, numsSize, k));
    return 0;
}
int maxStrongPairXor(int* nums, int numsSize) {
    // 排序数组
    qsort(nums, numsSize, sizeof(int), compare);

    int max_xor = 0;
    for (int i = 0; i < numsSize; ++i) {
        for (int j = i + 1; j < numsSize; ++j) {
            // 计算异或值
            int xor_val = nums[i] ^ nums[j];
            // 更新最大异或值
            if (xor_val > max_xor) {
                max_xor = xor_val;
            }
        }
    }
    return max_xor;
}
int numberOfWays(int m, int n, int* source, int* dest) {
    int dp[m][n]; // 动态规划表
    int i, j;

    // 初始化动态规划表
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            dp[i][j] = 0;
        }
    }
    dp[source[0]][source[1]] = 1; // 起点初始化

    // 动态规划填表
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            if (i == 0 && j == 0) continue; // 起点已初始化
            if (i > 0) dp[i][j] += dp[i - 1][j]; // 从上方来
            if (j > 0) dp[i][j] += dp[i][j - 1]; // 从左方来
        }
    }

    return dp[dest[0]][dest[1]]; // 目的地的路径数量
}
#include <stdio.h>

// 计算组合数 C(n, k)
long long combine(int n, int k) {
    long long c = 1;
    if (k > n) return 0;
    if (k > n - k) k = n - k;
    for (int i = 0; i < k; ++i) {
        c *= n - i;
        c /= i + 1;
    }
    return c;
}

// 分糖果的方案数
int distributeCandies(int n, int limit) {
    return n > 2 * limit ? combine(n, 2) : 0;
}

int main() {
    int n = 5, limit = 2;
    printf("Total ways to distribute candies: %d\n", distributeCandies(n, limit));
    return 0;
}
1. **MPU配置**：通过`mpu_set_protection`函数，可以配置MPU的保护区域。
2. **内存区域保护**：`mpu_memory_protection`函数设置了多个内存区域的保护，包括DTCM、AXI SRAM、SRAM1~SRAM3、SRAM4、FMC、SDRAM和NAND FLASH。
3. **错误处理**：`MemManage_Handler`函数处理内存访问错误，并通过LED和串口输出错误信息，最后执行软件复位。
/** 
 * 初始化按键
 * 配置GPIO引脚，设置为输入模式，并启用内部下拉电阻。
 */
void key_init(void)
{
    GPIO_InitTypeDef gpio_init_struct;  // 定义GPIO初始化结构体

    // 使能GPIO时钟，确保GPIO能够正常工作
    KEY0_GPIO_CLK_ENABLE();  // 使能KEY0的GPIO时钟
    WKUP_GPIO_CLK_ENABLE();  // 使能WKUP的GPIO时钟

    // 配置KEY0引脚为输入模式，启用下拉电阻，设置为高速
    gpio_init_struct.Pin = KEY0_GPIO_PIN;  // 设置引脚
    gpio_init_struct.Mode = GPIO_MODE_INPUT;  // 设置为输入模式
    gpio_init_struct.Pull = GPIO_PULLDOWN;  // 设置为下拉
    gpio_init_struct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;  // 设置为高速
    HAL_GPIO_Init(KEY0_GPIO_PORT, &gpio_init_struct);  // 初始化KEY0引脚

    // 配置WKUP引脚，与KEY0引脚配置相同
    gpio_init_struct.Pin = WKUP_GPIO_PIN;  // 设置引脚
    HAL_GPIO_Init(WKUP_GPIO_PORT, &gpio_init_struct);  // 初始化WKUP引脚
}
uint8_t key_scan(uint8_t mode)
{
    static uint8_t key_up = 1;  // 静态变量，用于标记按键是否松开

    if (mode == 1)  // 如果支持连续按键
    {
        key_up = 1;  // 重置按键松开标志
    }

    // 如果按键松开标志为1，并且有按键被按下
    if (key_up && (KEY0 == 1 || WK_UP == 1))
    {
        delay_ms(10);  // 去抖动
        key_up = 0;  // 标记按键已经被按下

        // 检测哪个按键被按下，并设置相应的返回值
        if (KEY0 == 1)
        {
            return KEY0_PRES;  // 返回KEY0按下的值
        }
        if (WK_UP == 1)
        {
            return WKUP_PRES;  // 返回WKUP按下的值
        }
    }
    else if (KEY0 == 0 && WK_UP == 0)  // 如果没有按键被按下
    {
        key_up = 1;  // 重置按键松开标志
    }

    return 0;  // 如果没有按键按下，返回0
}
/* 设置DAC输出电压的函数 */
void dac_set_voltage(uint8_t outx, uint16_t vol)
{
    uint32_t dacdata;
    
    /* 将电压值转换为DAC可接受的数字量 */
    dacdata = vol * 4095 / 3300;
    
    /* 限制dacdata的最大值为4095 */
    if (dacdata >= 4096)
    {
        dacdata = 4095;
    }
    
    /* 根据通道设置DAC值 */
    if (outx == 1)
    {
        HAL_DAC_SetValue(&g_dac_handle, DAC_CHANNEL_1, DAC_ALIGN_12B_R, dacdata);
    }
    else
    {
        HAL_DAC_SetValue(&g_dac_handle, DAC_CHANNEL_2, DAC_ALIGN_12B_R, dacdata);
    }
}
/* 初始化DAC通道的函数 */
void dac_init(uint8_t outx)
{
    /* 配置结构体定义 */
    DAC_ChannelConfTypeDef dac_ch_conf;
    GPIO_InitTypeDef gpio_init_struct;
    
    /* 使能DAC和GPIOA的时钟 */
    __HAL_RCC_DAC12_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    
    /* 根据通道配置GPIO引脚为模拟模式 */
    gpio_init_struct.Pin = (outx == 1) ? GPIO_PIN_4 : GPIO_PIN_5;
    gpio_init_struct.Mode = GPIO_MODE_ANALOG;
    HAL_GPIO_Init(GPIOA, &gpio_init_struct);
    
    /* 初始化DAC */
    g_dac_handle.Instance = DAC1;
    HAL_DAC_Init(&g_dac_handle);
    
    /* 配置DAC通道 */
    dac_ch_conf.DAC_Trigger = DAC_TRIGGER_NONE;
    dac_ch_conf.DAC_OutputBuffer = DAC_OUTPUTBUFFER_DISABLE;
    
    /* 根据outx选择通道并配置 */
    switch(outx)
    {
        case 1 :
            HAL_DAC_ConfigChannel(&g_dac_handle, &dac_ch_conf, DAC_CHANNEL_1);
            HAL_DAC_Start(&g_dac_handle, DAC_CHANNEL_1);
            break;
        case 2 :
            HAL_DAC_ConfigChannel(&g_dac_handle, &dac_ch_conf, DAC_CHANNEL_2);
            HAL_DAC_Start(&g_dac_handle, DAC_CHANNEL_2);
            break;
        default :
            break;
    }
}
void dac_init(uint8_t outx)
{
    /* 配置结构体定义 */
    DAC_ChannelConfTypeDef dac_ch_conf;
    GPIO_InitTypeDef gpio_init_struct;
    
    /* 使能DAC和GPIOA的时钟 */
    __HAL_RCC_DAC12_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    
    /* 根据通道配置GPIO引脚为模拟模式 */
    gpio_init_struct.Pin = (outx == 1) ? GPIO_PIN_4 : GPIO_PIN_5;
    gpio_init_struct.Mode = GPIO_MODE_ANALOG;
    HAL_GPIO_Init(GPIOA, &gpio_init_struct);
    
    /* 初始化DAC */
    g_dac_handle.Instance = DAC1;
    HAL_DAC_Init(&g_dac_handle);
    
    /* 配置DAC通道 */
    dac_ch_conf.DAC_Trigger = DAC_TRIGGER_NONE;
    dac_ch_conf.DAC_OutputBuffer = DAC_OUTPUTBUFFER_DISABLE;
    
    /* 根据outx选择通道并配置 */
    switch(outx)
    {
        case 1 :
            HAL_DAC_ConfigChannel(&g_dac_handle, &dac_ch_conf, DAC_CHANNEL_1);
            HAL_DAC_Start(&g_dac_handle, DAC_CHANNEL_1);
            break;
        case 2 :
            HAL_DAC_ConfigChannel(&g_dac_handle, &dac_ch_conf, DAC_CHANNEL_2);
            HAL_DAC_Start(&g_dac_handle, DAC_CHANNEL_2);
            break;
        default :
            break;
    }
}
/* 定义LED0的IO操作宏，用于控制LED0的亮灭 */
#define LED0(x)                 do{ x ? \
                                    HAL_GPIO_WritePin(LED0_GPIO_PORT, LED0_GPIO_PIN, GPIO_PIN_SET) :  \
                                    HAL_GPIO_WritePin(LED0_GPIO_PORT, LED0_GPIO_PIN, GPIO_PIN_RESET); \
                                }while(0)

/* 定义LED0的状态翻转宏 */
#define LED0_TOGGLE()           do{ HAL_GPIO_TogglePin(LED0_GPIO_PORT, LED0_GPIO_PIN); }while(0)

```c
#ifndef __NORFLASH_EX_H // 确保头文件只被包含一次
#define __NORFLASH_EX_H

#include "./SYSTEM/sys/sys.h" // 包含系统头文件

/* 函数声明 */
// 以下函数用于操作QSPI闪存

void norflash_ex_erase_chip(void); // 擦除整个QSPI闪存芯片
uint16_t norflash_ex_read_id(void); // 从QSPI闪存读取制造商和设备ID
void norflash_ex_erase_sector(uint32_t addr); // 根据提供的地址擦除QSPI闪存的扇区
uint8_t norflash_ex_write(uint8_t *pbuf, uint32_t addr, uint16_t datalen); // 向QSPI闪存写入数据
void norflash_ex_read(uint8_t *pbuf, uint32_t addr, uint16_t datalen); // 从QSPI闪存读取数据

#endif // 防止头文件重复包含
这段代码是一个针对STM32微控制器的DCMI（数字相机接口）驱动程序，用于初始化和控制DCMI接口，以便与数字相机进行通信。下面是对代码的概括、关键点分析以及注释建议：
这段代码提供了一套SCCB通信协议的驱动函数，用于初始化SCCB接口，控制SCCB的信号线，以及发送和接收数据。
这段代码是一个STM32微控制器项目中用于SCCB（一种串行通信总线）的驱动实现。SCCB常用于I2C设备之间的通信，但具有不同的信号线定义和协议。以下是对这段代码的概括和关键点分析，以及对每一行代码的注释：
#include <stdio.h>
#include <stdlib.h>

// 定义二叉树的节点结构
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 判断序列是否是二叉树的有效路径的函数
int isValidSequence(TreeNode* root, int* arr, int arrSize) {
    // 如果数组为空，但根节点不为空，说明路径不合法
    if (arrSize == 0 && root != NULL) return 0;
    // 如果当前节点为空，且数组还有元素，说明路径不合法
    if (root == NULL && arrSize > 0) return 0;
    // 如果当前节点不为空，且当前节点的值与数组第一个元素不相等，返回0
    if (root != NULL && root->val != arr[0]) return 0;

    // 如果当前节点为空，且数组也为空，说明路径合法
    if (root == NULL && arrSize == 0) return 1;

    // 递归检查左子树和右子树
    return isValidSequence(root->left, arr + 1, arrSize - 1) || 
           isValidSequence(root->right, arr + 1, arrSize - 1);
}

// 测试用例
int main() {
    // 创建一个示例二叉树 [0,1,0,0,1,null,null,1,0,0] 并检查序列 [0,1,0,1]
    TreeNode* root = (TreeNode*)malloc(sizeof(TreeNode));
    root->val = 0;
    root->left = (TreeNode*)malloc(sizeof(TreeNode));
    root->left->val = 1;
    root->left->left = (TreeNode*)malloc(sizeof(TreeNode));
    root->left->left->val = 0;
    root->left->left->left = NULL;
    root->left->left->right = (TreeNode*)malloc(sizeof(TreeNode));
    root->left->left->right->val = 1;
    root->left->left->right->left = NULL;
    root->left->left->right->right = NULL;
    root->right = (TreeNode*)malloc(sizeof(TreeNode));
    root->right->val = 0;
    root->right->left = NULL;
    root->right->right = NULL;

    int sequence[] = {0, 1, 0, 1};
    int result = isValidSequence(root, sequence, sizeof(sequence) / sizeof(sequence[0]));
    printf("The sequence is %s a valid path in the binary tree.\n", result ? "valid" : "invalid");

    // 释放二叉树的内存
    // ...

    return 0;
}
#include <stdio.h>
#include <stdio.h>
#include <stdlib.h>

// 定义一个结构体来存储活动和其参与者
typedef struct {
    char *activity;
    int *participants;
    int size;
} Activity;

// 比较函数，用于 qsort
int compare(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);
}

// 找出活动参与者的函数
void findParticipants(Activity *activities, int activitySize) {
    for (int i = 0; i < activitySize; i++) {
        // 对每个活动的参与者进行排序
        qsort(activities[i].participants, activities[i].size, sizeof(int), compare);
        // 打印活动名称和参与者
        printf("Activity: %s\n", activities[i].activity);
        for (int j = 0; j < activities[i].size; j++) {
            printf("%d ", activities[i].participants[j]);
        }
        printf("\n");
    }
}

int main() {
    // 示例输入
    Activity activities[3] = {
        {"Eating", (int[]){1, 3, 4, 5}, 4},
        {"Singing", (int[]){2, 3}, 2},
        {"Horse Riding", (int[]){6}, 1}
    };
    int activitySize = sizeof(activities) / sizeof(activities[0]);

    // 调用函数求解
    findParticipants(activities, activitySize);

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int cmp(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int countTriplets(int* nums, int numsSize) {
    qsort(nums, numsSize, sizeof(int), cmp); // 对数组进行排序
    int count = 0;
    for (int i = 0; i < numsSize; ++i) {
        if (nums[i] < 0) continue; // 跳过负数，因为平方后不可能是单因数
        for (int j = i + 1; j < numsSize; ++j) {
            int target = (long long)nums[i] * nums[i] + (long long)nums[j] * nums[j]; // 计算目标值
            int k = j + 1;
            int l = numsSize - 1;
            while (k < l) {
                if ((long long)nums[k] * nums[k] + (long long)nums[l] * nums[l] == target) {
                    count++; // 找到满足条件的三元组
                    k++;
                    l--;
                } else if ((long long)nums[k] * nums[k] + (long long)nums[l] * nums[l] < target) {
                    k++;
                } else {
                    l--;
                }
            }
        }
    }
    return count;
}

int main() {
    int nums[] = {4, 6, 7, 3, 2};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    printf("Number of Single Divisor Triplets: %d\n", countTriplets(nums, numsSize));
    return 0;
}
#include <stdio.h>

// 函数原型声明
int maxFontValue(char *text, int w, int h, int *fonts, int fontsSize);

int main() {
    // 示例输入
    char text[] = "helloworld";
    int w = 80;
    int h = 20;
    int fonts[] = {6, 8, 10, 12, 14, 16, 18, 24, 36};
    int fontsSize = sizeof(fonts) / sizeof(fonts[0]);

    // 调用函数并打印结果
    int result = maxFontValue(text, w, h, fonts, fontsSize);
    printf("最大字号为: %d\n", result);

    return 0;
}

// 函数定义
int maxFontValue(char *text, int w, int h, int *fonts, int fontsSize) {
    // 从最大字号开始二分查找
    int left = 0, right = fontsSize - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (isValidFontSize(text, w, h, fonts[mid])) {
            // 如果当前字号可行，尝试寻找更大的字号
            left = mid + 1;
        } else {
            // 如果当前字号不可行，寻找更小的字号
            right = mid - 1;
        }
    }
    // 返回找到的最大可行字号
    return fonts[right];
}

// 检查给定的字号是否可行
int isValidFontSize(char *text, int w, int h, int fontSize) {
    int lineLength = 0;
    for (int i = 0; text[i] != '\0'; ++i) {
        lineLength += fontSize; // 每个字符宽度为fontSize
        if (lineLength > w) {
            lineLength = fontSize; // 新行的开始
            if (++h > (int)(1.0 * text[i - 1] == '\n' ? 1 : 0) + (text[i] == '\n' ? 1 : 0)) {
                return 0; // 超出屏幕高度
            }
        }
    }
    return 1; // 字号可行
}
#include <stdio.h>
#include <stdlib.h>

// 定义链表节点结构体
typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

// 逆序打印不可变链表
void reversePrint(ListNode* head) {
    if (!head) return;

    // 使用栈存储节点
    stack<ListNode*> s;
    while (head) {
        s.push(head);
        head = head->next;
    }

    // 打印栈中的节点，实现逆序打印
    while (!s.empty()) {
        ListNode* node = s.top();
        printf("%d ", node->val);
        s.pop();
    }
    printf("\n");
}

// 测试
int main() {
    ListNode* head = (ListNode*)malloc(sizeof(ListNode));
    head->val = 1;
    head->next = NULL;

    // 构建链表 1->2->3
    ListNode* node2 = (ListNode*)malloc(sizeof(ListNode));
    node2->val = 2;
    node2->next = head;

    ListNode* node3 = (ListNode*)malloc(sizeof(ListNode));
    node3->val = 3;
    node3->next = node2;

    reversePrint(node3); // 输出 3 2 1

    // 释放链表占用的内存
    free(node3);
    free(node2);
    free(head);

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 计算逆序对的数量
int countInversions(int* nums, int size) {
    int count = 0;
    for (int i = 0; i < size - 1; ++i) {
        for (int j = i + 1; j < size; ++j) {
            if (nums[i] > nums[j]) {
                count++;
            }
        }
    }
    return count;
}

// 计算顺序对的数量（即数组排序后多余的逆序对数量）
int countNoninversions(int* nums, int size) {
    int count = 0;
    for (int i = 0; i < size - 1; ++i) {
        for (int j = i + 1; j < size; ++j) {
            if (nums[i] < nums[j]) {
                count++;
            }
        }
    }
    return count;
}

// 找到最小的操作次数
int minOperations(int* nums, int numsSize) {
    // 计算逆序对和顺序对的数量
    int inversions = countInversions(nums, numsSize);
    int noninversions = countNoninversions(nums, numsSize);
    // 返回较小的数量，即为所求的最小操作次数
    return (inversions < noninversions) ? inversions : noninversions;
}

int main() {
    int nums[] = {3, 1, 3, 2, 4, 0};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    printf("Minimum operations: %d\n", minOperations(nums, numsSize));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 定义二叉树的节点结构
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 判断序列是否是二叉树的有效路径的函数
int isValidSequence(TreeNode* root, int* arr, int arrSize) {
    // 如果数组为空，但根节点不为空，说明路径不合法
    if (arrSize == 0 && root != NULL) return 0;
    // 如果当前节点为空，且数组还有元素，说明路径不合法
    if (root == NULL && arrSize > 0) return 0;
    // 如果当前节点不为空，且当前节点的值与数组第一个元素不相等，返回0
    if (root != NULL && root->val != arr[0]) return 0;

    // 如果当前节点为空，且数组也为空，说明路径合法
    if (root == NULL && arrSize == 0) return 1;

    // 递归检查左子树和右子树
    return isValidSequence(root->left, arr + 1, arrSize - 1) || 
           isValidSequence(root->right, arr + 1, arrSize - 1);
}

// 测试用例
int main() {
    // 创建一个示例二叉树 [0,1,0,0,1,null,null,1,0,0] 并检查序列 [0,1,0,1]
    TreeNode* root = (TreeNode*)malloc(sizeof(TreeNode));
    root->val = 0;
    root->left = (TreeNode*)malloc(sizeof(TreeNode));
    root->left->val = 1;
    root->left->left = (TreeNode*)malloc(sizeof(TreeNode));
    root->left->left->val = 0;
    root->left->left->left = NULL;
    root->left->left->right = (TreeNode*)malloc(sizeof(TreeNode));
    root->left->left->right->val = 1;
    root->left->left->right->left = NULL;
    root->left->left->right->right = NULL;
    root->right = (TreeNode*)malloc(sizeof(TreeNode));
    root->right->val = 0;
    root->right->left = NULL;
    root->right->right = NULL;

    int sequence[] = {0, 1, 0, 1};
    int result = isValidSequence(root, sequence, sizeof(sequence) / sizeof(sequence[0]));
    printf("The sequence is %s a valid path in the binary tree.\n", result ? "valid" : "invalid");

    // 释放二叉树的内存
    // ...

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 函数用于判断两个数是否互质
int is_coprime(int a, int b) {
    while (b != 0) {
        int temp = a % b;
        a = b;
        b = temp;
    }
    return a == 1;
}

// 函数用于找出所有最简分数
char **simplified_fractions(int n, int *returnSize) {
    // 动态分配内存存储结果
    char **result = (char **)malloc(sizeof(char *) * (n * (n - 1) / 2));
    int count = 0;
    
    for (int i = 1; i < n; ++i) {
        for (int j = i + 1; j <= n; ++j) {
            // 检查是否是最简分数
            if (is_coprime(i, j)) {
                // 计算结果字符串的长度
                int len = snprintf(NULL, 0, "%d/%d", i, j) + 1;
                // 分配内存并生成分数字符串
                char *fraction = (char *)malloc(sizeof(char) * len);
                snprintf(fraction, len, "%d/%d", i, j);
                // 存储结果
                result[count++] = fraction;
            }
        }
    }
    
    *returnSize = count;
    return result;
}

int main() {
    int n = 4;
    int returnSize;
    char **result = simplified_fractions(n, &returnSize);
    
    for (int i = 0; i < returnSize; ++i) {
        printf("%s\n", result[i]);
        free(result[i]);  // 释放每个字符串的内存
    }
    
    free(result);  // 释放结果数组的内存
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 假设我们有一个结构体来存储学生和考试成绩
typedef struct {
    int student_id;
    int score;
} StudentScore;

// 函数来计算总成绩
int calculateTotalScore(StudentScore* studentScores, int length) {
    int totalScore = 0;
    for (int i = 0; i < length; ++i) {
        totalScore += studentScores[i].score;
    }
    return totalScore;
}

// 函数来找出中位数
double findMedian(int* scores, int length) {
    // 这里需要一个排序算法来对成绩进行排序，然后找到中位数
    // 由于C语言标准库中没有内置的排序函数，我们可以使用简单的冒泡排序或快速排序算法
    // 这里省略了排序的实现细节
    // ...
    // 返回排序后数组的中位数
    return median;
}

// 函数来找出成绩处于中游的学生ID
void findMiddleStudents(StudentScore* studentScores, int* studentIDs, int length, int* result, int* returnSize) {
    // 1. 计算每个学生的总成绩
    // 2. 找到所有学生成绩的中位数
    double median = findMedian(...);
    // 3. 根据中位数找出成绩处于中游的学生ID
    for (int i = 0; i < length; ++i) {
        if (studentScores[i].score < median || studentScores[i].score > (2 * median)) {
            result[(*returnSize)++] = studentScores[i].student_id;
        }
    }
}

int main() {
    // 示例数据
    StudentScore studentScores[] = {
        {1, 70},
        {2, 80},
        // ... 更多学生和成绩数据
    };
    int length = sizeof(studentScores) / sizeof(studentScores[0]);
    int studentIDs[length]; // 存储结果的数组
    int returnSize = 0; // 结果数组的大小

    // 调用函数
    findMiddleStudents(studentScores, studentIDs, length, &returnSize);

    // 输出结果
    for (int i = 0; i < returnSize; ++i) {
        printf("%d ", studentIDs[i]);
    }

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int sum;
    int* indices;
    int count;
} Node;

int compare(const void* a, const void* b) {
    Node* nodeA = (Node*)a;
    Node* nodeB = (Node*)b;
    return nodeA->sum - nodeB->sum;
}

int kthSmallest(int** matrix, int matrixSize, int* matrixColSize, int k) {
    int m = matrixSize, n = *matrixColSize;
    Node* minHeap = (Node*)malloc(sizeof(Node) * m * n);
    int heapSize = 0;

    // 初始化最小堆
    for (int i = 0; i < m; ++i) {
        minHeap[heapSize].sum = matrix[i][0];
        minHeap[heapSize].indices = (int*)malloc(sizeof(int) * 2);
        minHeap[heapSize].indices[0] = i;
        minHeap[heapSize].indices[1] = 0;
        minHeap[heapSize].count = 1;
        heapSize++;
    }

    qsort(minHeap, heapSize, sizeof(Node), compare);

    int result = 0;
    for (int i = 0; i < k - 1; ++i) {
        Node current = minHeap[i];
        result += current.sum;

        // 将下一行的相同列元素或当前行的下一列元素加入堆
        if (current.indices[1] + 1 < n) {
            Node next;
            next.sum = current.sum + matrix[current.indices[0]][current.indices[1] + 1];
            next.indices = (int*)malloc(sizeof(int) * 2);
            next.indices[0] = current.indices[0];
            next.indices[1] = current.indices[1] + 1;
            next.count = current.count + 1;

            minHeap[heapSize] = next;
            heapSize++;
            qsort(minHeap + i, heapSize - i, sizeof(Node), compare);
        }
    }
    result += minHeap[k - 1].sum;
    free(minHeap);
    return result;
}
#include <string.h>
#include <stdlib.h>

char **buildArray(const int *target, int targetSize, int n, int *returnSize) {
    // 初始化操作序列数组
    char **ops = (char **)malloc(sizeof(char *) * (n * 2));
    int opIndex = 0;
    
    // 当前遍历的数字
    int currentNum = 1;
    // 遍历数字直到达到或超过目标数组的最后一个元素
    while (currentNum <= n) {
        // 如果当前数字是目标数组的第一个元素
        if (targetSize > 0 && currentNum == target[0]) {
            ops[opIndex++] = strdup("Push");
            // 将目标数组的第一个元素移除，准备处理下一个元素
            memmove(target, target + 1, (targetSize - 1) * sizeof(int));
            targetSize--;
        } else {
            ops[opIndex++] = strdup("Pop");
        }
        // 移动到下一个数字
        currentNum++;
    }
    
    // 设置返回的操作序列大小
    *returnSize = opIndex;
    return ops;
}
#include <stdio.h>
#include <stdbool.h>

// 定义树的节点结构
typedef struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

// 辅助函数，用于构建树
TreeNode* createTreeNode(int val) {
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
    node->val = val;
    node->left = NULL;
    node->right = NULL;
    return node;
}

// 深度优先搜索，计算收集苹果的最少时间
int dfs(TreeNode* node, bool* hasApple, int* time) {
    if (!node) return 0;
    int timeSpent = 0;
    bool hasAppleInSubtree = hasApple[node->val] || dfs(node->left, hasApple, time) || dfs(node->right, hasApple, time);
    if (hasAppleInSubtree) {
        *time += 2; // 来回经过的边
        timeSpent = 2; // 当前节点的花费
    }
    return timeSpent;
}

// 收集所有苹果的最少时间
int minTime(int n, int* edges, int* hasApple) {
    if (n == 0) return 0;
    TreeNode* root = createTreeNode(0);
    // 构建树结构，这里省略了树的构建过程，假设树已经构建完成
    // ...

    int time = 0;
    dfs(root, hasApple, &time);
    return time;
}

int main() {
    int n = 7;
    int edges[] = {0, 1, 0, 2, 1, 4, 1, 5, 2, 3, 2, 6};
    int hasApple[] = {0, 0, 1, 0, 0, 1, 0};
    printf("Minimum time to collect all apples: %d\n", minTime(n, edges, hasApple));
    return 0;
}
#include <string.h>
#include <stdlib.h>

#define MOD 1000000007

int ways(int rows, int cols, char** pizza, int k) {
    // 初始化动态规划数组
    int dp[51][51][11] = {0};
    int appleCount[51][51] = {0};
    
    // 计算初始状态下苹果的数量
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (pizza[i][j] == 'A') {
                appleCount[i][j] = 1;
            }
        }
    }
    
    // 填充dp数组
    for (int c = 0; c < k - 1; c++) {
        memcpy(dp[c + 1], dp[c], sizeof(dp[c]));
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (appleCount[i][j]) {
                    // 进行水平切割
                    for (int x = i; x > 0; x--) {
                        if (appleCount[x - 1][j]) {
                            dp[c + 1][j][c] = (dp[c + 1][j][c] + dp[c][x - 1][j][c]) % MOD;
                        }
                    }
                    // 进行垂直切割
                    for (int y = j; y > 0; y--) {
                        if (appleCount[i][y - 1]) {
                            dp[c + 1][i][c] = (dp[c + 1][i][c] + dp[c][i][y - 1][c]) % MOD;
                        }
                    }
                }
            }
        }
    }
    
    // 计算最终结果
    int result = 0;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            result = (result + dp[k - 1][i][j]) % MOD;
        }
    }
    return result;
}
#include <stdbool.h>

bool canBeEqual(int* target, int targetSize, int* arr, int arrSize) {
    // 如果数组长度不一致，直接返回false
    if (targetSize != arrSize) return false;
    
    // 检查arr是否包含target的所有元素
    for (int i = 0; i < targetSize; i++) {
        if (!contains(arr, arrSize, target[i])) {
            return false;
        }
    }
    
    // 对两个数组进行排序
    int sortedTarget[targetSize], sortedArr[arrSize];
    memcpy(sortedTarget, target, sizeof(int) * targetSize);
    memcpy(sortedArr, arr, sizeof(int) * arrSize);
    sort(sortedTarget, sortedTarget + targetSize);
    sort(sortedArr, sortedArr + arrSize);
    
    // 比较排序后的数组是否相同
    for (int i = 0; i < targetSize; i++) {
        if (sortedTarget[i] != sortedArr[i]) {
            return false;
        }
    }
    
    return true;
}

bool contains(int* arr, int size, int value) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == value) {
            return true;
        }
    }
    return false;
}

void sort(int* arr, int* end) {
    // 简单的冒泡排序实现
    for (int* i = arr; i < end - 1; i++) {
        for (int* j = i + 1; j < end; j++) {
            if (*i > *j) {
                int temp = *i;
                *i = *j;
                *j = temp;
            }
        }
    }
}
#include <stdbool.h>
#include <string.h>

bool hasAllCodes(char *s, int k) {
    if (k > strlen(s) || k == 0) return false;
    bool seen[1 << k] = {false}; // 初始化所有子串为未见
    for (int i = 0; i <= strlen(s) - k; ++i) {
        int code = 0;
        for (int j = i; j < i + k; ++j) {
            code = (code << 1) | (s[j] - '0');
        }
        if (!seen[code]) {
            seen[code] = true;
        }
        if (allSeen(seen, 1 << k)) {
            return true;
        }
    }
    return false;
}

bool allSeen(bool *seen, int size) {
    for (int i = 0; i < size; ++i) {
        if (!seen[i]) {
            return false;
        }
    }
    return true;
}
#include <stdbool.h>
#include <stdlib.h>

// 定义邻接表存储图
typedef struct {
    int *prerequisites;
    int numCourses;
    int *adjList[100]; // 假设课程数量不超过100
} Graph;

// 初始化图
void initGraph(Graph *graph, int numCourses, int *prerequisites, int preSize) {
    graph->numCourses = numCourses;
    graph->prerequisites = prerequisites;
    for (int i = 0; i < numCourses; i++) {
        graph->adjList[i] = malloc(sizeof(int) * preSize);
        graph->adjList[i][0] = preSize; // 存储每个课程的先修课程数量
        for (int j = 0; j < preSize; j++) {
            if (prerequisites[j] == i) {
                graph->adjList[i][++graph->adjList[i][0]] = prerequisites[j + 1];
            }
        }
    }
}

// 深度优先搜索，检查是否从课程start可以到达课程end
bool dfs(Graph *graph, int start, int end, bool *visited) {
    if (start == end) return true;
    visited[start] = true;
    for (int i = 1; i <= graph->adjList[start][0]; i++) {
        int nextCourse = graph->adjList[start][i];
        if (!visited[nextCourse] && dfs(graph, nextCourse, end, visited)) {
            return true;
        }
    }
    return false;
}

// 处理查询
int* checkIfPrerequisite(int numCourses, int *prerequisites, int preSize, int *queries, int querySize, int* returnSize) {
    // 初始化图
    Graph graph;
    initGraph(&graph, numCourses, prerequisites, preSize);

    // 初始化答案数组和访问数组
    bool *visited = malloc(sizeof(bool) * numCourses);
    int *answer = malloc(sizeof(int) * querySize);
    *returnSize = querySize;

    for (int i = 0; i < querySize; i++) {
        visited[queries[2 * i]] = false; // 假设queries是按uj, vj的格式排列的
        answer[i] = dfs(&graph, queries[2 * i], queries[2 * i + 1], visited);
    }

    free(visited);
    return answer;
}
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// 定义结构体以保存单词和其原始索引
typedef struct {
    char *word;
    int index;
} WordWithIndex;

// 比较函数，用于qsort
int compare(const void *a, const void *b) {
    WordWithIndex *word1 = (WordWithIndex *)a;
    WordWithIndex *word2 = (WordWithIndex *)b;
    int len1 = strlen(word1->word);
    int len2 = strlen(word2->word);
    if (len1 == len2) {
        return word1->index - word2->index; // 保留原顺序
    }
    return len1 - len2; // 按长度排序
}

// 重新排列句子中的单词
char *rearrangeWords(char *text) {
    // 将句子分割成单词并存储
    WordWithIndex words[100]; // 假设句子最多有100个单词
    int count = 0;
    char *temp = strdup(text); // 使用strdup来复制文本，以便我们可以使用strtok
    char *word = strtok(temp, " ");
    while (word != NULL) {
        words[count].word = word;
        words[count].index = count;
        count++;
        word = strtok(NULL, " ");
    }

    // 使用qsort对单词进行排序
    qsort(words, count, sizeof(WordWithIndex), compare);

    // 构造新的句子
    int textLength = strlen(text);
    char *newText = (char *)malloc(textLength + 1);
    newText[0] = '\0'; // 初始化为空字符串

    // 添加第一个单词并大写首字母
    strcpy(newText, words[0].word);
    newText[strlen(words[0].word)] = ' '; // 添加空格

    // 添加剩余的单词
    for (int i = 1; i < count; i++) {
        strcat(newText, words[i].word);
        if (i < count - 1) {
            newText[strlen(newText)] = ' '; // 添加空格
        }
    }

    // 返回新的句子
    free(temp);
    return newText;
}

int main() {
    char text[] = "Leetcode is cool";
    char *sortedText = rearrangeWords(text);
    printf("%s\n", sortedText);
    free(sortedText);
    return 0;
}
#include <stdbool.h>
#include <string.h>

int* peopleIndexes(int** favoriteCompanies, int favoriteCompaniesSize, int* favoriteCompaniesLens, int* returnSize) {
    int* result = malloc(sizeof(int) * favoriteCompaniesSize);
    *returnSize = 0;
    bool isSubset[favoriteCompaniesSize] = {false};

    // 检查每个公司清单是否为其他清单的子集
    for (int i = 0; i < favoriteCompaniesSize; ++i) {
        for (int j = 0; j < favoriteCompaniesSize; ++j) {
            if (i != j && isSubset(j, favoriteCompanies[i], favoriteCompaniesLens[i], favoriteCompanies[j], favoriteCompaniesLens[j])) {
                isSubset[i] = true;
                break;
            }
        }
    }

    // 收集不是子集的索引
    for (int i = 0; i < favoriteCompaniesSize; ++i) {
        if (!isSubset[i]) {
            result[(*returnSize)++] = i;
        }
    }

    return result;
}

bool isSubset(int index, int* list1, int len1, int* list2, int len2) {
    int count = 0;
    for (int i = 0; i < len1; ++i) {
        for (int j = 0; j < len2; ++j) {
            if (list1[i] == list2[j]) {
                ++count;
                break;
            }
        }
    }
    return count == len1;
}
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int numPoints(int **points, int pointsSize, int *pointsColSize, int r) {
    int count = 0;
    int maxCount = 0;
    for (int i = 0; i < pointsSize; ++i) {
        count = 0;
        for (int j = 0; j < pointsSize; ++j) {
            if (pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2) <= pow(r, 2)) {
                count++;
            }
        }
        maxCount = count > maxCount ? count : maxCount;
    }
    return maxCount;
}
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// 函数用于检查searchWord是否是sentence中某个单词的前缀
int isPrefixOfWord(char* sentence, char* searchWord) {
    int index = 0; // 用于记录匹配单词的索引
    char* word; // 用于分割sentence中的单词
    char* token = strtok(sentence, " "); // 使用strtok分割sentence，以空格为分隔符

    while (token != NULL) {
        if (strncmp(token, searchWord, strlen(searchWord)) == 0) {
            // 如果当前单词以searchWord开头，则返回当前索引+1（因为题目要求从1开始计数）
            return index + 1;
        }
        token = strtok(NULL, " "); // 继续获取下一个单词
        index++; // 索引递增
    }

    return -1; // 如果没有找到匹配的前缀，返回-1
}

int main() {
    char sentence[] = "i love eating burger";
    char searchWord[] = "burg";
    int result = isPrefixOfWord(sentence, searchWord);
    printf("The index is: %d\n", result); // 应该输出4
    return 0;
}
#include <string.h>
#include <stdio.h>

int maxVowels(char *s, int k) {
    int maxCount = 0;
    int count = 0; // 当前窗口中元音字母的个数
    char vowels[] = "aeiou"; // 元音字母集合

    // 初始化窗口中的第一个k个字符的元音数量
    for (int i = 0; i < k; ++i) {
        if (strchr(vowels, s[i]) != NULL) {
            count++;
        }
    }
    maxCount = count;

    // 滑动窗口，每次向右移动一位
    for (int i = k; i < strlen(s); ++i) {
        // 如果当前字符是元音，增加计数
        if (strchr(vowels, s[i]) != NULL) {
            count++;
        }
        // 如果离开窗口的字符是元音，减少计数
        if (strchr(vowels, s[i - k]) != NULL) {
            count--;
        }
        // 更新最大元音数
        maxCount = (count > maxCount) ? count : maxCount;
    }

    return maxCount;
}

int main() {
    char s[] = "abciiidef";
    int k = 3;
    printf("Maximum number of vowels in a substring of length %d is %d\n", k, maxVowels(s, k));
    return 0;
}
#include <stdbool.h>
#include <stdio.h>

typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

bool isPseudoPalindromic(int* path, int pathSize) {
    int oddCount = 0;
    for (int i = 0; i < pathSize; ++i) {
        int num = path[i];
        for (int j = i + 1; j < pathSize; ++j) {
            if (path[i] == path[j]) {
                path[j] = 0;
                break;
            }
        }
        if (num && path[i]) {
            oddCount++;
            if (oddCount > 1) return false;
        }
    }
    return true;
}

int pseudoPalindromicPaths (TreeNode* root) {
    if (!root) return 0;
    int count = 0;
    int path[1000]; // 假设路径不会超过1000
    dfs(root, &count, path, 0);
    return count;
}

void dfs(TreeNode* node, int* count, int path[], int pathSize) {
    if (!node) return;
    path[pathSize] = node->val;
    if (!node->left && !node->right) {
        if (isPseudoPalindromic(path, pathSize + 1)) {
            (*count)++;
        }
    } else {
        dfs(node->left, count, path, pathSize + 1);
        dfs(node->right, count, path, pathSize + 1);
    }
}

// 测试代码
int main() {
    TreeNode root[5];
    root[0].val = 2;
    root[1].val = 3;
    root[2].val = 1;
    root[3].val = 3;
    root[4].val = 1;
    root[0].left = &root[1];
    root[0].right = &root[2];
    root[1].left = &root[3];
    root[1].right = &root[4];
    printf("Pseudo-palindromic paths: %d\n", pseudoPalindromicPaths(&root[0]));
    return 0;
}
#include <limits.h>

int maxDotProduct(int* nums1, int nums1Size, int* nums2, int nums2Size) {
    int dp[nums1Size][nums2Size];
    int i, j;
    
    // 初始化第一行和第一列
    for (i = 0; i < nums1Size; i++) {
        dp[i][0] = nums1[i] * nums2[0];
    }
    for (j = 0; j < nums2Size; j++) {
        dp[0][j] = nums1[0] * nums2[j];
    }
    
    // 动态规划填表
    for (i = 1; i < nums1Size; i++) {
        for (j = 1; j < nums2Size; j++) {
            dp[i][j] = INT_MIN;
            dp[i][j] = max(dp[i][j], dp[i-1][j]);
            dp[i][j] = max(dp[i][j], dp[i][j-1]);
            dp[i][j] = max(dp[i][j], dp[i-1][j-1] + nums1[i] * nums2[j]);
        }
    }
    
    // 寻找最大值
    int maxProduct = INT_MIN;
    for (i = 0; i < nums1Size; i++) {
        maxProduct = max(maxProduct, dp[i][nums2Size - 1]);
    }
    
    return maxProduct;
}

int main() {
    int nums1[] = {2, 1, -2, 5};
    int nums2[] = {3, 0, -6};
    printf("%d\n", maxDotProduct(nums1, sizeof(nums1)/sizeof(nums1[0]), nums2, sizeof(nums2)/sizeof(nums2[0])));
    return 0;
}
```

### 算法复杂度
- 时间复杂度：O(n*m)，其中n和m分别是`nums1`和`nums2`的长度。
- 空间复杂度：O(n*m)，用于存储动态规划表。

这个问题主要考察了动态规划的应用，通过定义合适的状态和状态转移方程来解决问题。希望这个解答和讲解对您有所帮助。如果您有任何疑问或需要进一步的讨论，请随时告诉我。['/home/tong/bin/new_2.py', '-f', './finished.txt']
您好！作为一名LeetCode讲师，我将为您提供针对LeetCode问题的详细解答和解题思路。现在，让我们来分析您提出的问题：

## 问题描述
给定一棵二叉树，每个节点的值为1到9。我们称二叉树中的一条路径为“伪回文”的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。您的任务是返回从根到叶子节点的所有路径中伪回文路径的数目。

## 示例
1. 输入：root = [2,3,1,3,1,null,1] 输出：2
   解释：有3条从根到叶子的路径：[2,3,3]，[2,1,1]和[2,3,1]。其中[2,3,3]和[2,1,1]是伪回文路径。

2. 输入：root = [2,1,1,1,3,null,null,null,null,null,1] 输出：1
   解释：有3条从根到叶子的路径，只有[2,1,1]是伪回文路径。

3. 输入：root = [9] 输出：1

## 提示
- 给定二叉树的节点数目在范围 [1, 10^5] 内
- 1 <= Node.val <= 9

## 解题思路
这个问题可以通过深度优先搜索（DFS）解决。我们从根节点开始遍历二叉树的每条路径，并检查路径上的值是否能够形成伪回文序列。

### 算法步骤
1. 定义一个辅助函数`isPseudoPalindromic`，该函数接收当前路径上的值，并检查是否存在至多一个数出现奇数次。
2. 定义一个递归函数`dfs`，用于遍历二叉树的每条路径，并使用辅助函数检查路径是否为伪回文。
3. 在`dfs`函数中，对于每个节点，将其值添加到当前路径上，然后递归遍历其左右子节点。
4. 如果到达叶子节点，使用`isPseudoPalindromic`检查当前路径。
5. 统计并返回所有伪回文路径的数目。

## C语言实现
```c
#include <stdbool.h>
#include <stdio.h>

typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

bool isPseudoPalindromic(int* path, int pathSize) {
    int oddCount = 0;
    for (int i = 0; i < pathSize; ++i) {
        int num = path[i];
        for (int j = i + 1; j < pathSize; ++j) {
            if (path[i] == path[j]) {
                path[j] = 0;
                break;
            }
        }
        if (num && path[i]) {
            oddCount++;
            if (oddCount > 1) return false;
        }
    }
    return true;
}

int pseudoPalindromicPaths (TreeNode* root) {
    if (!root) return 0;
    int count = 0;
    int path[1000]; // 假设路径不会超过1000
    dfs(root, &count, path, 0);
    return count;
}

void dfs(TreeNode* node, int* count, int path[], int pathSize) {
    if (!node) return;
    path[pathSize] = node->val;
    if (!node->left && !node->right) {
        if (isPseudoPalindromic(path, pathSize + 1)) {
            (*count)++;
        }
    } else {
        dfs(node->left, count, path, pathSize + 1);
        dfs(node->right, count, path, pathSize + 1);
    }
}

// 测试代码
int main() {
    TreeNode root[5];
    root[0].val = 2;
    root[1].val = 3;
    root[2].val = 1;
    root[3].val = 3;
    root[4].val = 1;
    root[0].left = &root[1];
    root[0].right = &root[2];
    root[1].left = &root[3];
    root[1].right = &root[4];
    printf("Pseudo-palindromic paths: %d\n", pseudoPalindromicPaths(&root[0]));
    return 0;
}
#include <stdio.h>

int* finalPrices(int* prices, int pricesSize, int* returnSize) {
    int* finalPrice = (int*)malloc(pricesSize * sizeof(int));
    *returnSize = pricesSize;
    for (int i = 0; i < pricesSize; ++i) {
        finalPrice[i] = prices[i];
        for (int j = i + 1; j < pricesSize; ++j) {
            if (prices[j] <= prices[i]) {
                finalPrice[i] -= prices[j];
                break;
            }
        }
    }
    return finalPrice;
}

int main() {
    int prices[] = {8, 4, 6, 2, 3};
    int returnSize;
    int* result = finalPrices(prices, sizeof(prices)/sizeof(prices[0]), &returnSize);
    
    for (int i = 0; i < returnSize; ++i) {
        printf("%d ", result[i]);
    }
    printf("\n");
    
    free(result);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int minDistance(int houses[], int housesSize, int k) {
    // 对房屋位置进行排序
    int i;
    for (i = 0; i < housesSize - 1; i++) {
        for (int j = 0; j < housesSize - i - 1; j++) {
            if (houses[j] > houses[j + 1]) {
                int temp = houses[j];
                houses[j] = houses[j + 1];
                houses[j + 1] = temp;
            }
        }
    }
    
    // 初始化邮筒数量数组
    int dp[housesSize + 1];
    int maxDistance = 0;
    for (i = 0; i < housesSize; i++) {
        maxDistance = (maxDistance > houses[i] ? maxDistance : houses[i]);
        dp[i] = maxDistance; // 初始情况下，每个房子都需要一个邮筒
    }
    dp[0] = 0;

    // 动态规划求解
    for (int m = 1; m < k; m++) {
        for (i = m; i < housesSize; i++) {
            int minDist = INT_MAX;
            for (int j = i - 1; j >= m - 1; j--) {
                minDist = (minDist < (houses[i] - houses[j]) ? minDist : (houses[i] - houses[j]));
            }
            dp[i] = (dp[i] < dp[i - 1] + minDist ? dp[i] : dp[i - 1] + minDist);
        }
    }

    // 返回最小总距离
    return dp[housesSize - 1];
}

int main() {
    int houses[] = {1, 4, 8, 10, 20};
    int k = 3;
    printf("Minimum total distance is %d\n", minDistance(houses, sizeof(houses) / sizeof(houses[0]), k));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int row1, col1, row2, col2, newValue;
} Update;

typedef struct {
    int **data;
    int rows, cols;
    Update *updates;
    int updatesSize;
} SubrectangleQueries;

SubrectangleQueries* subrectangleQueriesCreate(int** rectangle, int rows, int cols) {
    SubrectangleQueries* obj = (SubrectangleQueries*)malloc(sizeof(SubrectangleQueries));
    obj->rows = rows;
    obj->cols = cols;
    obj->updates = (Update*)malloc(sizeof(Update) * 500); // 假设最多500次更新
    obj->updatesSize = 0;
    
    obj->data = (int**)malloc(sizeof(int*) * rows);
    for (int i = 0; i < rows; i++) {
        obj->data[i] = (int*)malloc(sizeof(int) * cols);
        for (int j = 0; j < cols; j++) {
            obj->data[i][j] = rectangle[i][j];
        }
    }
    
    return obj;
}

void subrectangleQueriesUpdate(SubrectangleQueries* obj, int row1, int col1, int row2, int col2, int newValue) {
    Update update;
    update.row1 = row1;
    update.col1 = col1;
    update.row2 = row2;
    update.col2 = col2;
    update.newValue = newValue;
    obj->updates[obj->updatesSize++] = update;
}

int subrectangleQueriesGetValue(SubrectangleQueries* obj, int row, int col) {
    int value = obj->data[row][col];
    for (int i = obj->updatesSize - 1; i >= 0; i--) {
        Update update = obj->updates[i];
        if (row >= update.row1 && row <= update.row2 && col >= update.col1 && col <= update.col2) {
            value = update.newValue;
            break;
        }
    }
    return value;
}

void subrectangleQueriesFree(SubrectangleQueries* obj) {
    for (int i = 0; i < obj->rows; i++) {
        free(obj->data[i]);
    }
    free(obj->data);
    free(obj->updates);
    free(obj);
}

// 示例使用
int main() {
    int rectangle[4][3] = {{1,2,1},{4,3,4},{3,2,1},{1,1,1}};
    int** rectPtr = (int**)malloc(sizeof(int*) * 4);
    for (int i = 0; i < 4; i++) {
        rectPtr[i] = rectangle[i];
    }
    
    SubrectangleQueries* obj = subrectangleQueriesCreate(rectPtr, 4, 3);
    subrectangleQueriesUpdate(obj, 0, 0, 3, 2, 5);
    printf("Value at (0, 2): %d\n", subrectangleQueriesGetValue(obj, 0, 2)); // 输出 5
    subrectangleQueriesFree(obj);
    
    return 0;
}
int minSumOfLengths(int* arr, int arrSize, int target) {
    int prefix[arrSize + 1] = {0};
    int suffix[arrSize + 1] = {INT_MAX};
    int sum = 0, ans = INT_MAX;
    
    // 计算prefix数组
    for (int i = 0; i < arrSize; ++i) {
        sum += arr[i];
        prefix[i + 1] = sum >= target ? i + 1 : prefix[i];
    }
    
    sum = 0; // 重置求和变量
    // 计算suffix数组
    for (int i = arrSize - 1; i >= 0; --i) {
        sum += arr[i];
        suffix[i] = sum >= target ? arrSize - i : suffix[i + 1];
    }
    
    // 寻找最小长度和
    for (int i = 0; i < arrSize; ++i) {
        ans = min(ans, prefix[i] + suffix[i + 1]);
    }
    
    return ans == INT_MAX ? -1 : ans;
}
double getProbability(int balls[], int ballsSize) {
    int n = ballsSize;
    double totalWays = pow(2, n);
    double sameCountWays = 0;
    int sum = 0;
    
    // 计算总的分配方式
    for (int i = 0; i < n; ++i) {
        sum += balls[i];
    }
    
    // 初始化dp数组
    double dp[n + 1][n + 1];
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j <= n; ++j) {
            dp[i][j] = 0;
        }
    }
    
    // 特殊情况处理
    dp[0][0] = 1;
    
    // 动态规划填表
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= n; ++j) {
            for (int k = 0; k <= i && k <= j; ++k) {
                if (i == k || balls[i - 1] > 1) {
                    dp[i][j] += dp[i - 1][j - k] * (balls[i - 1] - k + 1) / totalWays;
                }
            }
        }
    }
    
    // 计算结果
    for (int i = 0; i <= n / 2; ++i) {
        sameCountWays += dp[n][i] * dp[n][i];
    }
    
    return sameCountWays / pow(2, sum);
}
#include <stdio.h>

void shuffleTheArray(int* nums, int numsSize, int n) {
    int i = 0, j = n;
    while (i < j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
        i++;
        j++;
    }
}

int main() {
    int nums[] = {2, 5, 1, 3, 4, 7};
    int n = 3;
    shuffleTheArray(nums, sizeof(nums)/sizeof(nums[0]), n);
    for (int i = 0; i < sizeof(nums)/sizeof(nums[0]); i++) {
        printf("%d ", nums[i]);
    }
    return 0;
}
#include <stdio.h>

double averageSalary(int salary[], int length) {
    // 对数组进行排序
    for (int i = 0; i < length - 1; i++) {
        for (int j = 0; j < length - i - 1; j++) {
            if (salary[j] > salary[j + 1]) {
                int temp = salary[j];
                salary[j] = salary[j + 1];
                salary[j + 1] = temp;
            }
        }
    }
    
    // 计算除去最小和最大值后的总和
    int sum = 0;
    for (int i = 1; i < length - 1; i++) {
        sum += salary[i];
    }
    
    // 计算平均值
    return (double)sum / (length - 2);
}

int main() {
    int salary[] = {4000, 3000, 1000, 2000};
    int length = sizeof(salary) / sizeof(salary[0]);
    printf("The average salary excluding the minimum and maximum is: %.5f\n", averageSalary(salary, length));
    return 0;
}
#include <stdio.h>

// 函数用于找出删除一个元素后的最长全1子数组
int longestSubarray(int* nums, int numsSize) {
    int maxLength = 0, countOnes = 0, start = 0;
    for (int end = 0; end < numsSize; end++) {
        if (nums[end] == 1) {
            countOnes++;
        } else {
            // 如果当前元素不是1，需要调整窗口
            // 移动start指针到当前0的左侧，直到窗口内再次只有1
            while (start < end && nums[start] == 1) {
                countOnes--;
                start++;
            }
            // 如果窗口内没有0，则移动start到当前0的位置
            if (start <= end) {
                start++;
            }
        }
        // 更新最大长度
        maxLength = (countOnes > 0) ? (end - start + 1) : maxLength;
    }
    return maxLength;
}

int main() {
    int nums[] = {1, 1, 0, 1}; // 示例数组
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    printf("最长全1子数组的长度是: %d\n", longestSubarray(nums, numsSize));
    return 0;
}
#include <stdio.h>

// 定义课程的结构体，包含课程编号和先修课程的数量
typedef struct Course {
    int id;
    int degree; // 先修课程的数量
} Course;

// 拓扑排序函数
int findOrder(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize, int k) {
    // 初始化所有课程的先修课程数量
    Course courses[numCourses];
    for (int i = 0; i < numCourses; i++) {
        courses[i].id = i;
        courses[i].degree = 0;
    }
    
    // 构建图，并计算每个课程的入度
    for (int i = 0; i < prerequisitesSize; i++) {
        int next = prerequisites[i][1] - 1; // 转换为从0开始的索引
        courses[next].degree++; // 增加先修课程的入度
    }
    
    // 用队列存储入度为0的课程
    int queue[numCourses], front = 0, rear = 0;
    for (int i = 0; i < numCourses; i++) {
        if (courses[i].degree == 0) {
            queue[rear++] = i;
        }
    }
    
    // 拓扑排序结果数组
    int result = 0;
    while (front < rear) {
        int size = rear - front; // 当前学期可以上的课程数量
        if (size == 0) return -1; // 如果没有课程可以上，说明有环存在
        result++; // 学期数增加
        for (int i = 0; i < size; i++) {
            int current = queue[front++]; // 取出一个课程
            for (int j = 0; j < prerequisitesSize; j++) {
                if (prerequisites[j][0] - 1 == current) { // 如果当前课程是先修课
                    int next = prerequisites[j][1] - 1; // 目标课程
                    courses[next].degree--; // 减少目标课程的入度
                    if (courses[next].degree == 0) {
                        queue[rear++] = next; // 如果入度为0，则加入队列
                    }
                }
            }
        }
    }
    
    // 如果所有课程都被安排了，返回学期数，否则返回-1
    return result;
}

int main() {
    int n = 4;
    int k = 2;
    int relations[][2] = {{2,1}, {3,1}, {1,4}};
    int relationsSize = sizeof(relations) / sizeof(relations[0]);
    printf("Minimum number of semesters: %d\n", findOrder(n, (int**)&relations, relationsSize, k));
    return 0;
}
#include <stdio.h>

// 计算一维数组的动态和
int* runningSum(int* nums, int numsSize, int* returnSize) {
    // 分配结果数组，其大小与输入数组相同
    int* result = (int*)malloc(sizeof(int) * numsSize);
    if (!result) return NULL;
    
    // 初始化结果数组的第一个元素为输入数组的第一个元素
    result[0] = nums[0];
    *returnSize = numsSize;
    
    // 计算动态和
    for (int i = 1; i < numsSize; i++) {
        result[i] = result[i - 1] + nums[i];
    }
    
    return result;
}

int main() {
    int nums[] = {1, 2, 3, 4};
    int returnSize;
    int* res = runningSum(nums, sizeof(nums) / sizeof(nums[0]), &returnSize);
    
    // 打印结果
    for (int i = 0; i < returnSize; i++) {
        printf("%d ", res[i]);
    }
    
    // 释放分配的内存
    free(res);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int leastNumberOfUniqueInts(int* arr, int arrSize, int k) {
    // 哈希表存储每个数字出现的次数
    int* count = (int*)calloc(1000001, sizeof(int)); // 假设数组元素不会超过1000000
    for (int i = 0; i < arrSize; ++i) {
        count[arr[i]]++;
    }

    // 排序出现次数的数组
    int* sortedCounts = (int*)malloc(sizeof(int) * 1000001);
    for (int i = 0; i < 1000001; ++i) {
        if (count[i] > 0) {
            sortedCounts[--num] = count[i];
        }
    }

    // 贪心算法，移除出现次数最少的数字
    int removeCount = 0;
    for (int i = 0; i < num; ++i) {
        if (k >= sortedCounts[i]) {
            k -= sortedCounts[i];
            removeCount += sortedCounts[i];
        } else {
            // 如果剩余的k不足以移除当前最小出现次数的所有数字
            removeCount += k;
            break;
        }
    }

    // 计算不同整数的最少数目
    int uniqueInts = 1000001 - num + (k > 0); // 如果k还有剩余，说明还能移除一些重复的数字
    free(count);
    free(sortedCounts);
    return uniqueInts;
}

int main() {
    int arr[] = {4,3,1,1,3,3,2};
    int k = 3;
    printf("The least number of unique integers is: %d\n", leastNumberOfUniqueInts(arr, sizeof(arr)/sizeof(arr[0]), k));
    return 0;
}
#include <limits.h>

int minDays(int* bloomDay, int bloomDaySize, int m, int k) {
    int left = 1, right = INT_MAX;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (canMakeBouquets(bloomDay, bloomDaySize, m, k, mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}

int canMakeBouquets(int* bloomDay, int bloomDaySize, int m, int k, int day) {
    int bouquets = 0, flowers = 0;
    for (int i = 0; i < bloomDaySize; ++i) {
        if (bloomDay[i] <= day) {
            flowers++;
            if (flowers == k) {
                bouquets++;
                flowers = 0;
            }
        } else {
            flowers = 0;
        }
    }
    return bouquets >= m;
}
#include <stdio.h>
#include <stdlib.h>

int countRectangles(int* points, int pointsSize, int target) {
    int count = 0;
    // 用于存储横纵坐标出现的次数
    int x[101] = {0}, y[101] = {0};
    
    // 统计横纵坐标出现的次数
    for (int i = 0; i < pointsSize; i += 3) {
        x[points[i]]++;
        y[points[i + 1]]++;
    }
    
    // 使用嵌套循环遍历所有可能的矩形组合
    for (int i = 0; i < 100; ++i) {
        for (int j = 0; j < 100; ++j) {
            if (x[i] > 0 && y[j] > 0 && (i > j)) {
                int area = i * j;
                if (area % target == 0 && area / target <= x[i] * y[j]) {
                    count += (x[i] * y[j]) / (i * j / target);
                }
            }
        }
    }
    
    return count;
}

int main() {
    int points[] = {1, 1, 3, 3, 1, 2};
    int target = 6;
    printf("Total rectangles: %d\n", countRectangles(points, sizeof(points) / sizeof(points[0]), target));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 假设我们使用一个结构体来表示员工的工资信息
typedef struct {
    int company_id;
    int employee_id;
    char employee_name[15];
    int salary;
} SalaryInfo;

// 这个函数用来计算税后工资
void calculateAfterTaxSalaries(SalaryInfo* salaries, int size) {
    // 根据题目要求，税后工资的计算方式是：超过4000元的部分需要缴纳超过部分的20%
    for (int i = 0; i < size; ++i) {
        if (salaries[i].salary > 4000) {
            salaries[i].salary = 4000 + (salaries[i].salary - 4000) * 0.8;
        }
    }
}

int main() {
    // 假设我们已经有了一个员工工资数组
    SalaryInfo salaries[] = {
        {1, 1, "Tony", 5000},
        {1, 2, "Pronub", 21300},
        // ... 更多员工信息
    };
    int size = sizeof(salaries) / sizeof(salaries[0]);

    calculateAfterTaxSalaries(salaries, size);

    // 输出税后工资
    for (int i = 0; i < size; ++i) {
        printf("Employee ID: %d, Name: %s, After-Tax Salary: %d\n",
               salaries[i].employee_id, salaries[i].employee_name, salaries[i].salary);
    }

    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 定义结构体用于存储文件夹名和对应的后缀
typedef struct {
    char *name;
    int suffix;
} Folder;

// 函数用于添加文件夹名，返回实际分配的文件夹名
char* getFolderNames(char **names, int namesSize) {
    // 创建一个数组来存储所有文件夹的信息
    Folder folders[namesSize];
    // 创建一个数组来存储结果
    char *result[namesSize];
    // 存储已使用的名字集合
    char *usedNames[namesSize];

    // 初始化
    for (int i = 0; i < namesSize; i++) {
        folders[i].name = names[i];
        folders[i].suffix = 0;
        usedNames[i] = NULL;
    }

    // 排序names数组，使得相同名字的文件夹相邻
    qsort(names, namesSize, sizeof(char*), (int (*)(const void *, const void *))strcmp);

    // 遍历names数组
    for (int i = 0; i < namesSize; i++) {
        // 检查当前文件夹名是否已经被使用
        int index = findUsedIndex(usedNames, namesSize, names[i]);
        if (index == -1) {
            // 如果没有被使用，添加到usedNames中
            usedNames[index] = names[i];
            result[i] = strdup(names[i]); // 复制名字到结果数组
        } else {
            // 如果已经被使用，找到下一个可用的后缀
            for (int k = 1;; k++) {
                char newName[21]; // 假设后缀数字不会超过20
                sprintf(newName, "%s(%d)", names[i], k);
                if (findUsedIndex(usedNames, namesSize, newName) == -1) {
                    usedNames[index] = strdup(newName); // 更新usedNames数组
                    result[i] = strdup(newName); // 复制新名字到结果数组
                    folders[index].suffix = k; // 更新后缀
                    break;
                }
            }
        }
    }

    return result;
}

// 辅助函数，用于在usedNames中查找已使用的名字
int findUsedIndex(char **usedNames, int size, char *name) {
    for (int i = 0; i < size; i++) {
        if (usedNames[i] != NULL && strcmp(usedNames[i], name) == 0) {
            return i;
        }
    }
    return -1;
}

// 示例使用
int main() {
    char *names[] = {"kaido", "kaido(1)", "kaido", "kaido(1)"};
    int namesSize = sizeof(names) / sizeof(names[0]);
    char *result = getFolderNames(names, namesSize);
    
    // 打印结果
    for (int i = 0; i < namesSize; i++) {
        printf("%s\n", result[i]);
        free(result[i]); // 释放结果字符串
    }
    free(result); // 释放结果数组

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int minDifference(int* nums, int numsSize) {
    // 对数组进行排序
    qsort(nums, numsSize, sizeof(int), compare);
    
    // 贪心策略，选择最小的差值
    int minDiff = nums[numsSize - 1] - nums[0];
    for (int i = 0; i < numsSize - 2; i++) {
        minDiff = fmin(minDiff, nums[i + 2] - nums[0]);
    }
    return minDiff;
}

// 用于qsort的比较函数
int compare(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

int main() {
    int nums[] = {5, 3, 2, 4};
    int size = sizeof(nums) / sizeof(nums[0]);
    printf("%d\n", minDifference(nums, size));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 定义一个结构体用于存储关键信息
typedef struct {
    int first; // 第一个数的索引
    int second; // 第二个数的索引
} TwoSumResult;

TwoSumResult twoSum(int* nums, int numsSize, int target) {
    TwoSumResult result;
    // 定义哈希表，使用数组模拟
    int hashTable[101] = {0}; // 假设数组元素不会超过100
    int i;

    // 遍历数组
    for (i = 0; i < numsSize; i++) {
        int complement = target - nums[i]; // 计算补数
        if (hashTable[complement] != -1) { // 如果补数在哈希表中
            result.first = hashTable[complement];
            result.second = i;
            return result; // 返回结果
        } else {
            hashTable[nums[i]] = i; // 否则，将当前元素的索引存入哈希表
        }
    }

    // 如果没有找到，返回-1表示失败
    result.first = -1;
    result.second = -1;
    return result;
}

int main() {
    int nums[] = {2, 7, 11, 15};
    int target = 9;
    TwoSumResult result = twoSum(nums, sizeof(nums) / sizeof(nums[0]), target);
    if (result.first != -1 && result.second != -1) {
        printf("Index 1: %d, Index 2: %d\n", result.first, result.second);
    } else {
        printf("No two sum solution found.\n");
    }
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 定义一个结构体用于存储关键信息
typedef struct {
    int first; // 第一个数的索引
    int second; // 第二个数的索引
} TwoSumResult;

TwoSumResult twoSum(int* nums, int numsSize, int target) {
    TwoSumResult result;
    // 定义哈希表，使用数组模拟
    int hashTable[101] = {0}; // 假设数组元素不会超过100
    int i;

    // 遍历数组
    for (i = 0; i < numsSize; i++) {
        int complement = target - nums[i]; // 计算补数
        if (hashTable[complement] != -1) { // 如果补数在哈希表中
            result.first = hashTable[complement];
            result.second = i;
            return result; // 返回结果
        } else {
            hashTable[nums[i]] = i; // 否则，将当前元素的索引存入哈希表
        }
    }

    // 如果没有找到，返回-1表示失败
    result.first = -1;
    result.second = -1;
    return result;
}

int main() {
    int nums[] = {2, 7, 11, 15};
    int target = 9;
    TwoSumResult result = twoSum(nums, sizeof(nums) / sizeof(nums[0]), target);
    if (result.first != -1 && result.second != -1) {
        printf("Index 1: %d, Index 2: %d\n", result.first, result.second);
    } else {
        printf("No two sum solution found.\n");
    }
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 定义点的结构体
typedef struct {
    int y;
    int x;
} Point;

// 比较函数，用于qsort
int cmp(const void *a, const void *b) {
    Point *pa = (Point *)a;
    Point *pb = (Point *)b;
    return (pa->y - pa->x) - (pb->y - pb->x);
}

// 找出最大值的函数
int findMaxValueOfEquation(int **points, int pointsSize, int k) {
    int max_value = -20000000000; // 初始化最大值为一个较小的数
    Point heap[pointsSize]; // 存储转换后的点
    for (int i = 0; i < pointsSize; ++i) {
        heap[i].y = points[i][1];
        heap[i].x = points[i][0];
    }
    qsort(heap, pointsSize, sizeof(Point), cmp); // 对点进行排序

    for (int i = 0, j = 0; i < pointsSize; ++i) {
        while (j < i && (points[i][0] - points[j][0]) > k) {
            // 维护单调性，移除不满足条件的点
            j++;
        }
        if (j < i) {
            max_value = max_value > heap[i].y + heap[j].y + (points[i][0] - points[j][0]) ? max_value : heap[i].y + heap[j].y + (points[i][0] - points[j][0]);
        }
    }
    return max_value;
}

int main() {
    // 示例测试
    int points1[2][2] = {{1, 3}, {2, 0}};
    int points2[3][2] = {{5, 10}, {6, -10}, {0, 0}};
    int k1 = 1, k2 = 3;
    printf("Max value of equation for the first example is: %d\n", findMaxValueOfEquation(points1, 2, k1));
    printf("Max value of equation for the second example is: %d\n", findMaxValueOfEquation(points2, 3, k2));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 假设我们有一个结构体来表示Activities表的一行
typedef struct {
    char sell_date[11];
    char product[21];
} Activity;

// 这个函数用于比较两个活动日期，用于qsort
int compareActivities(const void *a, const void *b) {
    Activity *activityA = (Activity *)a;
    Activity *activityB = (Activity *)b;
    return strcmp(activityA->sell_date, activityB->sell_date);
}

// 这个函数用于输出每个日期销售的产品
void printProductsPerDate(Activity *activities, int size) {
    if (size == 0) return;

    // 首先按日期对活动进行排序
    qsort(activities, size, sizeof(Activity), compareActivities);

    // 使用一个简单的哈希表（这里用数组模拟）来存储每个日期的产品集合
    int productCounts[100] = {0}; // 假设产品数不超过100种
    char products[100][21] = {{'\0'}}; // 存储产品名称
    int productIndex = 0;

    // 遍历活动并填充产品信息
    for (int i = 0; i < size; i++) {
        Activity current = activities[i];
        int found = 0;

        // 检查当前产品是否已经记录
        for (int j = 0; j < productIndex; j++) {
            if (strcmp(products[j], current.product) == 0) {
                found = 1;
                break;
            }
        }

        // 如果没有记录，则添加到产品集合
        if (!found) {
            strcpy(products[productIndex], current.product);
            productIndex++;
        }

        // 打印当前日期的所有产品
        printf("%s: ", current.sell_date);
        for (int j = 0; j < productIndex; j++) {
            printf("%s, ", products[j]);
        }
        printf("\n");
    }
}

int main() {
    // 假设这是从数据库获取的数据
    Activity activities[] = {
        {"2020-05-30", "Headphone"},
        {"2020-06-01", "Pencil"},
        // ... 更多活动
    };
    int size = sizeof(activities) / sizeof(activities[0]);

    printProductsPerDate(activities, size);

    return 0;
}
#include <stdio.h>
#include <string.h>

void swap(char *a, char *b) {
    char temp = *a;
    *a = *b;
    *b = temp;
}

char* minInteger(char* num, int k) {
    int n = strlen(num);
    int count[10] = {0}; // 记录每个数字出现的次数
    for (int i = 0; i < n; i++) {
        count[num[i] - '0']++; // 统计每个数字出现的次数
    }

    int maxSwaps = 0; // 记录实际需要交换的次数
    for (int i = 0; i < n; i++) {
        int minIdx = i;
        for (int j = i + 1; j < n; j++) {
            if (num[j] < num[minIdx]) {
                minIdx = j;
            }
        }
        if (minIdx != i) {
            // 如果当前位不是最小的数字，则需要交换
            swap(&num[i], &num[minIdx]);
            maxSwaps++;
            if (maxSwaps > k) {
                // 如果剩余的交换次数不足以将所有更小的数字交换到前面，则停止
                for (int j = 0; j < n; j++) {
                    count[num[j] - '0']--;
                }
                break;
            }
        }
        // 更新交换后的数字计数
        count[num[i] - '0']--;
    }

    return num;
}

int main() {
    char num[] = "4321";
    int k = 4;
    printf("Minimum integer after at most %d swaps: %s\n", k, minInteger(num, k));
    return 0;
}
#include <string.h>
#include <stdio.h>

int numSplits(char *s) {
    int len = strlen(s);
    int count = 0, res = 0;
    int leftUnique[len + 1], rightUnique[len + 1];

    // 初始化数组，统计每个位置前不同字符的数量
    memset(leftUnique, 0, sizeof(leftUnique));
    for (int i = 0; i < len; ++i) {
        leftUnique[i + 1] = leftUnique[i] + (s[i] == 'a' ? 1 : 0);
    }
    for (int i = len - 1; i >= 0; --i) {
        rightUnique[i] = rightUnique[i + 1] + (s[i] == 'a' ? 1 : 0);
    }

    // 遍历所有可能的分割点，检查是否为好分割
    for (int i = 1; i < len; ++i) {
        if (leftUnique[i] == rightUnique[i + 1]) {
            res++;
        }
    }

    return res;
}

int main() {
    char s[] = "aacaba";
    printf("Number of good splits: %d\n", numSplits(s));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 定义哈希表结构
typedef struct {
    int *keys;
    int *values;
    int size;
    int count;
} HashTable;

// 初始化哈希表
void initHashTable(HashTable *hashTable, int size) {
    hashTable->keys = (int *)malloc(sizeof(int) * size);
    hashTable->values = (int *)malloc(sizeof(int) * size);
    hashTable->size = size;
    hashTable->count = 0;
    for (int i = 0; i < size; ++i) {
        hashTable->keys[i] = -1;
    }
}

// 哈希函数
int hash(int key, int size) {
    return key % size;
}

// 插入元素到哈希表
void insert(HashTable *hashTable, int key, int value) {
    int index = hash(key, hashTable->size);
    while (hashTable->keys[index] != -1 && hashTable->keys[index] != key) {
        index = (index + 1) % hashTable->size; // 线性探测解决冲突
    }
    hashTable->keys[index] = key;
    hashTable->values[index] = value;
}

// 查找元素在哈希表中的次数
int find(HashTable *hashTable, int key) {
    int index = hash(key, hashTable->size);
    while (hashTable->keys[index] != -1) {
        if (hashTable->keys[index] == key) {
            return hashTable->values[index];
        }
        index = (index + 1) % hashTable->size; // 线性探测
    }
    return 0;
}

// 释放哈希表内存
void freeHashTable(HashTable *hashTable) {
    free(hashTable->keys);
    free(hashTable->values);
}

int numIdenticalPairs(int* nums, int numsSize) {
    HashTable hashTable;
    initHashTable(&hashTable, 101); // 假设数组元素范围是0到100
    int count = 0;
    for (int i = 0; i < numsSize; ++i) {
        int freq = find(&hashTable, nums[i]);
        count += freq;
        insert(&hashTable, nums[i], freq + 1);
    }
    freeHashTable(&hashTable);
    return count;
}

int main() {
    int nums[] = {1, 2, 3, 1, 1, 3};
    int size = sizeof(nums) / sizeof(nums[0]);
    printf("Number of good pairs: %d\n", numIdenticalPairs(nums, size));
    return 0;
}
#include <stdio.h>
#include <math.h>

// 定义一个结构体来存储点的坐标
typedef struct {
    double x;
    double y;
} Point;

// 计算两点之间的欧几里得距离的平方
double distanceSquare(Point p1, Point p2) {
    return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
}

// 计算三个点的质心
Point centroid(Point p1, Point p2, Point p3) {
    Point c;
    c.x = (p1.x + p2.x + p3.x) / 3.0;
    c.y = (p1.y + p2.y + p3.y) / 3.0;
    return c;
}

// 检查一个点是否在由三个点定义的圆内
int isInsideCircle(Point center, double radiusSquare, Point p) {
    return distanceSquare(center, p) <= radiusSquare;
}

// 寻找最佳位置的辅助函数
double findMinDistSum(Point positions[], int n, double left, double right, double bottom, double top) {
    // 如果搜索范围的宽度或高度小于一个很小的值，则返回当前最佳距离
    if (right - left < 1e-5 || top - bottom < 1e-5) {
        double minDist = 0;
        for (int i = 0; i < n; i++) {
            minDist += sqrt(distanceSquare(positions[i], (Point){left + right, bottom + top}));
        }
        return minDist;
    }

    double bestDist = 0;
    Point bestCenter;

    // 选择当前搜索范围的中心点作为初始猜测
    Point center = (Point){(left + right) / 2, (bottom + top) / 2};
    double currentDist = 0;
    for (int i = 0; i < n; i++) {
        currentDist += sqrt(distanceSquare(center, positions[i]));
    }
    bestDist = currentDist;
    bestCenter = center;

    // 检查当前搜索范围的四个角点
    for (int i = 0; i < 4; i++) {
        Point newCenter;
        double newDist;
        if (i == 0) {
            newCenter = (Point){left, center.y};
            newDist = findMinDistSum(positions, n, left, center.x, bottom, top);
        } else if (i == 1) {
            newCenter = (Point){right, center.y};
            newDist = findMinDistSum(positions, n, center.x, right, bottom, top);
        } else if (i == 2) {
            newCenter = (Point){center.x, bottom};
            newDist = findMinDistSum(positions, n, left, right, bottom, center.y);
        } else {
            newCenter = (Point){center.x, top};
            newDist = findMinDistSum(positions, n, left, right, center.y, top);
        }

        // 如果新的距离更小，则更新最佳距离和中心点
        if (newDist < bestDist) {
            bestDist = newDist;
            bestCenter = newCenter;
        }
    }

    return bestDist;
}

// 服务中心的最佳位置
double getMinDistSum(Point positions[], int n) {
    double minDist = 0;
    for (int i = 0; i < n; i++) {
        minDist += sqrt(distanceSquare(positions[0], positions[i]));
    }
    // 从整个地图的边界开始搜索最佳位置
    return findMinDistSum(positions, n, 0, 100, 0, 100);
}

int main() {
    // 示例输入
    Point positions[] = {{0, 1}, {1, 0}, {1, 2}, {2, 1}};
    int n = sizeof(positions) / sizeof(positions[0]);
    printf("Minimum Distance Sum: %.5f\n", getMinDistSum(positions, n));
    return 0;
}
// 定义文件分享系统结构
struct FileSharing {
    // 用哈希表存储用户和他们拥有的文件块
    hashmap users;

    // 加入操作
    void join(int userID, list<int> ownedChunks) {
        lock.acquire(); // 获取锁
        users[userID] = ownedChunks;
        lock.release(); // 释放锁
    }

    // 离开操作
    void leave(int userID) {
        lock.acquire();
        users.erase(userID);
        lock.release();
    }

    // 请求操作
    list<int> request(int userID) {
        list<int> result;
        lock.acquire();
        if (users.count(userID)) {
            result = users[userID];
        }
        lock.release();
        return result;
    }
};
#include <stdio.h>

// 计算累积和
void computePrefixSum(int arr[], int n, int prefixSum[]) {
    prefixSum[0] = arr[0];
    for (int i = 1; i < n; ++i) {
        prefixSum[i] = prefixSum[i - 1] + arr[i];
    }
}

// 二分查找最接近target的值
int closestToTarget(int arr[], int target, int n) {
    int prefixSum[n];
    computePrefixSum(arr, n, prefixSum);
    int minDiff = INT_MAX;
    int result = 0;
    
    for (int l = 0; l < n; ++l) {
        int r = n - 1;
        int closestSum = prefixSum[l];
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (abs(prefixSum[mid] - target) < abs(closestSum - target)) {
                closestSum = prefixSum[mid];
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        int diff = abs(closestSum - target);
        if (diff < minDiff) {
            minDiff = diff;
            result = closestSum;
        }
    }
    return result;
}

int main() {
    int arr[] = {9, 12, 3, 7, 15};
    int target = 5;
    int n = sizeof(arr) / sizeof(arr[0]);
    printf("The closest value to target is: %d\n", closestToTarget(arr, target, n));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 定义N叉树的节点结构
typedef struct Node {
    int val;
    struct Node** children;
    int childrenSize;
} Node;

// 找到N叉树的根节点
Node* findRoot(Node* tree) {
    if (tree == NULL) return NULL; // 如果树为空，返回NULL
    for (int i = 0; i < tree->childrenSize; ++i) {
        if (tree->children[i] != NULL) {
            // 递归检查子节点
            return findRoot(tree->children[i]);
        }
    }
    return tree; // 如果所有子节点都为空，当前节点即为根节点
}

int main() {
    // 构建一个示例N叉树
    Node* root = (Node*)malloc(sizeof(Node));
    root->val = 1;
    root->childrenSize = 3;
    root->children = (Node**)malloc(sizeof(Node*) * root->childrenSize);
    root->children[0] = NULL; // 根节点没有父节点
    root->children[1] = (Node*)malloc(sizeof(Node)); // 创建左子节点
    root->children[1]->val = 3;
    // ... 可以继续添加更多子节点和子树

    // 找到并打印根节点的值
    Node* rootNode = findRoot(root);
    printf("Root node value: %d\n", rootNode->val);

    // 释放内存
    // ... 需要添加代码来释放所有分配的内存

    return 0;
}
#include <stdio.h>

// 函数用于找出数组游戏的赢家
int getWinner(int arr[], int arrSize, int k) {
    // 如果k大于或等于数组长度，最大值将会连续赢得整个数组
    if (k >= arrSize) {
        return arr[0];
    }
    
    int maxIndex = 0; // 假设第一个元素是最大的
    for (int i = 1; i < arrSize; i++) {
        // 如果当前元素大于maxIndex对应的元素，则更新maxIndex
        if (arr[i] > arr[maxIndex]) {
            maxIndex = i;
        }
    }
    
    // 返回赢得比赛的整数
    return arr[maxIndex];
}

int main() {
    int arr[] = {2, 1, 3, 5, 4, 6, 7};
    int k = 2;
    int winner = getWinner(arr, sizeof(arr) / sizeof(arr[0]), k);
    printf("The winner is: %d\n", winner);
    return 0;
}
#include <stdio.h>

int getIndex(int* nums, int numsSize) {
    int maxIndex = 0; // 假设最大值的索引为0
    int maxVal = nums[0]; // 假设第一个元素为最大值

    for (int i = 1; i < numsSize; i++) {
        if (nums[i] > maxVal) {
            maxVal = nums[i]; // 发现新的最大值，更新最大值
            maxIndex = i; // 更新最大值的索引
        }
    }
    return maxIndex; // 返回最大值的索引
}

int main() {
    int nums[] = {7, 7, 7, 7, 10, 7, 7, 7};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    printf("The index of the largest integer is: %d\n", getIndex(nums, numsSize));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 定义箱子结构体
typedef struct {
    int width;
    int height;
} Box;

// 比较函数，用于排序
int cmp(const void *a, const void *b) {
    Box *boxA = (Box *)a;
    Box *boxB = (Box *)b;
    return (boxB->width * boxB->height) - (boxA->width * boxA->height);
}

int maxBoxesInWarehouse(Box boxes[], int boxesSize, int warehouse[2]) {
    // 对箱子进行排序
    qsort(boxes, boxesSize, sizeof(Box), cmp);

    int count = 0; // 放入箱子的数量
    for (int i = 0; i < boxesSize; i++) {
        Box box = boxes[i];
        // 尝试水平放置
        if (warehouse[0] >= box.width && warehouse[1] >= box.height) {
            warehouse[0] -= box.width;
            count++;
        } else if (warehouse[0] >= box.height && warehouse[1] >= box.width) { // 尝试垂直放置
            warehouse[1] -= box.height;
            count++;
        } else {
            // 如果都放不下，跳出循环
            break;
        }
    }
    return count;
}

int main() {
    // 示例
    Box boxes[] = {{4, 3}, {4, 1}};
    int boxesSize = sizeof(boxes) / sizeof(boxes[0]);
    int warehouse[] = {5, 3};
    printf("%d\n", maxBoxesInWarehouse(boxes, boxesSize, warehouse));
    return 0;
}
#include <stdio.h>

// 定义结构体来存储稀疏向量
typedef struct {
    int index;
    int val;
} SparseVector;

// 计算两个稀疏向量的点积
int dotProduct(SparseVector* v1, int v1Size, SparseVector* v2, int v2Size) {
    int i = 0, j = 0, result = 0; // 初始化指针和结果
    while (i < v1Size && j < v2Size) {
        if (v1[i].index < v2[j].index) {
            // 如果v1的下标小，v1指针后移
            i++;
        } else if (v1[i].index > v2[j].index) {
            // 如果v2的下标小，v2指针后移
            j++;
        } else {
            // 下标相同，计算点积并累加
            result += v1[i].val * v2[j].val;
            i++;
            j++;
        }
    }
    return result;
}

int main() {
    // 示例输入
    SparseVector v1[] = {{1, 2}, {3, 4}};
    int v1Size = sizeof(v1) / sizeof(v1[0]);
    SparseVector v2[] = {{1, 5}, {3, 6}};
    int v2Size = sizeof(v2) / sizeof(v2[0]);

    // 计算点积
    int product = dotProduct(v1, v1Size, v2, v2Size);
    printf("Dot Product: %d\n", product);

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 定义二叉树节点结构
typedef struct TreeNode {
    char val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 辅助函数，用于比较操作符优先级
int precedence(char op) {
    switch (op) {
        case '+': return 1;
        case '-': return 1;
        case '*': return 2;
        case '/': return 2;
        default: return -1;
    }
}

// 构建二叉表达式树的递归函数
TreeNode* buildTree(char *s, int *index) {
    if (s[*index] == '\0') return NULL;

    TreeNode *node = (TreeNode*)malloc(sizeof(TreeNode));
    char ch = s[(*index)++];

    if (ch >= '0' && ch <= '9') {
        node->val = ch;
        node->left = node->right = NULL;
    } else {
        node->val = ch;
        node->left = buildTree(s, index);
        node->right = buildTree(s, index);
    }
    return node;
}

// 主函数，用于初始化并调用构建树的函数
int main() {
    char expression[] = "3*4-2*5";
    int index = 0;
    TreeNode *root = buildTree(expression, &index);
    // 打印或处理树...
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <limits.h> // for INT_MAX

// Definition for a binary tree node.
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
};

// Function to find the nearest right node.
struct TreeNode* findNearestRightNode(struct TreeNode* root, int target) {
    struct TreeNode* nearest = NULL;
    int minDiff = INT_MAX;

    // Helper function to perform in-order traversal and update nearest node.
    void helper(struct TreeNode* node) {
        if (!node) return;

        // Traverse the right subtree first.
        helper(node->right);

        // Update the nearest node if the current node is closer to the target.
        int diff = abs(node->val - target);
        if (diff < minDiff) {
            minDiff = diff;
            nearest = node;
        }

        // Traverse the left subtree.
        helper(node->left);
    }

    helper(root);
    return nearest;
}

int main() {
    // Example usage:
    // Create a binary tree: [1,2,3,null,4,5,6]
    struct TreeNode root;
    root.val = 1;
    root.left = malloc(sizeof(struct TreeNode));
    root.left->val = 2;
    root.right = malloc(sizeof(struct TreeNode));
    root.right->val = 3;
    root.right->left = malloc(sizeof(struct TreeNode));
    root.right->left->val = 4;
    root.right->right = malloc(sizeof(struct TreeNode));
    root.right->right->val = 5;
    root.right->right->right = malloc(sizeof(struct TreeNode));
    root.right->right->right->val = 6;

    int target = 4;
    struct TreeNode* result = findNearestRightNode(&root, target);
    printf("The nearest right node with value %d is: %d\n", target, result->val);

    return 0;
}
// 定义二叉树的节点结构
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 函数声明
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q);

// 代码实现
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    // 如果达到叶子节点或者找到任何一个目标节点，返回当前节点
    if (!root || root == p || root == q) {
        return root;
    }

    // 递归地在左右子树中寻找目标节点
    TreeNode* left = lowestCommonAncestor(root->left, p, q);
    TreeNode* right = lowestCommonAncestor(root->right, p, q);

    // 如果左右子树都找到了目标节点，说明当前节点是最近公共祖先
    if (left && right) {
        return root;
    }

    // 如果只找到一个目标节点，返回那个目标节点
    return left ? left : right;
}
#include <stdio.h>
#include <stdlib.h>

int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    // 创建哈希表，存储数字及其索引
    int* hashTable = (int*)malloc(sizeof(int) * numsSize * 2);
    int* indices = (int*)malloc(sizeof(int) * 2);
    *returnSize = 0;

    for (int i = 0; i < numsSize; i++) {
        int complement = target - nums[i];
        if (complement == nums[i] && *returnSize < 1) {
            // 特殊情况，两个相同的数相加
            indices[(*returnSize)++] = i;
        } else if (complement < nums[i]) {
            // 如果差值小于当前数，则不可能找到符合条件的两个数
            continue;
        } else {
            // 在哈希表中查找差值
            int index = hashTable[complement] != -1 ? hashTable[complement] : -1;
            if (index != -1) {
                // 找到匹配的数
                indices[*returnSize] = index;
                indices[(*returnSize) + 1] = i;
                break;
            } else {
                // 存储当前数的索引
                hashTable[nums[i]] = i;
            }
        }
    }

    // 如果没有找到，返回NULL
    if (*returnSize < 2) {
        free(indices);
        return NULL;
    }

    return indices;
}

int main() {
    int nums[] = {2, 7, 11, 15};
    int target = 9;
    int returnSize = 0;
    int* result = twoSum(nums, sizeof(nums)/sizeof(nums[0]), target, &returnSize);

    if (result) {
        printf("Index1: %d, Index2: %d\n", result[0], result[1]);
        free(result);
    } else {
        printf("No two sum\n");
    }

    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <limits.h> // for INT_MAX

// Definition for a binary tree node.
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
};

// Function to find the nearest right node.
struct TreeNode* findNearestRightNode(struct TreeNode* root, int target) {
    struct TreeNode* nearest = NULL;
    int minDiff = INT_MAX;

    // Helper function to perform in-order traversal and update nearest node.
    void helper(struct TreeNode* node) {
        if (!node) return;

        // Traverse the right subtree first.
        helper(node->right);

        // Update the nearest node if the current node is closer to the target.
        int diff = abs(node->val - target);
        if (diff < minDiff) {
            minDiff = diff;
            nearest = node;
        }

        // Traverse the left subtree.
        helper(node->left);
    }

    helper(root);
    return nearest;
}

int main() {
    // Example usage:
    // Create a binary tree: [1,2,3,null,4,5,6]
    struct TreeNode root;
    root.val = 1;
    root.left = malloc(sizeof(struct TreeNode));
    root.left->val = 2;
    root.right = malloc(sizeof(struct TreeNode));
    root.right->val = 3;
    root.right->left = malloc(sizeof(struct TreeNode));
    root.right->left->val = 4;
    root.right->right = malloc(sizeof(struct TreeNode));
    root.right->right->val = 5;
    root.right->right->right = malloc(sizeof(struct TreeNode));
    root.right->right->right->val = 6;

    int target = 4;
    struct TreeNode* result = findNearestRightNode(&root, target);
    printf("The nearest right node with value %d is: %d\n", target, result->val);

    return 0;
}
typedef struct TreeNode {
    char val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

bool checkEquivalence(TreeNode* root1, TreeNode* root2) {
    // 基本情况
    if (!root1 && !root2) return true;
    if (!root1 || !root2) return false;
    
    // 如果是叶子节点，比较数值
    if (root1->left == NULL && root2->left == NULL) {
        return root1->val == root2->val;
    }
    
    // 检查操作符是否相同
    if (root1->val != root2->val) return false;
    
    // 递归检查左右子树
    return checkEquivalence(root1->left, root2->left) && 
           checkEquivalence(root1->right, root2->right);
}
typedef struct TreeNode {
    char val; // 存储操作数或运算符
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 构建树的函数
TreeNode* buildTree(char **s, int *index) {
    if (s[0][*index] == '#') {
        (*index)++;
        return NULL;
    }
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
    node->val = s[0][(*index)++];
    node->left = buildTree(s, index);
    node->right = buildTree(s, index);
    return node;
}

// 解析树并计算值的函数
int evaluateTree(TreeNode* node) {
    if (node == NULL) return 0;
    int leftVal = evaluateTree(node->left);
    int rightVal = evaluateTree(node->right);
    switch (node->val) {
        case '+': return leftVal + rightVal;
        case '-': return leftVal - rightVal;
        case '*': return leftVal * rightVal;
        case '/': return leftVal / rightVal;
        default: return node->val - '0'; // 将字符转换为整数
    }
}
#include <stdio.h>
#include <stdlib.h>

// 辅助函数，用于计算等差数列的和
int sumOfArithmeticSequence(int a, int d, int n) {
    return n * (2 * a + (n - 1) * d) / 2;
}

// 主函数，解决给定问题
int* sumOfSpecialEvenlySpacedElements(int* nums, int numsSize, int** queries, int queriesSize[], int* returnSize) {
    // 哈希表，存储前缀和
    int *prefixSums = (int *)malloc(sizeof(int) * numsSize);
    prefixSums[0] = nums[0];
    for (int i = 1; i < numsSize; ++i) {
        prefixSums[i] = prefixSums[i - 1] + nums[i];
    }

    // 存储结果
    int *results = (int *)malloc(sizeof(int) * queriesSize[0]);
    *returnSize = queriesSize[0];

    for (int i = 0; i < queriesSize[0]; ++i) {
        int l = queries[i][0], r = queries[i][1];
        int d = 1;
        while (l + d <= r) {
            int j = l + d;
            // 计算当前等差数列的和
            int currentSum = 0;
            if (l == 0) {
                currentSum = prefixSums[j] - prefixSums[l];
            } else {
                currentSum = prefixSums[j] - prefixSums[l - 1];
            }
            // 检查是否符合等差数列的和
            if (currentSum == sumOfArithmeticSequence(nums[l], nums[l] * d, (j - l) / d + 1)) {
                results[i] = currentSum;
                break;
            }
            d++;
        }
    }

    return results;
}

int main() {
    // 示例输入
    int nums[] = {0, 1, 2, 3, 4, 5, 6, 7};
    int queries[][2] = {{0, 3}, {5, 1}, {4, 2}};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int queriesSize = sizeof(queries) / sizeof(queries[0]);
    int returnSize = 0;

    // 调用函数
    int *result = sumOfSpecialEvenlySpacedElements(nums, numsSize, (int **)queries, &queriesSize, &returnSize);

    // 打印结果
    for (int i = 0; i < returnSize; ++i) {
        printf("%d ", result[i]);
    }
    printf("\n");

    // 释放内存
    free(result);
    return 0;
}
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 函数声明：改变二叉树的根节点
TreeNode* changeRoot(TreeNode* root, int leaf) {
    if (!root) return NULL;
    
    // 如果当前节点是目标节点，将其作为新根节点
    if (root->val == leaf) return root;
    
    // 递归左子树和右子树
    TreeNode* left = changeRoot(root->left, leaf);
    TreeNode* right = changeRoot(root->right, leaf);
    
    // 如果左子树或右子树的返回值不为空，说明找到了目标节点
    if (left) {
        // 将当前节点的右子树链接到目标节点的左子树上
        left->right = root->right;
        // 更新当前节点的右子树为新根节点
        root->right = left;
        return root;
    }
    
    if (right) {
        // 类似地处理右子树
        right->left = root->left;
        root->left = right;
        return right;
    }
    
    return NULL;
}
#include <string.h>
#include <limits.h>

// 动态规划求最长回文子序列
int longestPalindromeSubseq(char *s) {
    int n = strlen(s);
    // 初始化dp数组，所有元素设为0
    int dp[n][n];
    for (int i = 0; i < n; i++) {
        dp[i][i] = 1; // 单个字符是长度为1的回文子序列
        for (int j = i + 1; j < n; j++) {
            if (s[i] == s[j]) {
                // 如果字符相同，状态转移
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                // 否则取两个选择的最大值
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[0][n - 1]; // 返回最长回文子序列的长度
}

// 辅助函数，用于获取两个整数的最大值
int max(int a, int b) {
    return a > b ? a : b;
}
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

typedef struct Edge {
    int v; // 目标节点
    int dis; // 边的长度
    struct Edge* next; // 指向下一个边的指针
} Edge;

typedef struct {
    int n; // 图的节点数
    Edge** adj; // 邻接表
} DistanceLimitedPathsExist;

// 初始化图
DistanceLimitedPathsExist* DistanceLimitedPathsExistConstructor(int n, int** edgeList, int edgeListSize) {
    DistanceLimitedPathsExist* graph = (DistanceLimitedPathsExist*)malloc(sizeof(DistanceLimitedPathsExist));
    graph->n = n;
    graph->adj = (Edge**)malloc(n * sizeof(Edge*));
    for (int i = 0; i < n; i++) {
        graph->adj[i] = NULL;
    }

    for (int i = 0; i < edgeListSize; i++) {
        int u = edgeList[i][0];
        int v = edgeList[i][1];
        int w = edgeList[i][2];
        Edge* newEdge = (Edge*)malloc(sizeof(Edge));
        newEdge->v = v;
        newEdge->dis = w;
        newEdge->next = graph->adj[u];
        graph->adj[u] = newEdge;
    }

    return graph;
}

// 查询函数
bool DistanceLimitedPathsExistQuery(DistanceLimitedPathsExist* obj, int p, int q, int limit) {
    bool visited[obj->n] = {false};
    int dist[obj->n];
    for (int i = 0; i < obj->n; i++) {
        dist[i] = INT_MAX;
    }
    dist[p] = 0;

    Edge* queue[obj->n];
    int front = 0, rear = 0;
    queue[rear++] = obj->adj[p];

    while (front < rear) {
        Edge* edge = queue[front++];
        while (edge) {
            if (dist[edge->v] > dist[edge->dis] + p) {
                dist[edge->v] = dist[p] + edge->dis;
                queue[rear++] = obj->adj[edge->v];
            }
            edge = edge->next;
        }
    }

    return dist[q] <= limit;
}

// 销毁图
void DistanceLimitedPathsExistFree(DistanceLimitedPathsExist* obj) {
    for (int i = 0; i < obj->n; i++) {
        Edge* edge = obj->adj[i];
        while (edge) {
            Edge* temp = edge;
            edge = edge->next;
            free(temp);
        }
    }
    free(obj->adj);
    free(obj);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 定义二叉树的节点结构
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 创建一个新节点
TreeNode* createNode(int val) {
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
    node->val = val;
    node->left = NULL;
    node->right = NULL;
    return node;
}

// 找到两个节点的最小距离的函数
int findMinDistance(TreeNode* root, int p, int q) {
    if (!root) return -1; // 如果树为空，返回-1

    // 队列用于BFS
    TreeNode *queue[1000], *temp[1000];
    int front = 0, rear = 0;
    int step = 0, foundP = 0, foundQ = 0;

    // 将根节点入队
    queue[rear++] = root;

    while (front < rear) {
        while (front < rear) {
            TreeNode *node = queue[front++];
            if (node->val == p) foundP = 1;
            if (node->val == q) foundQ = 1;

            // 如果找到两个节点，计算距离
            if (foundP && foundQ) return step;

            // 访问左右子节点并入队
            if (node->left) {
                queue[rear++] = node->left;
            }
            if (node->right) {
                queue[rear++] = node->right;
            }
        }
        // 完成一层搜索，增加步数
        front = 0;
        rear = 0;
        step++;
    }
    return -1; // 如果没有找到节点，返回-1
}

int main() {
    // 构建示例二叉树
    TreeNode *root = createNode(3);
    root->left = createNode(5);
    root->right = createNode(1);
    root->left->left = createNode(6);
    root->left->right = createNode(2);
    root->right->left = createNode(0);
    root->right->right = createNode(8);
    root->left->right->left = createNode(7);
    root->left->right->right = createNode(4);

    // 调用函数并打印结果
    int p = 5, q = 0;
    printf("Minimum distance between %d and %d is %d\n", p, q, findMinDistance(root, p, q));

    // 释放二叉树内存
    // ...

    return 0;
}
#include <string.h>
#include <stdlib.h>

// 定义账户结构体，包含账户ID和IP地址的集合
typedef struct {
    int account_id;
    char ip_addresses[50][15];
    int ip_count;
} Account;

// 检查账户是否应该被禁止
int checkBan(Account *accounts, int account_id, int size) {
    for (int i = 0; i < size; i++) {
        if (accounts[i].account_id == account_id) {
            return (accounts[i].ip_count == 1) ? 1 : 0;
        }
    }
    return 0;
}

// 根据登录记录更新账户信息
void updateAccounts(Account *accounts, int *account_size, char *account_id, char *ip_address) {
    int id = atoi(account_id);
    for (int i = 0; i < *account_size; i++) {
        if (accounts[i].account_id == id) {
            // 如果IP地址尚未记录，则添加
            int found = 0;
            for (int j = 0; j < accounts[i].ip_count; j++) {
                if (strcmp(accounts[i].ip_addresses[j], ip_address) == 0) {
                    found = 1;
                    break;
                }
            }
            if (!found) {
                strcpy(accounts[i].ip_addresses[accounts[i].ip_count], ip_address);
                accounts[i].ip_count++;
            }
            return;
        }
    }
    // 如果账户尚未记录，则创建新记录
    Account new_account;
    new_account.account_id = id;
    strcpy(new_account.ip_addresses[0], ip_address);
    new_account.ip_count = 1;
    accounts[*account_size] = new_account;
    (*account_size)++;
}

// 核心函数，根据登录记录确定需要禁止的账户
int[] leetflexBannedAccounts(char ***logs, int logsSize, int *returnSize) {
    *returnSize = 0;
    Account accounts[1000]; // 假设账户数量不超过1000
    int account_size = 0;

    // 更新账户信息
    for (int i = 0; i < logsSize; i++) {
        char *log = logs[i][0];
        char *account_id = strtok(log, " ");
        char *ip_address = strtok(NULL, " ");
        updateAccounts(accounts, &account_size, account_id, ip_address);
    }

    // 分配输出数组
    int *banned = (int *)malloc(account_size * sizeof(int));

    // 检查并记录需要禁止的账户
    for (int i = 0; i < account_size; i++) {
        if (checkBan(accounts, accounts[i].account_id, account_size)) {
            banned[(*returnSize)++] = accounts[i].account_id;
        }
    }

    return banned;
}
#include <stdlib.h>

// 定义一个结构体来存储结果
typedef struct {
    int *data;
    int size;
    int length;
} MyArray;

// 初始化数组
void initMyArray(MyArray *a, int size) {
    a->data = (int *)malloc(sizeof(int) * size);
    a->size = size;
    a->length = 0;
}

// 向数组中添加元素
void pushMyArray(MyArray *a, int val) {
    if (a->length < a->size) {
        a->data[a->length++] = val;
    }
}

// 释放数组
void freeMyArray(MyArray *a) {
    free(a->data);
}

// 能看到海景的建筑物
int *findBuildingsWithOceanView(int *heights, int heightsSize, int *returnSize) {
    int *res = (int *)malloc(sizeof(int) * heightsSize);
    *returnSize = 0;

    MyArray left, right;
    initMyArray(&left, heightsSize);
    initMyArray(&right, heightsSize);

    // 从左到右遍历，记录能看到的最远建筑物的高度
    for (int i = 0; i < heightsSize; i++) {
        while (left.length > 0 && heights[left.data[left.length - 1]] <= heights[i]) {
            popMyArray(&left);
        }
        left.length++;
        if (left.length > 0) {
            pushMyArray(&res, left.data[left.length - 1]);
        }
    }

    // 从右到左遍历，更新最远能看到的建筑物
    for (int i = heightsSize - 1; i >= 0; i--) {
        while (right.length > 0 && heights[right.data[right.length - 1]] <= heights[i]) {
            popMyArray(&right);
        }
        right.length++;
        if (right.length > 0 && right.data[right.length - 1] == i) {
            res[(*returnSize)++] = i;
        }
    }

    freeMyArray(&left);
    freeMyArray(&right);
    return res;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 用于比较两个字符串的受欢迎程度的函数
int compare(const void *a, const void *b) {
    char **feature_a = (char **)a;
    char **feature_b = (char **)b;
    int count_a = feature_popularity[feature_hash[*feature_a]];
    int count_b = feature_popularity[feature_hash[*feature_b]];
    return count_b - count_a; // 降序排序
}

int main() {
    char *features[] = {"cooler", "lock", "touch"};
    char *responses[] = {"i like cooler cooler", "lock touch cool", "locker like touch"};
    int features_size = sizeof(features) / sizeof(features[0]);
    int responses_size = sizeof(responses) / sizeof(responses[0]);

    // 初始化哈希表，用于存储每个功能的受欢迎程度
    int feature_hash[100] = {0};
    int feature_popularity[100] = {0};

    // 填充哈希表
    for (int i = 0; i < responses_size; i++) {
        char *token = strtok(responses[i], " ");
        while (token != NULL) {
            int index = feature_hash[token] - 1; // 假设哈希函数将字符串映射到0到99之间的整数
            if (index >= 0 && index < 100) {
                feature_popularity[index]++;
            }
            token = strtok(NULL, " ");
        }
    }

    // 排序
    qsort(features, features_size, sizeof(char *), compare);

    // 输出结果
    for (int i = 0; i < features_size; i++) {
        printf("%s\n", features[i]);
    }

    return 0;
}
#include <stdio.h>

int maxBeauty(int* flowers, int flowersSize, int k) {
    int ans = 0, sum = 0;
    int i = 0, j = 0;
    while (j < flowersSize) {
        sum += flowers[j++];
        if (j - i == k) {
            ans = (sum > ans) ? sum : ans;
            if (i < j) sum -= flowers[i++];
        }
    }
    return ans;
}

int main() {
    int flowers[] = {1, 2, 3, 1, 2};
    int k = 2;
    printf("Maximum beauty of the garden is: %d\n", maxBeauty(flowers, sizeof(flowers)/sizeof(int), k));
    return 0;
}
typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

// 创建一个函数来移除链表中的重复元素
ListNode* deleteDuplicatesUnsorted(ListNode* head) {
    ListNode* current = head;
    HashSet set; // 假设的哈希表结构

    while (current != NULL) {
        // 如果当前元素在哈希表中，说明是重复的，需要删除
        if (isInHashSet(set, current->val)) {
            ListNode* toDelete = current;
            current = current->next;
            free(toDelete); // 释放内存
        } else {
            // 否则，将当前元素值添加到哈希表中
            addtoHashSet(set, current->val);
            current = current->next;
        }
    }

    return head;
}
#include <stdio.h>
#include <stdlib.h>

// 定义链表节点结构体
typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

// 找到链表的中点
ListNode* findMiddle(ListNode* head) {
    ListNode *slow = head, *fast = head, *prev = NULL;
    while (fast && fast->next) {
        prev = slow;
        slow = slow->next;
        fast = fast->next->next;
    }
    if (prev) prev->next = NULL; // 切断链表
    return slow;
}

// 合并两个有序链表
ListNode* merge(ListNode* l1, ListNode* l2) {
    ListNode dummy;
    ListNode *tail = &dummy;
    while (l1 && l2) {
        if (l1->val < l2->val) {
            tail->next = l1;
            l1 = l1->next;
        } else {
            tail->next = l2;
            l2 = l2->next;
        }
        tail = tail->next;
    }
    tail->next = l1 ? l1 : l2;
    return dummy.next;
}

// 归并排序链表
ListNode* sortLinkedList(ListNode* head) {
    if (!head || !head->next) return head;
    ListNode *mid = findMiddle(head);
    ListNode *left = sortLinkedList(head); // 前半部分排序
    ListNode *right = sortLinkedList(mid); // 后半部分排序
    return merge(left, right); // 合并两个有序链表
}

int main() {
    // 示例：构建一个链表，并调用排序函数
    ListNode *head = (ListNode*)malloc(sizeof(ListNode));
    head->val = 4;
    head->next = NULL;
    // 继续构建链表...
    // 调用排序函数
    ListNode *sorted = sortLinkedList(head);
    // 打印排序后的链表...
    return 0;
}
int rearrangeSticks(int n, int k) {
    int MOD = 1e9 + 7;
    int dp[1001][1001] = {0};
    dp[0][0] = 1;
    
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= k; j++) {
            if (j > 0) {
                dp[i][j] = (dp[i - 1][j - 1] * (i - j) + dp[i][j - 1]) % MOD;
            } else {
                dp[i][j] = dp[i][j - 1];
            }
        }
    }
    
    return dp[n][k];
}
bool checkZeroOnes(char* s) {
    int maxOnes = 0, maxZeros = 0;
    int currOnes = 0, currZeros = 0;
    for (int i = 0; s[i] != '\0'; i++) {
        if (s[i] == '1') {
            currOnes++;
            currZeros = 0; // Reset zeros count
        } else {
            currZeros++;
            currOnes = 0; // Reset ones count
        }
        if (currOnes > maxOnes) maxOnes = currOnes;
        if (currZeros > maxZeros) maxZeros = currZeros;
    }
    return maxOnes > maxZeros;
}
#include <stdbool.h>

// 判断在给定速度下是否能准时到达
bool can_arrive_on_time(int* dist, int n, double hour, int speed) {
    double time = 0;
    for (int i = 0; i < n; ++i) {
        time += (double)dist[i] / speed; // 乘车时间
        if (time > (int)time) time = (int)time + 1; // 等待时间
    }
    return time <= hour;
}

int minSpeedOnTime(int* dist, int n, double hour) {
    int left = 1, right = 1e7; // 设置搜索范围
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (can_arrive_on_time(dist, n, hour, mid)) {
            right = mid; // 如果可以到达，尝试减小速度
        } else {
            left = mid + 1; // 否则增加速度
        }
    }
    return left; // 找到的最小速度
}
#include <stdio.h>

int stoneGameVIII(int* stones, int stonesSize) {
    // 前缀和数组
    int prefixSum[stonesSize + 1];
    for (int i = 0; i < stonesSize; ++i) {
        prefixSum[i + 1] = prefixSum[i] + stones[i];
    }
    
    // dp数组，初始化为第一个石子的价值
    int dp[stonesSize];
    dp[0] = stones[0];
    
    // 动态规划求解
    for (int i = 1; i < stonesSize; ++i) {
        int maxDiff = -2000000000; // 初始化为最小可能值
        for (int j = 0; j < i; ++j) {
            maxDiff = max(maxDiff, prefixSum[i + 1] - prefixSum[j] - dp[j]);
        }
        dp[i] = maxDiff;
    }
    
    // Alice 的最终分数与 Bob 的分数之差
    return dp[stonesSize - 1];
}

// 辅助函数，用于计算两个数的最大值
int max(int a, int b) {
    return (a > b) ? a : b;
}

int main() {
    int stones[] = {-1, 2, -3, 4, -5};
    int size = sizeof(stones) / sizeof(stones[0]);
    printf("The difference of scores is: %d\n", stoneGameVIII(stones, size));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int* distinctNumbers(int* nums, int numsSize, int k, int* returnSize) {
    int* result = (int*)malloc(sizeof(int) * numsSize);
    *returnSize = 0;
    
    // 初始化哈希表，用于存储窗口内数字的出现次数
    int** count = (int**)malloc(sizeof(int*) * 101);
    for (int i = 0; i < 101; ++i) {
        count[i] = (int*)calloc(numsSize + 1, sizeof(int)); // 假设数字范围在1到100
    }
    
    int distinctCount = 0;
    for (int i = 0; i < k; ++i) {
        if (count[nums[i]]) {
            count[nums[i]][i] = 1;
        } else {
            distinctCount++;
            count[nums[i]] = (int*)malloc(sizeof(int) * (numsSize + 1));
            count[nums[i]][i] = 1;
        }
    }
    result[0] = distinctCount;
    (*returnSize)++;
    
    for (int i = k; i < numsSize; ++i) {
        // 移除窗口左边界元素
        if (count[nums[i - k]]) {
            count[nums[i - k]][i - k] = 0;
            if (!count[nums[i - k]][i - k + 1]) {
                distinctCount--;
            }
            free(count[nums[i - k]]);
            count[nums[i - k]] = NULL;
        }
        // 添加新元素
        if (!count[nums[i]]) {
            distinctCount++;
            result[*returnSize] = distinctCount;
            (*returnSize)++;
            count[nums[i]] = (int*)malloc(sizeof(int) * (numsSize + 1));
            count[nums[i]][i] = 1;
        } else {
            result[*returnSize] = distinctCount;
            (*returnSize)++;
            count[nums[i]][i]++;
        }
    }
    
    // 清理分配的内存
    for (int i = 0; i < 101; ++i) {
        if (count[i]) {
            free(count[i]);
        }
    }
    free(count);
    
    return result;
}

int main() {
    int nums[] = {1,2,3,2,2,1,3};
    int k = 3;
    int returnSize = 0;
    int* result = distinctNumbers(nums, sizeof(nums)/sizeof(nums[0]), k, &returnSize);
    
    printf("Distinct numbers in each subarray of length %d:\n", k);
    for (int i = 0; i < returnSize; i++) {
        printf("%d ", result[i]);
    }
    printf("\n");
    
    free(result);
    return 0;
}
#include <stdbool.h>

bool isCovered(int** ranges, int rangesSize, int* rangeColSize, int left, int right) {
    // 按区间起始位置排序
    qsort(ranges, rangesSize, sizeof(int[2]), (int (*)(const void*, const void*))compare);

    int start = left, end = -1; // 初始化区间跟踪
    for (int i = 0; i < rangesSize; ++i) {
        int currentStart = ranges[i][0];
        int currentEnd = ranges[i][1];
        
        // 如果当前区间的起始值大于end，说明出现间隔
        if (currentStart > end) {
            break;
        }
        
        // 更新end值，如果当前区间的结束值更大
        end = (currentEnd > end) ? currentEnd : end;
        
        // 如果已经覆盖到right，直接返回true
        if (end >= right) {
            return true;
        }
    }
    // 如果end没有达到right，说明没有完全覆盖区间
    return (end >= right);
}

// 比较函数，用于qsort
int compare(const void* a, const void* b) {
    int* rangeA = *(int**)a;
    int* rangeB = *(int**)b;
    return rangeA[0] - rangeB[0];
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_CITIES 200
#define MAX_ROADS 400
#define MAX_K 20

int n, k;
int highways[MAX_ROADS][3];
int dp[MAX_CITIES][MAX_K+1];

int findMaxCost(int city, int k) {
    if (k == 0) {
        return 0;
    }
    if (dp[city][k] != -1) {
        return dp[city][k];
    }
    int max_cost = 0;
    for (int i = 0; i < n; i++) {
        if (highways[i][0] == city && (dp[highways[i][1]][k-1] == -1 || dp[highways[i][1]][k-1] < findMaxCost(highways[i][1], k-1))) {
            max_cost = highways[i][2] + findMaxCost(highways[i][1], k-1);
            break;
        }
    }
    dp[city][k] = max_cost;
    return max_cost;
}

int maximumCost(int n, int k, int highways[]) {
    memset(dp, -1, sizeof(dp));
    return findMaxCost(0, k);
}

int main() {
    // 示例输入
    n = 5;
    k = 3;
    highways[0][0] = 0; highways[0][1] = 1; highways[0][2] = 4;
    highways[1][0] = 2; highways[1][1] = 1; highways[1][2] = 3;
    highways[2][0] = 1; highways[2][1] = 4; highways[2][2] = 11;
    highways[3][0] = 3; highways[3][1] = 2; highways[3][2] = 3;
    highways[4][0] = 3; highways[4][1] = 4; highways[4][2] = 2;

    printf("Maximum cost: %d\n", maximumCost(n, k, highways));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 比较函数，用于 qsort
int compare(const void *a, const void *b) {
    return strlen(*(const char **)b) - strlen(*(const char **)a);
}

// 检查 word 是否是 prelude 的前缀
int isPrefix(const char *word, const char *prelude) {
    return strncmp(word, prelude, strlen(prelude)) == 0;
}

// 找到最长的前缀单词
char *longestWordWithAllPrefixes(char **words, int wordsSize, char *prelude) {
    qsort(words, wordsSize, sizeof(char *), compare);
    char *longest = NULL;
    for (int i = 0; i < wordsSize; ++i) {
        if (isPrefix(words[i], prelude) && strlen(words[i]) > strlen(longest)) {
            longest = words[i];
        }
    }
    return longest;
}

int main() {
    char *words[] = {"k", "ki", "kir", "kira", "kiran"};
    int wordsSize = sizeof(words) / sizeof(words[0]);
    char prelude[] = "kira";
    char *result = longestWordWithAllPrefixes(words, wordsSize, prelude);
    printf("The longest word with all prefixes is: %s\n", result);
    return 0;
}
#include <stdio.h>
#include <string.h>

// 将字符串转换为数值
int wordToValue(char* word) {
    int value = 0;
    for (int i = 0; word[i] != '\0'; ++i) {
        value = value * 10 + (word[i] - 'a');
    }
    return value;
}

// 检查两个单词的和是否等于目标单词的数值
bool isSumEqual(char* firstWord, char* secondWord, char* targetWord) {
    int sum = wordToValue(firstWord) + wordToValue(secondWord);
    return sum == wordToValue(targetWord);
}

int main() {
    char* firstWord = "acb";
    char* secondWord = "cba";
    char* targetWord = "cdb";
    printf("%d\n", isSumEqual(firstWord, secondWord, targetWord)); // 输出应为 1（true）
    return 0;
}
#include <stdio.h>
#include <stdio.h>
#include <string.h>

char* maxValueAfterInsertion(char* n, int x) {
    int len = strlen(n);
    char maxEnd[13]; // 因为n的长度最大为10^5，加上x和负号，足够存储
    int maxPtr = 0;

    // 处理正数情况
    int i;
    for (i = 0; i < len; ++i) {
        if (n[i] < '0' + x) {
            break;
        }
        // 构建最大结束字符串
        maxEnd[maxPtr++] = n[i];
    }

    // 在找到的位置前插入x
    maxEnd[maxPtr++] = '0' + x;

    // 继续添加剩余的部分
    for (; i < len; ++i) {
        maxEnd[maxPtr++] = n[i];
    }
    maxEnd[maxPtr] = '\0'; // 字符串结束符

    return strdup(maxEnd); // 使用strdup复制字符串，因为不能修改输入的n
}

int main() {
    char n[] = "99";
    int x = 9;
    char* result = maxValueAfterInsertion(n, x);
    printf("%s\n", result);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 定义服务器结构体
typedef struct {
    int weight;   // 权重
    int index;    // 下标
    int freeTime; // 预计空闲时间
} Server;

int cmp(const void *a, const void *b) {
    Server *serverA = (Server *)a;
    Server *serverB = (Server *)b;
    if (serverA->weight != serverB->weight) {
        return serverA->weight - serverB->weight;
    }
    return serverA->index - serverB->index;
}

int* assignTasks(int* servers, int serversSize, int* tasks, int tasksSize, int* returnSize) {
    // 初始化服务器数组
    Server *serverArray = (Server *)malloc(sizeof(Server) * serversSize);
    for (int i = 0; i < serversSize; i++) {
        serverArray[i].weight = servers[i];
        serverArray[i].index = i;
        serverArray[i].freeTime = 0;
    }

    // 创建并初始化优先队列
    int *ans = (int *)malloc(sizeof(int) * tasksSize);
    Server *minHeap = (Server *)malloc(sizeof(Server) * serversSize);
    *returnSize = tasksSize;
    int heapSize = 0;

    for (int taskIndex = 0; taskIndex < tasksSize; taskIndex++) {
        // 将所有可以处理当前任务的服务器加入到优先队列中
        for (int i = 0; i < serversSize; i++) {
            if (serverArray[i].freeTime <= taskIndex) {
                minHeap[heapSize++] = serverArray[i];
            }
        }

        // 根据权重和下标对服务器进行排序
        qsort(minHeap, heapSize, sizeof(Server), cmp);

        // 取出权重最小的服务器
        Server chosenServer = minHeap[0];
        ans[taskIndex] = chosenServer.index;

        // 更新服务器的预计空闲时间
        chosenServer.freeTime = taskIndex + tasks[taskIndex];
        serverArray[chosenServer.index] = chosenServer;

        // 重新初始化优先队列
        heapSize = 0;
    }

    free(serverArray);
    free(minHeap);
    return ans;
}
int minSkips(int dist[], int n, int speed, int hoursBefore) {
    // 计算总距离
    long long totalDistance = 0;
    for (int i = 0; i < n; ++i) {
        totalDistance += dist[i];
    }
    
    // 计算不跳过休息所需时间
    double timeNeeded = (double)totalDistance / speed;
    
    // 如果所需时间小于等于hoursBefore，不需要跳过休息
    if (timeNeeded <= hoursBefore) {
        return 0;
    }
    
    // 初始化dp数组
    int dp[n+1][hoursBefore+1];
    memset(dp, 0x3f, sizeof(dp)); // 使用较大的数初始化，表示无穷大
    
    // 状态初始化：第0条路，任意小时数下都不需要跳过
    for (int j = 0; j <= hoursBefore; ++j) {
        dp[0][j] = 0;
    }
    
    // 动态规划填表
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= hoursBefore; ++j) {
            // 走当前道路，不跳过休息
            dp[i][j] = dp[i-1][(int)ceil((double)(dist[i-1] * speed) / hoursBefore)];
            // 尝试跳过休息
            for (int k = 1; k <= j; ++k) {
                dp[i][j] = min(dp[i][j], dp[i-1][k-1] + 1);
            }
        }
    }
    
    // 检查是否有解
    if (dp[n][hoursBefore] < INT_MAX) {
        return dp[n][hoursBefore];
    } else {
        return -1;
    }
}
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char* removeOccurrences(char* s, char* part) {
    int len_s = strlen(s);
    int len_part = strlen(part);
    char *res = (char *)malloc(len_s + 1); // 申请足够的空间，+1为了存储结尾的'\0'
    int j = 0; // res中的索引

    for (int i = 0; i <= len_s - len_part; i++) {
        // 如果找到匹配的子字符串part
        if (strncmp(&s[i], part, len_part) == 0) {
            // 跳过这个子字符串继续查找
            i += len_part - 1;
        } else {
            // 否则，将当前字符添加到res中
            res[j++] = s[i];
        }
    }

    // 将剩余部分添加到res中
    while (i < len_s) {
        res[j++] = s[i++];
    }

    res[j] = '\0'; // 确保字符串以'\0'结尾
    free(s); // 注意释放原始字符串s的内存
    return res;
}

int main() {
    char s[] = "daabcbaabcbc";
    char part[] = "abc";
    char *result = removeOccurrences(s, part);
    printf("Output: %s\n", result);
    free(result); // 释放结果字符串的内存
    return 0;
}
#include <stdio.h>
#include <stdbool.h>

bool canBeEqual(char **words, int wordsSize) {
    // 假设wordsSize是字符串数组的长度
    int count[26] = {0}; // 存储每个字符出现的次数，假设是小写字母
    for (int i = 0; i < wordsSize; ++i) {
        for (int j = 0; words[i][j]; ++j) {
            // 将字符转换为索引，例如'a' -> 0, 'b' -> 1, ...
            int index = words[i][j] - 'a';
            count[index]++;
        }
    }

    int totalChars = 0;
    for (int i = 0; i < 26; ++i) {
        totalChars += count[i];
    }

    // 检查是否可以平均分配字符
    for (int i = 0; i < 26; ++i) {
        if (count[i] % wordsSize != 0) {
            return false; // 如果不能平均分配，则返回false
        }
    }

    // 如果所有字符都能平均分配，则返回true
    return true;
}

int main() {
    char *words1[] = {"abc", "aabc", "bc"};
    int wordsSize1 = sizeof(words1) / sizeof(words1[0]);
    printf("%s\n", canBeEqual(words1, wordsSize1) ? "true" : "false");

    char *words2[] = {"ab", "a"};
    int wordsSize2 = sizeof(words2) / sizeof(words2[0]);
    printf("%s\n", canBeEqual(words2, wordsSize2) ? "true" : "false");

    return 0;
}
#include <stdio.h>

// 计算最晚回合数
int calculateLatestRound(int n, int firstPlayer, int secondPlayer) {
    int latest = 0;
    while (n > 1) {
        n /= 2; // 每轮后运动员数量减半
        latest++; // 回合数增加
        // 如果两个运动员在同一半区，则他们不会在这一轮比拼
        if (firstPlayer <= n && secondPlayer > n) {
            break;
        }
    }
    return latest;
}

// 计算最早回合数
int calculateEarliestRound(int n, int firstPlayer, int secondPlayer) {
    int rounds = 0;
    while (n > 2) { // 当剩下超过2个运动员时
        n -= 1; // 每轮减少一个运动员
        rounds++; // 回合数增加
        // 如果两个运动员编号之差大于当前运动员数量，说明他们在这一轮会相遇
        if (secondPlayer - firstPlayer > n) {
            break;
        }
    }
    return rounds;
}

// 返回最早和最晚的比拼回合数
int* findEarliestAndLatestRound(int n, int firstPlayer, int secondPlayer, int returnSize) {
    static int result[2];
    result[0] = calculateEarliestRound(n, firstPlayer, secondPlayer);
    result[1] = calculateLatestRound(n, firstPlayer, secondPlayer);
    return result;
}

int main() {
    int n = 11, firstPlayer = 2, secondPlayer = 4;
    int returnSize = 2;
    int* res = findEarliestAndLatestRound(n, firstPlayer, secondPlayer, returnSize);
    printf("最早回合数: %d, 最晚回合数: %d\n", res[0], res[1]);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int minProductSum(int* nums1, int nums1Size, int* nums2, int nums2Size) {
    // 对两个数组进行排序
    qsort(nums1, nums1Size, sizeof(int), compare);
    qsort(nums2, nums2Size, sizeof(int), compare);
    
    // 初始化最小乘积和为第一个元素乘积
    int minProduct = nums1[0] * nums2[0];
    
    // 检查最后一个元素的乘积
    int lastProduct = nums1[nums1Size - 1] * nums2[nums2Size - 1];
    if (lastProduct < minProduct) {
        minProduct = lastProduct;
    }
    
    return minProduct;
}

// 用于qsort的比较函数
int compare(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

int main() {
    int nums1[] = {5, 3, 4, 2};
    int nums2[] = {4, 2, 2, 5};
    printf("%d\n", minProductSum(nums1, sizeof(nums1)/sizeof(nums1[0]), nums2, sizeof(nums2)/sizeof(nums2[0])));
    return 0;
}
#include <math.h>

int twoEggDrop(int n) {
    int l = 1, r = n;
    while (l < r) {
        int mid = l + (r - l) / 2;
        int breaks = mid - 1;
        int works = (n - mid) + (int)ceil((double)breaks / (mid + 1)) + 1;
        if (works <= r) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }
    return l;
}
#include <stdio.h>

// 计算从startTime到finishTime之间，有多少个15分钟的倍数。
int numberOfRounds(char *startTime, char *finishTime) {
    int startHour, startMinute, endHour, endMinute;
    sscanf(startTime, "%d:%d", &startHour, &startMinute);
    sscanf(finishTime, "%d:%d", &endHour, &endMinute);

    // 如果结束时间小于开始时间，表示跨日。
    if (endHour < startHour || (endHour == startHour && endMinute < startMinute)) {
        endHour += 24;
    }

    int totalMinutes = (endHour - startHour) * 60 + endMinute - startMinute;
    // 每个对局15分钟，计算总对局数。
    int fullRounds = totalMinutes / 15;

    // 检查边界情况，确保没有多算。
    if (totalMinutes % 15 > 0 && (endHour == startHour && endMinute > startMinute)) {
        fullRounds++;
    }

    return fullRounds;
}

int main() {
    char startTime[] = "12:01";
    char finishTime[] = "12:44";
    printf("%d\n", numberOfRounds(startTime, finishTime)); // 输出应该是1
    return 0;
}
#include <stdio.h>

// 计算差分数组的函数
void preprocessDiff(int *diff, int *nums, int size) {
    int i;
    for (i = 0; i < size; i++) {
        diff[i] = 0;
    }
    diff[0] = 1;
    for (i = 1; i < size; i++) {
        if (nums[i - 1] <= nums[i]) {
            diff[i] = diff[i - 1] + 1;
        } else {
            diff[i] = diff[i - 1] - 1;
        }
    }
}

// 二分查找差分数组中的最小绝对差值
int binarySearch(int *diff, int target, int size) {
    int left = 0, right = size - 1, result = -1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (diff[mid] >= target) {
            result = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return diff[result];
}

// 计算所有查询结果的函数
int *minAbsoluteDifferenceQueries(int *nums, int numsSize, int **queries, int queriesSize, int *returnSize) {
    // 预处理差分数组
    int *diff = (int *)malloc(numsSize * sizeof(int));
    preprocessDiff(diff, nums, numsSize);

    // 存储结果的数组
    int *result = (int *)malloc(queriesSize * sizeof(int));

    // 处理每个查询
    int i;
    for (i = 0; i < queriesSize; i++) {
        int l = queries[i][0];
        int r = queries[i][1];
        int size = r - l + 1;
        if (size == 1) {
            result[i] = -1; // 单个元素，没有绝对差
        } else {
            // 在差分数组中二分查找
            result[i] = binarySearch(diff + l, size, r - l + 1);
        }
    }

    *returnSize = queriesSize;
    free(diff);
    return result;
}

int main() {
    int nums[] = {1, 3, 4, 8};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int queries[][2] = {{0, 1}, {1, 2}, {2, 3}, {0, 3}};
    int queriesSize = sizeof(queries) / sizeof(queries[0]);
    int returnSize;

    int *result = minAbsoluteDifferenceQueries(nums, numsSize, (int **)queries, queriesSize, &returnSize);

    // 打印结果
    int i;
    for (i = 0; i < returnSize; i++) {
        printf("%d ", result[i]);
    }
    printf("\n");

    free(result);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 定义哈希表结构
typedef struct {
    int *keys;
    int size;
    int count;
} HashTable;

// 初始化哈希表
HashTable *initHashTable(int size) {
    HashTable *table = (HashTable *)malloc(sizeof(HashTable));
    table->size = size;
    table->count = 0;
    table->keys = (int *)malloc(sizeof(int) * size);
    return table;
}

// 哈希函数
unsigned int hash(int key, int size) {
    return key % size;
}

// 插入元素到哈希表
void insert(HashTable *table, int key) {
    unsigned int index = hash(key, table->size);
    while (table->keys[index] != 0 && table->keys[index] != key) {
        index = (index + 1) % table->size; // 线性探测解决冲突
    }
    if (table->keys[index] == 0) {
        table->keys[index] = key;
        table->count++;
    }
}

// 查找元素是否存在于哈希表
int find(HashTable *table, int key) {
    unsigned int index = hash(key, table->size);
    while (table->keys[index] != 0) {
        if (table->keys[index] == key) {
            return 1;
        }
        index = (index + 1) % table->size; // 线性探测解决冲突
    }
    return 0;
}

// 释放哈希表内存
void freeHashTable(HashTable *table) {
    free(table->keys);
    free(table);
}

// 统计数对的函数
int countPairs(int* nums1, int nums1Size, int* nums2, int nums2Size, int value) {
    HashTable *table = initHashTable(nums1Size);
    int count = 0;
    for (int i = 0; i < nums1Size; i++) {
        insert(table, nums1[i]);
    }
    for (int i = 0; i < nums2Size; i++) {
        int complement = value - nums2[i];
        if (find(table, complement)) {
            count++;
        }
    }
    freeHashTable(table);
    return count;
}

int main() {
    int nums1[] = {1, 2, 3};
    int nums2[] = {2, 4, 6};
    int value = 6;
    int result = countPairs(nums1, sizeof(nums1)/sizeof(nums1[0]), nums2, sizeof(nums2)/sizeof(nums2[0]), value);
    printf("Total pairs: %d\n", result);
    return 0;
}
#include <stdio.h>
#include <limits.h>

// 定义图的邻接矩阵
int graph[1001][1001];
// 定义城市通行费数组
int passingFees[1001];
// 定义距离数组，记录从起点到每个状态的最小花费
int dist[1001][1001];

// Dijkstra 算法找到从 (startCity, 0) 到 (endCity, maxTime) 的最小花费
void dijkstra(int n, int maxTime, int startCity, int endCity) {
    int i, j, u, minCost, minTime;
    for (i = 0; i <= n; i++) {
        for (j = 0; j <= maxTime; j++) {
            dist[i][j] = INT_MAX;
        }
    }
    dist[startCity][0] = 0;

    for (j = 0; j <= maxTime; j++) {
        for (i = 0; i < n; i++) {
            if (dist[i][j] == INT_MAX)
                continue;
            for (u = 0; u < n; u++) {
                minCost = dist[i][j] + graph[i][u] + passingFees[u];
                minTime = j + 1;
                if (minCost < dist[u][minTime] && minTime <= maxTime)
                    dist[u][minTime] = minCost;
            }
        }
    }
}

int main() {
    int maxTime = 30;
    int edges[] = {{0,1,10},{1,2,10},{2,5,10},{0,3,1},{3,4,10},{4,5,15}};
    int passingFees[] = {5,1,2,20,20,3};
    int n = 6; // 城市的数量

    // 初始化图的邻接矩阵
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            graph[i][j] = (i == j) ? 0 : INT_MAX;
        }
    }

    // 构建图
    for (int i = 0; i < sizeof(edges) / sizeof(edges[0]); i++) {
        int x = edges[i][0], y = edges[i][1], time = edges[i][2];
        graph[x][y] = time;
        graph[y][x] = time; // 因为是双向道路
    }

    dijkstra(n, maxTime, 0, n - 1);

    // 输出结果
    if (dist[n - 1][maxTime] == INT_MAX)
        printf("-1\n");
    else
        printf("%d\n", dist[n - 1][maxTime]);

    return 0;
}
#include <stdlib.h>
#include <stdio.h>

// 快速排序函数
void quickSort(int* nums, int left, int right) {
    if (left >= right) return;
    int pivot = nums[right];
    int i = left - 1;
    for (int j = left; j < right; j++) {
        if (nums[j] > pivot) {
            i++;
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    }
    int temp = nums[i + 1];
    nums[i + 1] = nums[right];
    nums[right] = temp;
    quickSort(nums, left, i);
    quickSort(nums, i + 2, right);
}

// 割绳子问题的C语言实现
int cuttingRibbons(int* ribbons, int ribbonsSize, int k) {
    if (k == 1) return 0; // 如果只需要一段，不需要切割
    quickSort(ribbons, 0, ribbonsSize - 1); // 对丝带长度进行降序排序
    int cuts = 0;
    int totalLength = 0;
    for (int i = 0; i < ribbonsSize && cuts < k - 1; i++) {
        if (ribbons[i] > 1) { // 如果当前丝带长度大于1，可以切割
            totalLength += ribbons[i]; // 累加当前丝带长度
            ribbons[i] = 1; // 将当前丝带设置为1，表示已经切割
            cuts++; // 切割次数加1
        }
    }
    // 如果切割次数还不够，继续切割剩余的丝带
    for (int i = 0; i < ribbonsSize && cuts < k - 1; i++) {
        totalLength += ribbons[i];
        cuts++;
    }
    return totalLength;
}

int main() {
    int ribbons[] = {9, 7, 5};
    int k = 3;
    int result = cuttingRibbons(ribbons, sizeof(ribbons) / sizeof(ribbons[0]), k);
    printf("The total length of the ribbons after cutting is: %d\n", result);
    return 0;
}
#include <stdio.h>

int* buildArray(int* nums, int numsSize, int* ansSize) {
    // 初始化ans数组的大小
    *ansSize = numsSize;
    int* ans = (int*)malloc(sizeof(int) * numsSize);
    
    // 构建ans数组
    for (int i = 0; i < numsSize; i++) {
        ans[i] = nums[nums[i]]; // 直接按照题目描述构建ans
    }
    
    return ans;
}

int main() {
    int nums[] = {0, 2, 1, 5, 3, 4};
    int ansSize;
    int* ans = buildArray(nums, sizeof(nums) / sizeof(nums[0]), &ansSize);
    
    // 打印结果
    for (int i = 0; i < ansSize; i++) {
        printf("%d ", ans[i]);
    }
    
    // 释放内存
    free(ans);
    
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int dist;
    int speed;
} Monster;

int compare(const void *a, const void *b) {
    double aTime = ((Monster *)a)->dist / ((Monster *)b)->speed;
    double bTime = ((Monster *)b)->dist / ((Monster *)b)->speed;
    return (aTime > bTime) - (aTime < bTime);
}

int eliminateMaxMonsters(int dist[], int speed[], int n) {
    // 创建怪物数组
    Monster monsters[n];
    for (int i = 0; i < n; ++i) {
        monsters[i].dist = dist[i];
        monsters[i].speed = speed[i];
    }

    // 根据到达时间排序
    qsort(monsters, n, sizeof(Monster), compare);

    int count = 0; // 记录消灭的怪物数量
    int time = 0;   // 当前时间
    for (int i = 0; i < n; ++i) {
        // 如果当前怪物到达时间大于时间，则可以消灭
        if ((double)monsters[i].dist / monsters[i].speed > time) {
            count++;
            time++; // 武器充电需要一分钟
        }
    }
    return count;
}

int main() {
    int dist[] = {1, 3, 4};
    int speed[] = {1, 1, 1};
    int n = sizeof(dist) / sizeof(dist[0]);
    printf("Maximum number of monsters that can be eliminated: %d\n", eliminateMaxMonsters(dist, speed, n));
    return 0;
}
#include <stdio.h>

// 定义二叉树的节点结构
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 创建一个新节点
TreeNode* createNode(int val) {
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
    node->val = val;
    node->left = NULL;
    node->right = NULL;
    return node;
}

// 根据BST的插入顺序构建树
TreeNode* buildBST(int* order, int start, int end) {
    if (start > end) return NULL;
    int mid = (start + end) / 2;
    TreeNode* root = createNode(order[mid]);
    root->left = buildBST(order, start, mid - 1);
    root->right = buildBST(order, mid + 1, end);
    return root;
}

// 计算BST的深度
int maxDepthBST(TreeNode* root) {
    if (root == NULL) return 0;
    return 1 + (maxDepthBST(root->left) > maxDepthBST(root->right) ? maxDepthBST(root->left) : maxDepthBST(root->right));
}

int main() {
    int order[] = {2, 1, 4, 3};
    int n = sizeof(order) / sizeof(order[0]);
    TreeNode* root = buildBST(order, 0, n - 1);
    printf("The maximum depth of the BST is: %d\n", maxDepthBST(root));
    return 0;
}
bool areOccurrencesEqual(char *s) {
    int count[26] = {0}; // 记录每个字符的出现次数
    int firstCharOccurrence = 0; // 第一个出现的字符的计数

    // 记录每个字符的出现次数
    for (int i = 0; s[i]; i++) {
        if (count[s[i] - 'a'] == 0) {
            firstCharOccurrence = i; // 记录第一个字符的出现次数
        }
        count[s[i] - 'a']++;
    }

    // 检查所有字符的出现次数是否与第一个出现的字符相同
    for (int i = firstCharOccurrence + 1; s[i]; i++) {
        if (count[s[i] - 'a'] != count[s[firstCharOccurrence] - 'a']) {
            return false;
        }
    }

    return true;
}
#include <stdio.h>
#include <string.h>

int countPalindromicSubsequence(char* s) {
    int len = strlen(s);
    int count = 0;
    int charIndex[26] = {0};

    for (int i = 0; i < len; i++) {
        // 更新字符最后出现的位置
        charIndex[s[i] - 'a'] = i;
        // 两边的字符相同，中间可以是任意字符
        for (int j = 0; j < i; j++) {
            if (s[j] == s[i]) {
                count += (i - j - 1); // 减1是因为回文子序列长度为3，不能包括相同字符的两侧
            }
        }
    }

    // 三个字符都相同，如"aaa"
    for (int i = 0; i < 26; i++) {
        int sameCharCount = 0;
        for (int j = 0; j < len; j++) {
            if (s[j] - 'a' == i) {
                sameCharCount++;
            } else {
                count += (sameCharCount * (sameCharCount - 1) / 2); // 计算连续相同字符的组合
                sameCharCount = 0;
            }
        }
        // 最后一组连续相同字符
        count += (sameCharCount * (sameCharCount - 1) / 2);
    }

    return count;
}

int main() {
    char s[] = "aabca";
    printf("Output: %d\n", countPalindromicSubsequence(s));
    return 0;
}
#include <string.h>

int longestCommonSubsequence(int* nums1, int len1, int* nums2, int len2) {
    // 创建动态规划表格，初始化为0
    int dp[len1+1][len2+1];
    memset(dp, 0, sizeof(dp));

    // 动态规划填表
    for (int i = 1; i <= len1; i++) {
        for (int j = 1; j <= len2; j++) {
            if (nums1[i-1] == nums2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = (dp[i-1][j] > dp[i][j-1]) ? dp[i-1][j] : dp[i][j-1];
            }
        }
    }

    // 返回最终的LCS长度
    return dp[len1][len2];
}
#include <stdio.h>

// 假设Light的结构体定义如下：
typedef struct {
    int x; // 路灯的横坐标
    int y; // 路灯的亮度
} Light;

int brightestPosition(int n, Light lights[], int w) {
    int maxBrightness = 0; // 最大亮度
    int currentSum = 0;    // 当前窗口的亮度和

    // 初始化窗口的起始位置
    int start = 0;
    for (int end = 0; end < n; end++) {
        currentSum += lights[end].y; // 加入当前路灯的亮度

        // 当窗口大小大于街道宽度时，开始移动窗口
        while (end - start + 1 > w) {
            currentSum -= lights[start].y; // 移除左侧路灯的亮度
            start++;
        }

        // 更新最大亮度
        if (currentSum > maxBrightness) {
            maxBrightness = currentSum;
        }
    }

    return maxBrightness;
}

int main() {
    // 示例输入
    int n = 3;
    Light lights[] = {{-3, 2}, {1, 2}, {3, 3}};
    int w = 2;
    printf("The brightest position has a brightness of: %d\n", brightestPosition(n, lights, w));
    return 0;
}
#include <stdio.h>
#include <string.h>

int sumOfLetters(char c) {
    return c - 'a' + 1;
}

int sumOfDigitsOfStringAfterConvert(char *s, int k) {
    int num = 0;
    while (k--) {
        int sum = 0;
        while (*s) {
            num = num * 10 + sumOfLetters(*s++);
        }
        s = &num; // 重置字符串指针
        while (num) {
            sum += num % 10;
            num /= 10;
        }
        num = sum;
    }
    return num;
}

int main() {
    char s[] = "zbax";
    int k = 2;
    printf("Result: %d\n", sumOfDigitsOfStringAfterConvert(s, k));
    return 0;
}
#include <math.h>
bool isThree(int n) {
    int count = 0;
    for (int i = 1; i <= sqrt(n); i++) {
        if (n % i == 0) {
            count++; // i 是一个除数
            if (i != 1 && n / i != i) count++; // n / i 也是除数，且不是 i 自身
        }
    }
    return count == 3;
}
#include <stdio.h>
#include <stdlib.h>

// 比较函数，用于qsort
int compare(const void *a, const void *b) {
    return (*(int*)b - *(int*)a);
}

int numberOfWeeks(int* milestones, int milestonesSize) {
    // 对里程碑进行排序
    qsort(milestones, milestonesSize, sizeof(int), compare);
    
    int weeks = 0;
    int i = 0;
    int lastProject = -1; // 上一个选择的项目索引

    while (i < milestonesSize) {
        // 如果当前项目是上周的项目，尝试选择下一个项目
        while (i < milestonesSize && i == lastProject) {
            i++;
        }
        
        if (i < milestonesSize) {
            // 选择当前最多的项目，减少一个任务，并记录索引
            milestones[i]--;
            lastProject = i;
            weeks++;
        }
    }
    
    return weeks;
}

int main() {
    int milestones[] = {5, 2, 1};
    int n = sizeof(milestones) / sizeof(milestones[0]);
    printf("Maximum number of weeks: %d\n", numberOfWeeks(milestones, n));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MOD 1000000007

// 用于比较两个整数的函数，用于优先队列
int cmp(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);
}

// Dijkstra算法找到从起点到所有其他顶点的最短路径
void dijkstra(int n, int roads[][3], int road_count, int *dist, int start) {
    int i, j;
    for (i = 0; i < n; i++) dist[i] = 1e+18; // 初始化距离为无穷大
    dist[start] = 0;
    int *q = malloc(n * sizeof(int)), *inq = malloc(n * sizeof(int));
    for (i = 0; i < n; i++) q[i] = i, inq[i] = 1;
    qsort(q, n, sizeof(int), cmp);
    while (q[0] != start) {
        int u = q[0];
        for (j = 0; j < road_count; j++) {
            if (!inq[roads[j][1]] && dist[u] + roads[j][2] < dist[roads[j][1]]) {
                dist[roads[j][1]] = dist[u] + roads[j][2];
                qsort(q, n, sizeof(int), cmp);
            }
        }
        inq[u] = 0;
        for (i = 0; i < n; i++)
            if (inq[q[i]]) break;
        if (i == n) break;
        q[0] = q[i];
        for (i = 1; i < n; i++)
            if (!inq[q[i]] && q[i] < q[0]) break;
        for (j = i; j > 0 && !inq[q[j - 1]]; j--) q[j] = q[j - 1];
        q[j] = u;
    }
    free(q);
    free(inq);
}

// 动态规划计算方案数
int countWays(int n, int roads[][3], int road_count) {
    int dist[n], time = 0;
    dijkstra(n, roads, road_count, dist, 0);
    time = dist[n - 1];
    memset(dist, 0, n * sizeof(int));
    dist[time] = 1;
    for (int i = 1; i < time; i++) {
        for (int j = 0; j < road_count; j++) {
            if (dist[i - roads[j][2]] > 0) {
                dist[i + roads[j][2]] = (dist[i + roads[j][2]] + dist[i - roads[j][2]]) % MOD;
            }
        }
    }
    return dist[time];
}

int main() {
    int n = 7;
    int roads[][3] = {{0,6,7},{0,1,2},{1,2,3},{1,3,3},{6,3,3},{3,5,1},{6,5,1},{2,5,1},{0,4,5},{4,6,2}};
    printf("%d\n", countWays(n, roads, 10));
    return 0;
}
#include <stdio.h>
#include <string.h>

int numOfSubstrInWord(char **patterns, int patternsSize, char *word) {
    int count = 0; // 计数器，用于统计子字符串的数量
    for (int i = 0; i < patternsSize; ++i) {
        char *pattern = patterns[i];
        // 使用strstr查找word中是否包含当前pattern
        if (strstr(word, pattern) != NULL) {
            ++count;
        }
    }
    return count;
}

int main() {
    char patterns[][4] = {"a", "abc", "bc", "d"};
    char word[] = "abc";
    int patternsSize = sizeof(patterns) / sizeof(patterns[0]);
    
    int result = numOfSubstrInWord(patterns, patternsSize, word);
    printf("Number of substrings: %d\n", result);
    
    return 0;
}
int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    // 初始化哈希表
    int *hashTable = (int *)malloc(sizeof(int) * numsSize);
    // 存储索引
    int *indices = (int *)malloc(sizeof(int) * 2);

    for (int i = 0; i < numsSize; i++) {
        int complement = target - nums[i];
        if (hashTable[complement] != -1) {
            indices[0] = hashTable[complement];
            indices[1] = i;
            *returnSize = 2;
            return indices;
        } else {
            hashTable[nums[i]] = i;
        }
    }

    // 如果没有找到结果，返回空数组
    *returnSize = 0;
    return NULL;
}
int* averageHeightOfBuildings(int **buildings, int buildingsSize, int *buildingsColSize, int *returnSize) {
    int n = 0;
    for (int i = 0; i < buildingsSize; ++i) {
        n = buildings[i][1] > n ? buildings[i][1] : n;
    }
    int *prefix = (int *)malloc((n + 1) * sizeof(int));
    for (int i = 0; i <= n; ++i) {
        prefix[i] = 0;
    }
    
    for (int i = 0; i < buildingsSize; ++i) {
        int *b = buildings[i];
        prefix[b[0] - 1] += b[2];
        if (b[1] < n) {
            prefix[b[1]] -= b[2];
        }
    }
    
    int *result = (int *)malloc(n * sizeof(int));
    result[0] = prefix[0];
    for (int i = 1; i < n; ++i) {
        prefix[i] += prefix[i - 1];
        result[i] = prefix[i] / (i + 1);
    }
    
    *returnSize = n;
    free(prefix);
    return result;
}
#include <stdio.h>
#include <stdlib.h>

// 定义一个结构体来存储结果
typedef struct {
    int index1;
    int index2;
} TwoSumResult;

TwoSumResult twoSum(int* nums, int numsSize, int target) {
    // 创建哈希表，用于存储已经遍历过的数字及其索引
    int *hashTable = (int *)malloc(sizeof(int) * numsSize);
    for (int i = 0; i < numsSize; ++i) {
        hashTable[i] = -1;
    }

    // 遍历数组
    for (int i = 0; i < numsSize; ++i) {
        int complement = target - nums[i];
        // 在哈希表中查找差值
        int j;
        for (j = 0; j < i; ++j) {
            if (nums[j] == complement) {
                // 找到匹配的数字，返回结果
                return (TwoSumResult){i, j};
            }
        }
        // 未找到匹配，更新哈希表
        hashTable[i] = complement;
    }

    // 如果没有找到结果，返回一个无效的结果
    TwoSumResult result = {-1, -1};
    free(hashTable);
    return result;
}

int main() {
    int nums[] = {2, 7, 11, 15};
    int target = 9;
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    TwoSumResult result = twoSum(nums, numsSize, target);
    printf("Index1: %d, Index2: %d\n", result.index1, result.index2);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int account;
    char day[11]; // 假设日期的最大长度为10
    int amount;
} Transaction;

typedef struct {
    Transaction *transactions;
    int size;
    int capacity;
} AccountBalance;

// 初始化AccountBalance
AccountBalance* accountBalanceCreate() {
    AccountBalance *obj = (AccountBalance *)malloc(sizeof(AccountBalance));
    obj->size = 0;
    obj->capacity = 2; // 初始容量
    obj->transactions = (Transaction *)malloc(obj->capacity * sizeof(Transaction));
    return obj;
}

// 辅助函数，用于在数组中查找交易记录
int findTransaction(AccountBalance *obj, int account, char *day) {
    for (int i = 0; i < obj->size; i++) {
        if (obj->transactions[i].account == account && strcmp(obj->transactions[i].day, day) == 0) {
            return i;
        }
    }
    return -1;
}

// 存款操作
void accountBalanceDeposit(AccountBalance *obj, int account, char *day, int amount) {
    int index = findTransaction(obj, account, day);
    if (index != -1) {
        obj->transactions[index].amount += amount; // 如果已存在，直接增加金额
    } else {
        if (obj->size >= obj->capacity) {
            // 如果数组满了，扩容
            obj->capacity *= 2;
            obj->transactions = (Transaction *)realloc(obj->transactions, obj->capacity * sizeof(Transaction));
        }
        obj->transactions[obj->size].account = account;
        strcpy(obj->transactions[obj->size].day, day);
        obj->transactions[obj->size].amount = amount;
        obj->size++;
    }
}

// 取款操作
void accountBalanceWithdraw(AccountBalance *obj, int account, char *day, int amount) {
    accountBalanceDeposit(obj, account, day, -amount); // 取款可以看作是金额为负的存款操作
}

// 获取余额
int accountBalanceGetBalance(AccountBalance *obj, int account, char *day) {
    int balance = 0;
    for (int i = 0; i < obj->size; i++) {
        if (obj->transactions[i].account == account) {
            balance += obj->transactions[i].amount;
        }
    }
    return balance;
}

// 销毁AccountBalance
void accountBalanceFree(AccountBalance *obj) {
    free(obj->transactions);
    free(obj);
}

// 测试代码
int main() {
    AccountBalance *balance = accountBalanceCreate();
    accountBalanceDeposit(balance, 1, "2021-11-07", 2000);
    accountBalanceWithdraw(balance, 1, "2021-11-09", 1000);
    printf("Balance: %d\n", accountBalanceGetBalance(balance, 1, "2021-11-11")); // 输出余额
    accountBalanceFree(balance);
    return 0;
}
#include <stdio.h>
#include <string.h>

// 函数用于计算子串的字符出现次数
int equalCountSubstrings(char* s) {
    int len = strlen(s);
    int count[256] = {0}; // 用于存储字符出现次数的数组
    int result = 0; // 结果变量

    // 遍历所有可能的子串长度
    for (int sublen = 1; sublen <= len; ++sublen) {
        // 用滑动窗口的方法检查所有子串
        for (int i = 0; i <= len - sublen; ++i) {
            // 初始化哈希表
            memset(count, 0, sizeof(count));
            // 计算当前子串的字符出现次数
            for (int j = i; j < i + sublen; ++j) {
                count[s[j]]++;
            }
            // 检查所有字符的出现次数是否相等
            int equal = 1;
            for (int k = 1; k < 256; ++k) {
                if (count[k] > 0 && (count[k] != count[s[i]])) {
                    equal = 0;
                    break;
                }
            }
            if (equal) {
                result++;
            }
        }
    }
    return result;
}

int main() {
    char s[] = "aaabcbbcc";
    printf("Number of equal count substrings: %d\n", equalCountSubstrings(s));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

#define MAX_MAZE_SIZE 100  // 假设迷宫的最大尺寸为100x100

int maze[MAX_MAZE_SIZE][MAX_MAZE_SIZE];  // 迷宫数组
int visited[MAX_MAZE_SIZE][MAX_MAZE_SIZE];  // 访问状态数组
int dx[] = {-1, 0, 1, 0};  // x方向的移动
int dy[] = {0, 1, 0, -1};  // y方向的移动

// 检查坐标是否在迷宫内
int isInside(int x, int y, int n, int m) {
    return x >= 0 && x < n && y >= 0 && y < m;
}

// 深度优先搜索函数
void dfs(int x, int y, int n, int m, int *roomCount) {
    if (!isInside(x, y, n, m) || maze[x][y] == 1 || visited[x][y]) {
        return;
    }
    visited[x][y] = 1;
    // 检查是否到达房间
    if (x == n - 1 && y == m - 1) {
        (*roomCount)++;
    }
    // 遍历四个方向
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i], ny = y + dy[i];
        dfs(nx, ny, n, m, roomCount);
    }
    visited[x][y] = 0;  // 回溯
}

// 计算迷宫中所有通往相同房间的路径数量
int numberOfPaths(int n, int m, int** corridors, int corridorsSize, int* corridorsItemSize) {
    int roomCount = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (maze[i][j] == 0) {
                dfs(i, j, n, m, &roomCount);
            }
        }
    }
    return roomCount;
}

int main() {
    // 示例输入
    int n = 5;
    int m = 5;
    int corridors[][2] = {{1, 2}, {5, 2}, {4, 1}, {2, 4}, {3, 1}, {3, 4}};
    int corridorsSize = sizeof(corridors) / sizeof(corridors[0]);
    int *corridorItemSizes = (int *)malloc(corridorsSize * sizeof(int));
    for (int i = 0; i < corridorsSize; i++) {
        corridorItemSizes[i] = 2;
    }

    // 初始化迷宫
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            maze[i][j] = 0;
            visited[i][j] = 0;
        }
    }
    // 构建迷宫墙壁
    for (int i = 0; i < corridorsSize; i++) {
        maze[corridors[i][0]][corridors[i][1]] = 1;
    }

    // 计算路径数量
    int result = numberOfPaths(n, m, corridors, corridorsSize, corridorItemSizes);
    printf("Number of paths: %d\n", result);

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 定义一个结构体来存储客户ID和其累计销售额
typedef struct {
    int customer_id;
    int amount;
} Transaction;

// 函数用于统计每月销售额超过amount的客户数量
int countRichCustomers(Transaction* transactions, int transSize, int amount) {
    // 使用哈希表存储客户的累计销售额，这里简化为固定大小数组
    int customerSales[1001] = {0}; // 假设客户ID小于等于1000
    int richCount = 0;

    // 遍历所有交易记录
    for (int i = 0; i < transSize; ++i) {
        // 累加对应客户的销售额
        customerSales[transactions[i].customer_id] += transactions[i].amount;
    }

    // 检查每个客户的累计销售额
    for (int i = 1; i <= 1000; ++i) {
        if (customerSales[i] > amount) {
            // 如果超过指定金额，增加计数
            richCount++;
        }
    }

    return richCount;
}

int main() {
    // 示例交易记录和金额限制
    Transaction transactions[] = {
        {1, 549},
        {1, 834},
        {2, 394},
        {3, 657},
        {3, 257}
    };
    int amount = 1500;
    int transSize = sizeof(transactions) / sizeof(transactions[0]);

    // 调用函数并输出结果
    int result = countRichCustomers(transactions, transSize, amount);
    printf("The number of rich customers is: %d\n", result);

    return 0;
}
#include <stdio.h>
#include <string.h>

// 函数用于计算以相同字母开头和结尾的子串总数
long long numberOfSubstrings(char *s) {
    int len = strlen(s);
    long long count = 0;
    
    // 遍历字符串中的每个字符
    for (int i = 0; i < len; ++i) {
        // 以当前字符为开头，检查后面的字符
        for (int j = i; j < len; ++j) {
            if (s[i] == s[j]) {
                // 如果当前字符与开头字符相同，增加计数
                // 子串长度为 j - i + 1
                count += (j - i + 1);
            }
        }
    }
    return count;
}

int main() {
    char s[] = "abcba"; // 示例字符串
    printf("Number of substrings: %lld\n", numberOfSubstrings(s));
    return 0;
}
#include <stdio.h>

// 定义一个结构体来存储糖果的类型和数量
typedef struct {
    int type;
    int count;
} Candy;

// 比较函数，用于 qsort
int compare(const void *a, const void *b) {
    return ((Candy *)a)->count - ((Candy *)b)->count;
}

int shareCandies(int candies[], int candiesSize, int k) {
    // 创建一个足够大的数组来存储所有可能的糖果类型
    Candy candyList[2001]; // 假设糖果类型不会超过2000种
    int uniqueFlavors = 0;
    
    // 初始化糖果列表
    for (int i = 0; i < candiesSize; i++) {
        int found = 0;
        // 查找是否已经记录了这种糖果
        for (int j = 0; j < uniqueFlavors; j++) {
            if (candyList[j].type == candies[i]) {
                candyList[j].count++;
                found = 1;
                break;
            }
        }
        // 如果没有记录，添加新的糖果类型
        if (!found) {
            candyList[uniqueFlavors].type = candies[i];
            candyList[uniqueFlavors].count = 1;
            uniqueFlavors++;
        }
    }
    
    // 根据糖果的数量进行排序
    qsort(candyList, uniqueFlavors, sizeof(Candy), compare);
    
    // 移除足够多的糖果直到剩下k个
    for (int i = uniqueFlavors - 1; i >= 0 && k > 0; i--) {
        if (candyList[i].count > 1) {
            int shared = candyList[i].count - 1;
            candyList[i].count = 1;
            k -= shared;
        }
    }
    
    // 返回剩下的独特口味数量
    return uniqueFlavors;
}

int main() {
    int candies[] = {1,2,2,3,4,3};
    int k = 3;
    printf("Number of unique flavors after sharing: %d\n", shareCandies(candies, sizeof(candies)/sizeof(int), k));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int minimumDifference(int* nums, int numsSize) {
    // 对数组进行排序
    qsort(nums, numsSize, sizeof(int), compare);

    int n = numsSize / 3;
    long long minDiff = LLONG_MAX;
    long long sumLeft, sumRight;
    int left = 0, right = 2 * n;

    // 使用双指针技术
    while (left < n) {
        // 计算当前两部分的和
        sumLeft = 0;
        for (int i = 0; i < left; ++i) {
            sumLeft += nums[i];
        }
        for (int i = left; i < left + n; ++i) {
            sumLeft += nums[i];
        }

        sumRight = 0;
        for (int i = right; i < right + n; ++i) {
            sumRight += nums[i];
        }

        // 更新最小差值
        minDiff = fmin(minDiff, sumLeft - sumRight);

        // 移动指针
        left++;
        right++;
    }

    return minDiff;
}

// 用于qsort的比较函数
int compare(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

int main() {
    int nums[] = {3,1,2};
    int n = sizeof(nums) / sizeof(nums[0]);
    printf("Minimum Difference: %d\n", minimumDifference(nums, n));
    return 0;
}
```

## 讲解

这段代码首先对输入数组进行排序，然后使用双指针技术来找到最小的和的差值。`qsort`函数是一个标准库函数，用于对数组进行排序，我们提供了一个比较函数`compare`来指定排序的方式。在主循环中，我们计算了以当前左右指针划分的两部分的和，并更新了最小差值。最后，我们返回了计算出的最小差值。

请注意，这个问题的关键在于理解如何通过删除元素来平衡两部分的和，排序和双指针技术是解决这个问题的有效方法。['/home/tong/bin/new_2.py', '-f', './finished.txt']
您好！根据您提供的信息，您似乎正在寻找解决 LeetCode 问题 "2162. 设置时间的最少代价" 的方法。这个问题要求我们找到设置微波炉加热时间到特定秒数的最少代价。具体来说，我们需要考虑移动到不同数字的成本以及输入数字的成本。

首先，我们来审视一下解决这个问题所需的算法和数据结构。这个问题可以通过动态规划或者贪心算法来解决。我们可以将问题分解为以下几个步骤：

1. **理解问题**：我们需要将微波炉的时间设置为特定的秒数，同时最小化操作成本。时间由分钟和秒组成，范围从 0 到 99。

2. **算法设计**：我们可以为每一分钟数计算出达到目标秒数的最少成本。由于分钟数的范围是 0 到 99，我们可以遍历每一种可能的分钟数，然后找到与之对应的最少成本的秒数。

3. **状态定义**：我们可以定义一个二维数组 `dp[min][sec]` 来存储达到 `min` 分钟和 `sec` 秒的最少成本。

4. **状态转移**：对于每一分钟 `m`（0 ≤ m ≤ 99），我们计算所有可能的秒数 `s`（0 ≤ s ≤ 99），并更新 `dp[m][s]`。

5. **初始状态**：`dp[0][0] = 0`，表示初始状态下（0 分 0 秒）不需要任何成本。

6. **边界条件**：注意处理分钟和秒数的边界情况，例如，当目标秒数超过 60 时，我们需要将多出的秒数转换为分钟。

7. **实现**：根据上述逻辑，我们可以编写代码来实现算法。

下面是一个可能的 C 语言实现示例：

```c
int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {
    int minutes = targetSeconds / 60;
    int seconds = targetSeconds % 60;
    int dp[100][100] = {0}; // 存储到达每个分钟和秒数的最少成本

    // 初始化 dp 数组
    for (int m = 0; m < 100; ++m) {
        for (int s = 0; s < 100; ++s) {
            if (m == 0 && s == 0) {
                dp[m][s] = 0;
            } else {
                int cost = INT_MAX;
                for (int digit = 0; digit < 10; ++digit) {
                    int move = (digit == startAt) ? 0 : moveCost;
                    int push = pushCost;
                    if (m == 0) {
                        cost = min(cost, move + push);
                    } else {
                        int prevM = m - 1;
                        int prevCost = dp[prevM][seconds];
                        cost = min(cost, move + push + prevCost);
                    }
                }
                dp[m][s] = cost;
            }
        }
    }

    return dp[minutes][seconds];
}
```

请注意，这个示例是一个简化的版本，可能需要进一步优化以满足所有边界条件和问题要求。希望这个示例能帮助您理解如何解决问题，并为您提供一个良好的起点。如果您有任何具体问题或需要进一步的解释，请随时提问。['/home/tong/bin/new_2.py', '-f', './finished.txt']
您好！作为一名LeetCode讲师，我将为您提供问题的解答和解题思路。根据您提供的问题描述，您需要解决的是LeetCode上的2161号问题：“根据给定数字划分数组”。

这个问题的描述是这样的：给定一个整数数组`nums`和一个整数`pivot`，请你将`nums`重新排列，使得所有小于`pivot`的元素都出现在所有大于`pivot`的元素之前，同时保持等于`pivot`的元素在中间，并且小于和大于`pivot`的元素之间的相对顺序不发生改变。

## 解题思路

1. **双指针法**：使用三个指针`i`, `j`, `k`分别遍历数组，`i`用于记录小于`pivot`的元素，`j`用于记录大于`pivot`的元素，`k`为当前遍历到的元素的索引。
2. **分类存储**：创建两个数组或指针，一个用于存储所有小于`pivot`的元素，另一个用于存储所有大于`pivot`的元素。
3. **原地重组**：在遍历结束后，将小于`pivot`的元素移动到数组的前部，然后将等于`pivot`的元素填充到它们的后面，最后将大于`pivot`的元素放在数组的最后。

## C语言实现

```c
#include <stdio.h>

void partitionArray(int* nums, int numsSize, int pivot) {
    int i = 0, j = 0, k = 0;
    int less = 0, equal = 0, greater = 0;
    
    // 统计小于、等于、大于pivot的元素数量
    for (k = 0; k < numsSize; k++) {
        if (nums[k] < pivot) less++;
        else if (nums[k] > pivot) greater++;
        else equal++;
    }
    
    // 重新排列数组
    for (k = 0; k < numsSize; k++) {
        if (nums[k] < pivot) {
            nums[k] = nums[less];
            nums[less++] = nums[k];
        } else if (nums[k] == pivot) {
            nums[k] = nums[less + equal];
            nums[less + equal++] = nums[k];
        }
    }
}

int main() {
    int nums[] = {9, 12, 5, 10, 14, 3, 10};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int pivot = 10;
    
    partitionArray(nums, numsSize, pivot);
    
    // 输出结果
    for (int i = 0; i < numsSize; i++) {
        printf("%d ", nums[i]);
    }
    
    return 0;
}
```

## 解题步骤详细讲解

1. **初始化**：定义三个指针`i`, `j`, `k`，分别用于记录不同类别的元素，以及当前遍历到的位置。
2. **统计**：通过一次遍历，统计数组中小于、等于、大于`pivot`的元素数量。
3. **重组**：使用三个指针`less`, `equal`, `greater`来记录不同类别元素的当前索引，然后在遍历数组的同时，将元素放到正确的位置。
4. **输出**：最后打印出重新排列后的数组。

这个问题主要考察了数组的操作和双指针技巧，通过有效的分类和原地重组，可以在不使用额外空间的情况下解决问题。希望这个解答和讲解对您有所帮助！如果您有任何其他问题或需要进一步的解释，请随时告诉我。['/home/tong/bin/new_2.py', '-f', './finished.txt']
您好！根据您提供的信息，您正在寻求解决 LeetCode 问题的帮助，特别是编号为 2160 的问题：“拆分数位后四位数字的最小和”。这个问题要求您给定一个四位数，使用它的数位将其拆分为两个新的整数，且这两个整数的和最小。

### 问题描述
给定一个四位数 `num`，请使用 `num` 中的数位，将其拆成两个新的整数 `new1` 和 `new2`。要求 `new1` 和 `new2` 中可以有前导 0，且 `num` 中所有数位都必须使用。

### 示例
- 输入：`num = 2932`
  - 输出：`52`
  - 解释：可能的数对 `[new1, new2]` 为 `[29, 23]`，`[223, 9]` 等。最小和为 `[29, 23]` 的和：`29 + 23 = 52`。

### 提示
- `1000 <= num <= 9999`

### 解题思路
这个问题可以通过贪心算法来解决。我们需要找到一种方式，使得两个新整数的和尽可能小。根据题目的提示，我们可以将最小的两个数位放在十位上，最大的两个数位放在个位上，这样可以得到最小的和。

### C 语言实现
```c
#include <stdio.h>

int minimumSum(int num) {
    int digits[4] = {0}; // 存储 num 的每一位数字
    int i, sum = 0;
    
    // 将 num 的每一位存储到 digits 数组中
    for (i = 0; num > 0; i++) {
        digits[i] = num % 10;
        num /= 10;
    }
    
    // 对 digits 数组进行排序
    for (i = 0; i < 3; i++) {
        for (int j = i + 1; j < 4; j++) {
            if (digits[i] > digits[j]) {
                int temp = digits[i];
                digits[i] = digits[j];
                digits[j] = temp;
            }
        }
    }
    
    // 构造 new1 和 new2 并计算和
    int new1 = digits[0] * 10 + digits[1];
    int new2 = digits[2] * 10 + digits[3];
    sum = new1 + new2;
    
    return sum;
}

int main() {
    int num = 2932;
    printf("The minimum sum is: %d\n", minimumSum(num));
    return 0;
}
```

### 算法分析
- 时间复杂度：O(n^2)，其中 n 为数字的位数。在本问题中，n 固定为 4。
- 空间复杂度：O(1)，因为我们只需要常数级别的额外空间。

希望这个解答能帮助您理解问题并找到解决方案。如果您还有其他问题或需要进一步的帮助，请随时告诉我。['/home/tong/bin/new_2.py', '-f', './finished.txt']
['/home/tong/bin/new_2.py', '-f', './finished.txt']
['/home/tong/bin/new_2.py', '-f', './finished.txt']
['/home/tong/bin/new_2.py', '-f', './finished.txt']
['/home/tong/bin/new_2.py', '-f', './finished.txt']
您好！作为一名LeetCode讲师，我注意到您正在准备技术面试或希望通过解决算法问题提升编程能力。LeetCode是一个极客们非常喜爱的技术成长平台，提供了丰富的编程挑战和算法问题。我的任务是帮助您解决这些问题，提供正确的答案和详细的解题思路。

对于您提出的LeetCode问题“2123. 使矩阵中的 1 互不相邻的最小操作数”，这属于“困难”级别的题目，主要考察的是贪心算法和动态规划的应用。

### 问题描述
给定一个 `m x n` 的矩阵 `grid`，每次操作可以选择任意一个 `1`，并将其变为 `0`。`1` 互不相邻指的是，矩阵中任意两个 `1` 都不相邻（没有共享行或列）。返回使矩阵中的所有 `1` 互不相邻的最小操作数。

### 解题思路
1. **贪心算法**：首先尝试使用贪心算法，从左到右，从上到下遍历矩阵，如果当前元素是 `1` 且其上方或左方的元素也是 `1`，则进行操作将其变为 `0`。
2. **动态规划**：如果贪心算法无法解决问题，考虑使用动态规划。定义状态 `dp[i][j]` 表示在 `(i, j)` 位置的矩阵变为互不相邻的最小操作数。状态转移方程需要考虑当前位置是否为 `1` 以及其上方和左方的状态。

### C语言实现
以下是使用贪心算法的C语言实现示例：

```c
#include <string.h>

int minOperations(int *grid, int gridSize, int *gridColSize) {
    int m = gridSize, n = *gridColSize;
    int dp[m][n] = {0};
    int res = 0;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i * n + j] == 1) {
                if ((i > 0 && dp[i - 1][j] == 1) || (j > 0 && dp[i][j - 1] == 1)) {
                    dp[i][j] = 1;
                    res++;
                }
            }
        }
    }

    return res;
}
```

请注意，这只是一个解题思路的示例，实际的解决方案可能需要根据问题的具体要求进行调整。

### 附加建议
- 在解决问题前，确保您已经掌握了相关的算法和数据结构。
- 尝试多种解决方案，并比较它们的时间和空间复杂度。
- 定期复习和练习，以巩固所学知识。

如果您需要更详细的讲解或有其他问题，欢迎随时提问。祝您在LeetCode的学习和面试准备中取得好成绩！['/home/tong/bin/new_2.py', '-f', './finished.txt']
您好！作为一名LeetCode讲师，我将遵循您的指示，使用中文与您交流，并在讲解前向您问好。接下来，我将根据您提出的问题提供C语言实现的代码答案和详细的讲解，每行代码都需要有注释。

根据您提供的LeetCode问题“2113. 查询删除和添加元素后的数组”，我将提供一个可能的解决方案，并详细讲解每个解决方案的思路和实现步骤。

### 问题描述
给定一个数组`nums`，以及一个查询列表`queries`，每个查询包含两个元素：`val`和`index`。对于每个查询，如果`index`小于数组的长度，我们就将`nums[index]`替换为`val`。如果`index`等于数组长度，我们就将`val`追加到数组的末尾。返回所有操作完成后的数组。

### 解题思路
1. 创建一个与原数组同样大小的数组`result`，用于存放最终结果。
2. 遍历每个查询，根据查询中的`index`和`val`执行操作：
   - 如果`index`小于`nums`的长度，替换`result`中相应位置的元素。
   - 如果`index`等于`nums`的长度，将`val`追加到`result`的末尾。
3. 由于查询可能包含追加操作，所以最终结果数组的大小可能大于原数组。

### C语言实现
```c
#include <stdio.h>

// 定义一个函数用于执行查询操作
void processQuery(int *nums, int *result, int val, int index, int numsSize) {
    if (index < numsSize) {
        result[index] = val; // 替换操作
    } else {
        result[index] = val; // 追加操作
    }
}

// 定义主函数
int* arrayManipulation(int *nums, int numsSize, int *queries, int queriesSize, int *returnSize) {
    // 初始化结果数组
    int *result = (int *)malloc((queriesSize + numsSize) * sizeof(int));
    *returnSize = queriesSize + numsSize; // 设置返回数组的大小

    // 复制原数组到结果数组
    for (int i = 0; i < numsSize; i++) {
        result[i] = nums[i];
    }

    // 处理每个查询
    for (int i = 0; i < queriesSize; i++) {
        processQuery(nums, result, queries[i * 2], queries[i * 2 + 1], numsSize);
    }

    return result;
}

int main() {
    // 示例输入
    int nums[] = {0, 1, 2};
    int queries[][2] = {{5, 1}, {1, 5}, {2, 1}, {2, 8}};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int queriesSize = sizeof(queries) / sizeof(queries[0]) / 2;
    int returnSize = 0;

    // 调用函数并打印结果
    int *result = arrayManipulation(nums, numsSize, (int *)queries, queriesSize, &returnSize);
    for (int i = 0; i < returnSize; i++) {
        printf("%d ", result[i]);
    }
    printf("\n");

    // 释放结果数组
    free(result);

    return 0;
}
#include <stdio.h>

// 比较函数，用于qsort
int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

// 题目要求的函数实现
int countElements(int *nums, int numsSize) {
    // 对数组进行排序
    qsort(nums, numsSize, sizeof(int), compare);
    
    int count = 0; // 初始化计数器
    for (int i = 1; i < numsSize - 1; ++i) { // 从第二个元素开始，到倒数第二个元素结束
        if (nums[i - 1] < nums[i] && nums[i] < nums[i + 1]) { // 检查是否严格介于两个元素之间
            ++count;
        }
    }
    
    return count;
}

int main() {
    int nums[] = {11, 7, 2, 15}; // 示例数组
    int size = sizeof(nums) / sizeof(nums[0]);
    printf("输出: %d\n", countElements(nums, size)); // 调用函数并打印结果
    return 0;
}
#include <stdio.h>

// 假设bucket是一个整型数组，表示每个水桶中的水量
// n是bucket数组的长度
void pourWater(int *buckets, int n) {
    int maxLevel = 0; // 用来记录当前最大的水位
    int minLevel = buckets[0]; // 用来记录当前最小的水位
    int maxIndex = 0; // 最大水位水桶的索引
    int minIndex = 0; // 最小水位水桶的索引

    for (int i = 1; i < n; ++i) {
        if (buckets[i] > buckets[maxIndex]) {
            maxIndex = i;
            maxLevel = buckets[i];
        }
        if (buckets[i] < buckets[minIndex]) {
            minIndex = i;
            minLevel = buckets[i];
        }
    }

    // 模拟倒水过程
    while (maxLevel - minLevel > 1) {
        // 从最大水位的水桶倒水到最小水位的水桶
        buckets[maxIndex] -= (maxLevel - minLevel) / 2;
        buckets[minIndex] += (maxLevel - minLevel) / 2;

        // 更新最大和最小水位及对应的索引
        maxIndex = minIndex = 0;
        maxLevel = buckets[0];
        minLevel = buckets[0];
        for (int i = 1; i < n; ++i) {
            if (buckets[i] > maxLevel) {
                maxLevel = buckets[i];
                maxIndex = i;
            }
            if (buckets[i] < minLevel) {
                minLevel = buckets[i];
                minIndex = i;
            }
        }
    }
}

int main() {
    int buckets[] = {1, 2, 7};
    int n = sizeof(buckets) / sizeof(buckets[0]);
    pourWater(buckets, n);

    // 输出最终的水位分布
    for (int i = 0; i < n; ++i) {
        printf("%d ", buckets[i]);
    }
    return 0;
}
#include <stdio.h>

// 函数用于返回乘以2后的最终值
int findFinalValue(int* nums, int numsSize, int original) {
    int result = original; // 初始化result为original
    while (result <= 1000) { // 确保result不会超过题目给定的限制
        int found = 0; // 标记是否找到result
        for (int i = 0; i < numsSize; i++) {
            if (nums[i] == result) {
                result *= 2; // 找到result，乘以2
                found = 1; // 标记为已找到
                break; // 跳出循环，继续查找新的result
            }
        }
        if (!found) break; // 如果没有找到result，结束循环
    }
    return result; // 返回最终的result
}

int main() {
    int nums[] = {5, 3, 6, 1, 12}; // 示例数组
    int original = 3; // 示例original值
    int result = findFinalValue(nums, sizeof(nums)/sizeof(nums[0]), original); // 调用函数
    printf("The final value is: %d\n", result); // 打印结果
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

char *smallestNumber(int num) {
    int len = 0;
    char *digits = NULL;
    char *result = (char *)malloc(12 * sizeof(char)); // 足够存储36位数

    // 将数字转换为字符串并计算长度
    char numStr[12] = {0};
    sprintf(numStr, "%d", num);
    len = strlen(numStr);

    // 将字符串转换为字符数组
    digits = (char *)malloc(len * sizeof(char));
    for (int i = 0; i < len; ++i) {
        digits[i] = numStr[i];
    }

    // 对字符数组进行排序
    int isNegative = (num < 0);
    if (isNegative) {
        digits[0] = '-'; // 负号保留在最高位
    }
    qsort(&digits[isNegative], len - isNegative, sizeof(char), compare);

    // 重排数字
    for (int i = 0; i < len; ++i) {
        result[i] = digits[i];
    }
    result[len] = '\0'; // 确保字符串正确结束

    free(digits);
    return result;
}

// 比较函数，用于qsort
int compare(const void *a, const void *b) {
    return *(char *)b - *(char *)a;
}

int main() {
    int num = 310;
    printf("Original number: %d\n", num);
    char *minNumber = smallestNumber(num);
    printf("Smallest rearranged number: %s\n", minNumber);
    free(minNumber);
    return 0;
}
int minimumTime(char *s) {
    int n = strlen(s);
    int totalOnes = 0, leftOnes = 0, rightOnes = 0;
    int time = 0;

    // 计算总的'1'的数量
    for (int i = 0; i < n; ++i) {
        if (s[i] == '1') totalOnes++;
    }

    // 使用双指针从两边开始计算
    for (int i = 0; i < n && totalOnes > 0; ++i) {
        if (s[i] == '1') leftOnes++;
        if (s[n - 1 - i] == '1') rightOnes++;

        // 当左右两边的'1'的数量加起来等于总数时，计算时间
        if (leftOnes + rightOnes == totalOnes) {
            time = totalOnes;
            break;
        }
    }

    // 计算中间需要移除的车厢数量
    int middleOnes = totalOnes - leftOnes - rightOnes;

    // 计算总时间
    time += middleOnes * 2; // 中间移除的成本是两端的两倍

    // 优化：如果左边或右边的'0'的数量大于中间的'1'的数量，可以替换为更优的解
    if (leftOnes > middleOnes) {
        time -= middleOnes;
        time += leftOnes;
    }
    if (rightOnes > middleOnes) {
        time -= middleOnes;
        time += rightOnes;
    }

    return time;
}
#include <stdio.h>
#include <stdlib.h>

int minSteps(char* s, char* t) {
    int count[26] = {0}; // 用于存储字符出现次数的数组，索引对应字符的ASCII码减去'a'
    int steps = 0; // 最少操作数

    // 统计字符串s中每个字符的出现次数
    for (int i = 0; s[i] != '\0'; i++) {
        count[s[i] - 'a']++;
    }

    // 统计字符串t中每个字符的出现次数，并计算操作数
    for (int i = 0; t[i] != '\0'; i++) {
        if (count[t[i] - 'a'] > 0) {
            count[t[i] - 'a']--;
        } else {
            steps++; // 如果s中没有该字符，操作数加1
        }
    }

    // 计算还需要添加的字符数
    for (int i = 0; i < 26; i++) {
        steps += count[i];
    }

    return steps;
}

int main() {
    char s[] = "leetcode";
    char t[] = "coats";
    printf("Minimum steps: %d\n", minSteps(s, t));
    return 0;
}
#include <stdio.h>
#include <string.h>

int maxSubsequenceCount(char *text, char *pattern) {
    int n = strlen(text);
    int maxCount = 0;
    int countA = 0, countB = 0;

    for (int i = 0; i < n; i++) {
        if (text[i] == pattern[0]) {
            countA++;
        } else if (text[i] == pattern[1]) {
            countB++;
            maxCount += countA;
        }
    }

    // 最后，countA中可能包含了可以与text末尾的pattern[1]形成子序列的pattern[0]
    maxCount += countA;

    // 由于我们可以在开头或结尾插入一个字符，我们需要检查pattern作为一个整体在开头和结尾的情况
    maxCount = (maxCount > countB) ? maxCount : countB;

    return maxCount;
}

int main() {
    char text[] = "abdcdbc";
    char pattern[] = "ac";
    printf("Maximum number of '%s' subsequences in '%s' is %d\n", pattern, text, maxSubsequenceCount(text, pattern));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int minOperations(int *nums, int numsSize) {
    // 计算数组的初始总和
    long long sum = 0;
    for (int i = 0; i < numsSize; ++i) {
        sum += nums[i];
    }

    // 定义操作次数
    int ops = 0;

    // 当总和大于一半时，继续操作
    while (sum > sum / 2) {
        // 寻找当前数组中最大的元素
        int maxIndex = 0;
        for (int i = 1; i < numsSize; ++i) {
            if (nums[i] > nums[maxIndex]) {
                maxIndex = i;
            }
        }

        // 将最大元素减小一半，并更新总和
        nums[maxIndex] /= 2;
        sum -= nums[maxIndex];

        // 增加操作次数
        ops++;
    }

    return ops;
}

int main() {
    int nums[] = {5, 19, 8, 1};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int result = minOperations(nums, numsSize);
    printf("最少操作次数为: %d\n", result);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 线段树节点结构
typedef struct SegmentTreeNode {
    char character; // 当前节点代表的字符
    int length;     // 当前字符重复的长度
    // 其他可能需要的字段，例如左右子节点指针等
} SegmentTreeNode;

// 线段树的初始化、更新和查询等函数的声明

void initializeSegmentTree(SegmentTreeNode* tree, char* s, int size);
void updateSegmentTree(SegmentTreeNode* tree, int index, char newChar);
int querySegmentTree(SegmentTreeNode* tree, int start, int end);

int* maxRepeating(SegmentTreeNode** tree, char* s, char* queryCharacters, int* queryIndices, int k) {
    int* lengths = (int*)malloc(sizeof(int) * k); // 存储每次查询后的结果
    initializeSegmentTree(*tree, s, strlen(s)); // 初始化线段树

    for (int i = 0; i < k; ++i) {
        updateSegmentTree(*tree, queryIndices[i], queryCharacters[i]); // 更新线段树
        lengths[i] = querySegmentTree(*tree, 0, strlen(s) - 1); // 查询最长重复子字符串长度
    }

    return lengths;
}

int main() {
    char s[] = "babacc";
    char queryCharacters[] = "bcb";
    int queryIndices[] = {1, 3, 3};
    int k = sizeof(queryIndices) / sizeof(queryIndices[0]);
    SegmentTreeNode* tree = NULL;

    int* result = maxRepeating(&tree, s, queryCharacters, queryIndices, k);

    // 打印结果
    for (int i = 0; i < k; ++i) {
        printf("%d ", result[i]);
    }
    printf("\n");

    // 释放线段树内存
    // ...

    free(result);
    return 0;
}
#include <stdio.h>

int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int* findKDistantIndices(int* nums, int numsSize, int key, int k, int* returnSize) {
    int* result = malloc(numsSize * sizeof(int)); // 存储结果的数组
    *returnSize = 0; // 结果数组的当前大小

    // 遍历数组，记录等于key的元素下标
    for (int i = 0; i < numsSize; ++i) {
        if (nums[i] == key) {
            // 检查并添加符合条件的下标
            for (int j = i - k; j <= i + k; ++j) {
                if (j >= 0 && j < numsSize && (j != i)) {
                    result[*returnSize] = j; // 添加邻居下标
                    (*returnSize)++;
                }
            }
        }
    }

    // 去除重复的下标
    qsort(result, *returnSize, sizeof(int), compare);
    int uniqueIndex = 0;
    for (int i = 1; i < *returnSize; ++i) {
        if (result[i] != result[uniqueIndex]) {
            result[++uniqueIndex] = result[i];
        }
    }
    *returnSize = uniqueIndex + 1;

    return result;
}
int numberOfWays(char *s) {
    int n = strlen(s);
    int dp[3][2] = {0}; // dp[i][j] 表示前i栋楼中，以第j类建筑结尾的合法方案数
    dp[0][0] = dp[0][1] = 1; // 基础情况，只有一种建筑类型时的方案数

    for (int i = 1; i < n; ++i) {
        // 转移方程，根据当前楼的类型更新方案数
        dp[i][0] = dp[i - 1][1]; // 0结尾的方案数等于1结尾的方案数
        dp[i][1] = dp[i - 1][0] + (s[i - 1] == '0' ? dp[i - 1][1] : 0);
    }

    // 最后一个数字可以是0或1，所以总方案数是两者之和
    return dp[n - 1][0] + dp[n - 1][1];
}
#include <stdio.h>
#include <string.h>

int sumScoresOfBuiltString(char *s) {
    int len = strlen(s);
    int score = 0;
    // 用于存储每个si的最长公共前缀长度
    int prefix[len + 1];

    // 初始化前缀数组，所有si的最长公共前缀都是1
    for (int i = 0; i < len; i++) {
        prefix[i] = 1;
    }
    prefix[len] = 0; // sn的得分是0

    // 从后向前遍历字符串，计算每个si的最长公共前缀
    for (int i = len - 1; i > 0; i--) {
        // 如果当前字符与后面的字符相同，则公共前缀加1
        if (s[i] == s[i - 1]) {
            prefix[i - 1] = prefix[i] + 1;
        }
        // 否则，公共前缀重置为1
        else {
            prefix[i - 1] = 1;
        }
    }

    // 累加每个si的得分
    for (int i = 0; i < len; i++) {
        score += prefix[i];
    }

    return score;
}

int main() {
    char s[] = "babab";
    printf("The sum of scores is: %d\n", sumScoresOfBuiltString(s));
    return 0;
}
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// 定义矩阵中的一个点
typedef struct {
    int x; // 行
    int y; // 列
} Point;

// 广度优先搜索
int minStepToExtractMantra(char** matrix, int rows, int cols, char* mantra) {
    // 如果矩阵为空或者咒语为空，直接返回-1
    if (rows == 0 || cols == 0 || mantra == NULL) return -1;

    // 初始化队列和访问集合
    Point* queue = (Point*)malloc(sizeof(Point) * (rows * cols));
    int head = 0, tail = 0;
    int* visited = (int*)calloc(rows * cols, sizeof(int)); // 0 表示未访问，1 表示已访问

    // 将起点加入队列
    queue[tail++] = (Point){0, 0};
    visited[0] = 1;
    int step = 0; // 记录步数

    while (head < tail) {
        // 队列中的元素数量
        int queueSize = tail - head;
        for (int i = 0; i < queueSize; ++i) {
            Point curr = queue[head++];

            // 检查当前点的字符是否与咒语的当前字符匹配
            if (mantra[step] == matrix[curr.x][curr.y]) {
                // 如果是咒语的最后一个字符，返回步数
                if (step == strlen(mantra) - 1) {
                    free(queue);
                    free(visited);
                    return step + 1;
                }
                step++;
            } else {
                // 如果不匹配，继续搜索
                continue;
            }

            // 检查上下左右四个方向
            int dx[] = {-1, 0, 1, 0};
            int dy[] = {0, 1, 0, -1};
            for (int j = 0; j < 4; ++j) {
                int nx = curr.x + dx[j];
                int ny = curr.y + dy[j];
                // 检查新位置是否在矩阵内，并且未被访问过
                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && !visited[nx * cols + ny]) {
                    queue[tail++] = (Point){nx, ny};
                    visited[nx * cols + ny] = 1;
                }
            }
        }
    }

    free(queue);
    free(visited);
    return -1; // 如果没有找到完整的路径，返回-1
}

int main() {
    char matrix[2][2] = {{'s', 'd'}, {'e', 'p'}};
    char* mantra = "speed";
    printf("Minimum steps: %d\n", minStepToExtractMantra(matrix, 2, 2, mantra));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int maxRunes(int* runes, int runesSize) {
    // 对符文数组进行排序
    int i, j, temp;
    for (i = 0; i < runesSize - 1; i++) {
        for (j = 0; j < runesSize - 1 - i; j++) {
            if (runes[j] > runes[j + 1]) {
                temp = runes[j];
                runes[j] = runes[j + 1];
                runes[j + 1] = temp;
            }
        }
    }

    int count = 0, left = 0, right = 1;
    while (right < runesSize) {
        if (runes[right] == runes[left] || runes[right] == runes[left] + 1) {
            count++; // 符合条件的符文数量加1
            right++;  // 右指针向右移动
        } else {
            left = right; // 左指针移动到右指针的位置
        }
    }
    return count;
}

int main() {
    int runes[] = {1, 3, 5, 4, 1, 7};
    int runesSize = sizeof(runes) / sizeof(runes[0]);
    printf("最大符文数量: %d\n", maxRunes(runes, runesSize));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int maxBlessing(int **forceField, int forceFieldSize, int *forceFieldColSize) {
    int maxSide = 0;
    for (int i = 0; i < forceFieldSize; ++i) {
        maxSide = maxSide < forceField[i][2] ? forceField[i][2] : maxSide;
    }
    
    int **count = (int **)malloc((maxSide * 2 + 1) * sizeof(int *));
    for (int i = 0; i <= maxSide * 2; ++i) {
        count[i] = (int *)calloc(maxSide * 2 + 1, sizeof(int));
    }
    
    for (int i = 0; i < forceFieldSize; ++i) {
        int x = forceField[i][0], y = forceField[i][1], side = forceField[i][2];
        for (int dx = -side; dx <= side; ++dx) {
            for (int dy = -side; dy <= side; ++dy) {
                count[x + dx][y + dy]++;
            }
        }
    }
    
    int maxCount = 0;
    for (int i = 0; i <= maxSide * 2; ++i) {
        for (int j = 0; j <= maxSide * 2; ++j) {
            maxCount = maxCount > count[i][j] ? maxCount : count[i][j];
        }
    }
    
    for (int i = 0; i <= maxSide * 2; ++i) {
        free(count[i]);
    }
    free(count);
    
    return maxCount;
}

int main() {
    int forceField[][3] = {{0, 0, 1}, {1, 0, 1}};
    int forceFieldSize = sizeof(forceField) / sizeof(forceField[0]);
    printf("%d\n", maxBlessing(forceField, forceFieldSize, NULL));
    return 0;
}
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int findMaxNewCampsites(char **expeditions, int expeditionsSize) {
    // 创建哈希表存储访问过的营地
    int visited[26] = {0}; // 假设营地名称只包含小写字母
    int maxNewCampsites = 0;
    int index = -1;
    
    for (int i = 0; i < expeditionsSize; i++) {
        int newCampsites = 0;
        char *campsite = strtok(expeditions[i], "->");
        while (campsite) {
            if (!visited[campsite[0] - 'a']) { // 检查是否新发现的营地
                newCampsites++;
                visited[campsite[0] - 'a'] = 1;
            }
            campsite = strtok(NULL, "->");
        }
        // 更新最大新发现营地数和索引
        if (newCampsites > maxNewCampsites) {
            maxNewCampsites = newCampsites;
            index = i;
        }
    }
    
    return maxNewCampsites ? index : -1;
}

int main() {
    // 示例输入
    char *expeditions[] = {"leet->code", "leet->code->Campsite->Leet", "leet->code->leet->courier"};
    int n = sizeof(expeditions) / sizeof(expeditions[0]);
    // 调用函数并输出结果
    printf("%d\n", findMaxNewCampsites(expeditions, n));
    return 0;
}
#include <stdio.h>

void merge(int* supplies, int first, int second) {
    supplies[first] = supplies[first] + supplies[second];
    // 合并后，删除原第二辆马车的物资记录
    // 由于C语言数组不能动态调整大小，我们简单地覆盖第二辆车的物资
    // 并在后面的操作中忽略它。
}

int* mergeSupplies(int* supplies, int suppliesSize, int* returnSize) {
    int length = suppliesSize;
    int* result = (int*)malloc(length * sizeof(int));
    *returnSize = length;

    while (length > ((length + 1) / 2)) {
        int minSum = supplies[0] + supplies[1];
        int mergeIndex = 0;
        for (int i = 1; i < length - 1; i++) {
            if (supplies[i] + supplies[i + 1] < minSum) {
                minSum = supplies[i] + supplies[i + 1];
                mergeIndex = i;
            }
        }
        merge(supplies, mergeIndex, mergeIndex + 1);
        length--;
    }

    for (int i = 0; i < length; i++) {
        result[i] = supplies[i];
    }
    return result;
}

int main() {
    int supplies[] = {7, 3, 6, 1, 8};
    int returnSize;
    int* result = mergeSupplies(supplies, sizeof(supplies) / sizeof(supplies[0]), &returnSize);

    for (int i = 0; i < returnSize; i++) {
        printf("%d ", result[i]);
    }
    printf("\n");

    free(result);
    return 0;
}
#include <stdio.h>

void merge(int* supplies, int first, int second) {
    supplies[first] = supplies[first] + supplies[second];
    // 合并后，删除原第二辆马车的物资记录
    // 由于C语言数组不能动态调整大小，我们简单地覆盖第二辆车的物资
    // 并在后面的操作中忽略它。
}

int* mergeSupplies(int* supplies, int suppliesSize, int* returnSize) {
    int length = suppliesSize;
    int* result = (int*)malloc(length * sizeof(int));
    *returnSize = length;

    while (length > ((length + 1) / 2)) {
        int minSum = supplies[0] + supplies[1];
        int mergeIndex = 0;
        for (int i = 1; i < length - 1; i++) {
            if (supplies[i] + supplies[i + 1] < minSum) {
                minSum = supplies[i] + supplies[i + 1];
                mergeIndex = i;
            }
        }
        merge(supplies, mergeIndex, mergeIndex + 1);
        length--;
    }

    for (int i = 0; i < length; i++) {
        result[i] = supplies[i];
    }
    return result;
}

int main() {
    int supplies[] = {7, 3, 6, 1, 8};
    int returnSize;
    int* result = mergeSupplies(supplies, sizeof(supplies) / sizeof(supplies[0]), &returnSize);

    for (int i = 0; i < returnSize; i++) {
        printf("%d ", result[i]);
    }
    printf("\n");

    free(result);
    return 0;
}
#include <stdlib.h>

// 定义三角形的结构体
typedef struct Triangle {
    int x, y;
} Triangle;

int** sandyLandManagement(int size, int* returnSize) {
    // 分配内存给返回的二维数组
    int** res = (int**)malloc(sizeof(int*) * size);
    *returnSize = size;
    for (int i = 0; i < size; i++) {
        res[i] = (int*)malloc(sizeof(int) * (2 * i + 1));
    }

    // 从底部开始种植
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < 2 * i + 1; j++) {
            // 每隔一棵树种植一棵
            if (j % 2 == 0) {
                res[i][j] = 1;
            }
        }
    }

    return res;
}
#include <stdio.h>
#include <string.h>

int minCost(char **words, int wordsSize) {
    // 存储每个字母出现的次数和位置
    int count[26] = {0};
    int positions[26][50]; // 假设每个字母最多出现在50个位置
    int minCost = 0;
    char target[] = "helloleetcode";
    int targetLen = strlen(target);

    // 记录每个字母出现的次数和位置
    for (int i = 0; i < wordsSize; ++i) {
        for (int j = 0; words[i][j]; ++j) {
            if (count[target[targetLen - words[i][j] - 'a']] < 50) {
                positions[target[targetLen - words[i][j] - 'a']][count[target[targetLen - words[i][j] - 'a']]] = j;
            }
            count[target[targetLen - words[i][j] - 'a']]++;
        }
    }

    // 计算取得所有字母的最少代币消耗
    for (int i = 0; i < targetLen; ++i) {
        int current = target[i] - 'a';
        // 选择消耗最小的字母位置
        for (int j = 0; j < count[current]; ++j) {
            if (j * (count[current] - j - 1) < minCost) {
                minCost = j * (count[current] - j - 1);
            }
        }
    }

    return minCost > 0 ? minCost : -1; // 如果无法取得所有字母，则返回-1
}

int main() {
    char *words[] = {"hello", "leetcode"};
    int wordsSize = sizeof(words) / sizeof(words[0]);
    printf("Minimum cost: %d\n", minCost(words, wordsSize));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// 定义二叉树的节点结构
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 创建一个新的树节点
TreeNode* createNode(int val) {
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
    node->val = val;
    node->left = NULL;
    node->right = NULL;
    return node;
}

// 装饰树的递归函数
TreeNode* decorateTree(TreeNode* node) {
    if (node == NULL) return NULL;
    
    // 创建两个-1节点，分别作为当前节点的左右子节点
    TreeNode* leftNegativeOne = createNode(-1);
    TreeNode* rightNegativeOne = createNode(-1);
    
    // 递归地装饰当前节点的左右子树
    leftNegativeOne->left = decorateTree(node->left);
    rightNegativeOne->right = decorateTree(node->right);
    
    // 将-1节点连接到当前节点，并返回当前节点
    node->left = leftNegativeOne;
    node->right = rightNegativeOne;
    
    return node;
}

int main() {
    // 构建示例中的二叉树
    TreeNode* root = createNode(7);
    root->left = createNode(5);
    root->right = createNode(6);
    root->left->left = createNode(3);
    root->left->right = createNode(8);
    root->right->left = createNode(4);
    
    // 装饰二叉树
    root = decorateTree(root);
    
    // 打印装饰后的二叉树
    // 这里需要一个辅助函数来遍历和打印二叉树，此处省略实现细节
    
    return 0;
}
#include <stdio.h>
#include <string.h>

// 假设展台类型的数量不会超过26个小写字母
#define MAX_TYPE 26

int minNumBooths(char **demand, int demandSize) {
    int boothCount = 0; // 展台数量计数器
    int typeCount[MAX_TYPE] = {0}; // 记录每个展台类型的出现次数

    for (int i = 0; i < demandSize; i++) {
        char *day = demand[i];
        // 重置当天展台类型出现次数
        memset(typeCount, 0, sizeof(typeCount));
        for (int j = 0; j < strlen(day); j++) {
            int index = day[j] - 'a'; // 计算展台类型在数组中的索引
            if (typeCount[index] == 0) {
                // 如果该类型展台尚未记录，则增加展台数量计数器
                boothCount++;
                typeCount[index] = 1; // 标记该展台类型已记录
            }
        }
    }

    return boothCount;
}

int main() {
    // 示例输入
    char *demand1[] = {"acd", "bed", "accd"};
    int size1 = sizeof(demand1) / sizeof(demand1[0]);
    printf("Minimum number of booths: %d\n", minNumBooths(demand1, size1));

    // 第二个示例
    char *demand2[] = {"abc", "ab", "ac", "b"};
    int size2 = sizeof(demand2) / sizeof(demand2[0]);
    printf("Minimum number of booths: %d\n", minNumBooths(demand2, size2));

    return 0;
}
#include <stdio.h>
#include <string.h>

// 假设展台类型的数量不会超过26个小写字母
#define MAX_TYPE 26

int minNumBooths(char **demand, int demandSize) {
    int boothCount = 0; // 展台数量计数器
    int typeCount[MAX_TYPE] = {0}; // 记录每个展台类型的出现次数

    for (int i = 0; i < demandSize; i++) {
        char *day = demand[i];
        // 重置当天展台类型出现次数
        memset(typeCount, 0, sizeof(typeCount));
        for (int j = 0; j < strlen(day); j++) {
            int index = day[j] - 'a'; // 计算展台类型在数组中的索引
            if (typeCount[index] == 0) {
                // 如果该类型展台尚未记录，则增加展台数量计数器
                boothCount++;
                typeCount[index] = 1; // 标记该展台类型已记录
            }
        }
    }

    return boothCount;
}

int main() {
    // 示例输入
    char *demand1[] = {"acd", "bed", "accd"};
    int size1 = sizeof(demand1) / sizeof(demand1[0]);
    printf("Minimum number of booths: %d\n", minNumBooths(demand1, size1));

    // 第二个示例
    char *demand2[] = {"abc", "ab", "ac", "b"};
    int size2 = sizeof(demand2) / sizeof(demand2[0]);
    printf("Minimum number of booths: %d\n", minNumBooths(demand2, size2));

    return 0;
}
