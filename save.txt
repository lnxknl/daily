#include "led.h"
#include "delay.h"
#include "sys.h"
#include "usart.h"
#include "oled.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "scan.h"
extern u8 hum_set,Is_Ture;
u8 out_state[3];

/*
         1.ÏÔÊ¾ÈýÂ·³¬Éù²¨µÄ¾àÀë
         2.µÚ¶þÆÁÄ»ÉèÖÃ ±¨¾¯¾àÀë
*/
void Targ_GPIO()
{
    GPIO_InitTypeDef  GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_10|GPIO_Pin_1;	 //PD3,PD6ÍÆÍìÊä³ö  
 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //ÍÆÍìÊä³ö
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//ËÙ¶È50MHz
 	GPIO_Init(GPIOB, &GPIO_InitStructure);	  //³õÊ¼»¯GPIOD3,6
    
 	GPIO_ResetBits(GPIOB,GPIO_Pin_0|GPIO_Pin_10|GPIO_Pin_1);	//PD3,PD6 Êä³ö¸ß
}
extern volatile u8  TIM4_CAPTURE_STA,state;	//ÊäÈë²¶»ñ×´Ì¬		    				
extern volatile u16 TIM4_CAPTURE_VAL;	//ÊäÈë²¶»ñÖµ
float distance_circulate(u32 date,u8 state) //¼ÆËã¾àÀë,dis=340m/s*Ê±¼ä/2
{
    float dis;
    if(state>0xc1) //³¬³ö·¶Î§,²»¼ÆËã
        state=0xc1;
    date+=(state-0xc0)*65535; //¼ÆËãÒç³öµÄÊ±¼ä,³¬³ö·¶Î§,²»¼ÆËã
    date/=2;
    dis=(date*340)/10000.0;
    return dis;
}
u8 dis_warn(float warn,u8 dis)
{
  if((u8)warn<dis)
  {
    TIM_Cmd(TIM2,ENABLE);
    TIM2->PSC=719;
    
      if((u8)warn+2<dis)
       TIM2->PSC=366;
    if((u8)warn+5<dis)
        TIM2->PSC=71;
    return 1;
  }
  return 0;
}
 int main(void) //Ö÷º¯Êý
 { 
    u32 distance[3];
    float dis_save[3];
     float dis_temp;
    u8 distance_warning=10;
	volatile u8 Key_vaule,num_pos=0;
    
	u8 buf[20],buf1[20],Is_distance_set=0,Heart_bit; //
	delay_init();	    	 //ÑÓÊ±º¯Êý³õÊ¼»¯	  
	TIM4_Cap_Init(0xffff,71);
    
  //  TIM4_Int_Init(0xffff,71);
    Key_GPIO_Init();  // PA 0-7
     
   // TIM4_Cap_Init(0xffff,71);          //ÈýÂ·³¬Éù²¨³õÊ¼»¯ PB 7-9
     OLED_Init();  //oled³¬ÊæÊÊ»¯  PB 3,4,5,6
    Targ_GPIO();
	memset(buf,0,16);
    memset(buf1,0,16);
    TIME_INIT(); 
    TIM_Cmd(TIM4,ENABLE ); 	//Ê¹ÄÜ¶¨Ê±Æ÷2
	while(1)
	{
      Key_vaule=Key_Scan(); //°´¼üÉ¨Ãè
        
       if(Heart_bit>100) //³¬Éù²¨²â¾à,Ã¿100ms²âÒ»´Î
       {
          
 
            state=1;
            PBout(0)=1;
            delay_us(30);
            PBout(0)=0;
            TIM4_CAPTURE_VAL=0;
            while(TIM4_CAPTURE_STA<0xc0);
           out_state[0]=TIM4_CAPTURE_STA;
            distance[0]=TIM4_CAPTURE_VAL;
            TIM4_CAPTURE_STA=0; //ÖØÖÃ±êÖ¾Î»
            state=2;
            PBout(1)=1;
            delay_us(30);
            PBout(1)=0;
            TIM4_CAPTURE_VAL=0;
            while(TIM4_CAPTURE_STA<0xc0);
           out_state[1]=TIM4_CAPTURE_STA;
            distance[1]=TIM4_CAPTURE_VAL;
            TIM4_CAPTURE_STA=0;  //ÖØÖÃ±êÖ¾Î»
            state=3;
            PBout(10)=1;
            delay_us(30);
            PBout(10)=0;
            TIM4_CAPTURE_VAL=0;
           while(TIM4_CAPTURE_STA<0xc0);
           out_state[2]=TIM4_CAPTURE_STA;
           distance[2]=TIM4_CAPTURE_VAL;
           TIM4_CAPTURE_STA=0;  //ÖØÖÃ±êÖ¾Î»
       }
      if(Key_vaule=='A') //°´¼üA,ÉèÖÃ¾àÀë 
      {
        Is_distance_set=1;
        OLED_Clear();//ÇåÆÁ ÏÔÊ¾ÉèÖÃµÄ¾àÀë
        OLED_ShowString(5,0,"setting/cm");      
        OLED_Refresh_Gram();	 
          
      }
      if(Key_vaule>='0'&&Key_vaule<='9'&&Is_distance_set==1)
      {
        buf[num_pos++]=Key_vaule;
        OLED_ShowString(5,20,buf);  //ÏÔÊ¾°´¼ü
        OLED_Refresh_Gram();
        if(num_pos>3)
            num_pos=0;
      }
      if(Key_vaule=='#'&&(Is_distance_set==1))  //ÉèÖÃ¾àÀë
      {
        Is_distance_set=0; //ÉèÖÃÍê³É,Ìø³ö
        if(strlen(buf)>0)
            distance_warning=atoi(buf);
        memset(buf,0,10);
        delay_ms(1000);
        OLED_Clear();
        Heart_bit=111;  //ÎªÁËµÈÏÂÄÜ¿ìËÙ¿´µ½¾àÀë
      }
     
      
     if(Heart_bit>100&&(Is_distance_set==0)) //³¬Éù²¨²â¾à,Ã¿100ms²âÒ»´Î,²¢ÏÔÊ¾,²¢ÇÒÅÐ¶ÏÊÇ·ñ±¨¾¯
     {
        Heart_bit=0;
         sprintf(buf1,"CH1:%.1f cm",dis_save[0]=distance_circulate(distance[0],out_state[0]));               //²âÁ¿¾àÀë
         OLED_ShowString(5,0,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
         sprintf(buf1,"CH2:%.1f cm",dis_save[1]=distance_circulate(distance[1],out_state[1]));               //²âÁ¿¾àÀë
         OLED_ShowString(5,16,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
         sprintf(buf1,"CH3:%.1f cm",dis_save[2]=distance_circulate(distance[2],out_state[2]));               //²âÁ¿¾àÀë
         OLED_ShowString(5,32,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
     }
     /*-----------------Èý¸öµÈ¼¶----------------------*/
     if(dis_save[0]<distance_warning||dis_save[1]<distance_warning||dis_save[2]<distance_warning)
     {
        dis_warn(dis_save[0],distance_warning);
        dis_warn(dis_save[1],distance_warning);
        dis_warn(dis_save[2],distance_warning);
     }else{
     TIM_Cmd(TIM2,DISABLE);  //DISABLE
     }
//     dis_temp=0;
//     dis_temp+=dis_save[0];
//     dis_temp+=dis_save[1];
//     dis_temp+=dis_save[2];
//     if((int)dis_temp<distance_warning*3)
//     {
//        TIM_Cmd(TIM2,ENABLE);
//        if((int)dis_temp<(distance_warning*3-20))
//         TIM2->PSC=199;
//        if((int)dis_temp<(distance_warning*3-30))
//         TIM2->PSC=71;
//     }else
//     {
//     
//      TIM_Cmd(TIM2,DISABLE);  //DISABLE
//     }
     Heart_bit++;
     delay_ms(10);   
    }
    
}
//TIM_SetCompare2(TIM1,light_table[pre_t][1]);
#include "delay.h"
#include "sys.h"
#include "usart.h"
#include "timer.h"
#include "led.h"
#include "key.h"

#define LAMP_ON   1
#define LAMP_OFF  0

void bsp_init(void);
int main(void)
{
	bsp_init();
	 
	while(1)
	{
		if(IO_LIGHT == 1) //Èõ¹â
		{
			if(IO_MAN  == 1|| IO_SOUND == 1)
			{
				sendMsgTout1 = 5000; //10s
				if(!IO_LAMP)
					IO_LAMP = LAMP_ON;
			}
		}
		else
		{
			if(IO_LAMP)
					IO_LAMP = LAMP_OFF;
		}
		
		if(sendMsgTout1 == 0) 
		{
			if(IO_LAMP)
				IO_LAMP = LAMP_OFF; //¹ØµÆ
		}
	}
}

void bsp_init(void)
{
	delay_init();	    	 //ÑÓÊ±º¯Êý³õÊ¼»¯	  
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//ÉèÖÃÖÐ¶ÏÓÅÏÈ¼¶·Ö×éÎª×é2£º2Î»ÇÀÕ¼ÓÅÏÈ¼¶£¬2Î»ÏìÓ¦ÓÅÏÈ¼¶
	TIM3_Int_Init(9,7199);//10KhzµÄ¼ÆÊýÆµÂÊ£¬¼ÆÊýµ½9,1ms½øÈëÒ»´ÎÖÐ¶Ï
	uart_init(9600);	 	//´®¿Ú³õÊ¼»¯Îª115200	 	
	IO_Init();
}


#include "stm32f10x.h"
#include "led.h"
#include "delay.h"
#include "key.h"
#include "usart.h"
#include <string.h>
#include <stdio.h>
#include <w25q128.h>
#include <lcd.h>
#include "sd.h" //SD¿¨
#include "ff.h" //ÎÄ¼þÏµÍ³
#include "vs1053b.h"
#include "exti.h"
#include "rtc.h"
#include "timer.h"
u8 ScanVSFile(const char *path);
/*
°´¼ü1 ¿ªÊ¼Â¼Òô
°´¼ü2 ½áÊøÂ¼Òô
°´¼ü3 ²¥·ÅÒôÆµ
*/
FATFS fs;  // ÓÃ»§¶¨ÒåµÄÎÄ¼þÏµÍ³½á¹¹Ìå
u8 RecoderPlay(u8 *file_name);
u8 VS1053_PlayOneMusic(u8 *pname);
u8 *VS1053_FileBuff[10];
u32  VS_Cnt=0;
int main()
{
		        //ÎÄ¼þÊýÁ¿	
	char clock_buff[1024];	//´æ·ÅÊ±¼ä×Ö·û´®
	u8 key;
	u32 sd_size;    //´æ·ÅSD¿¨·µ»ØµÄÈÝÁ¿
	BeepInit();		  //·äÃùÆ÷³õÊ¼»¯
	LedInit();      //LEDµÆ³õÊ¼»¯ 
	UsartInit(USART1,72,115200);
	KeyInit();     //°´¼ü³õÊ¼»¯
	W25Q128_Init();
	LcdInit();
	EXTI0_Init();
	TIMx_Init(TIM2,72,20000);//20ms
	RTC_Init();
	LCD_Clear(WHITE);
	
	NT35310_LCD_ShowString(0,0,16,(u8*)"´®¿Ú¹¤×÷Õý³£!");
	if(SDCardDeviceInit()) {NT35310_LCD_ShowString(0,16,16,(u8*)"SD¿¨³õÊ¼»¯Ê§°Ü!");}
	else {NT35310_LCD_ShowString(0,16,16,(u8*)"SD¿¨³õÊ¼»¯³É¹¦!");}
	sd_size=GetSDCardSectorCount();	//¼ì²âSD¿¨´óÐ¡£¬·µ»ØÖµÓÒÒÆ11Î»µÃµ½ÒÔMÎªµ¥Î»µÄÈÝÁ¿
	sprintf(clock_buff,"SD¿¨ÈÝÁ¿:%d MB",sd_size>>11);
	NT35310_LCD_ShowString(0,32,16,(u8*)clock_buff);
	
  if(f_mount(&fs,"0:",1)==FR_OK)NT35310_LCD_ShowString(0,48,16,(u8*)"ÎÄ¼þÏµÍ³³õÊ¼»¯³É¹¦!");  // ×¢²áÎÄ¼þÏµÍ³¹¤×÷Çø£¬Çý¶¯Æ÷ºÅ 0£¬³õÊ¼»¯ºóÆäËûº¯Êý¿ÉÊ¹ÓÃÀïÃæµÄ²ÎÊý
	else NT35310_LCD_ShowString(0,48,16,(u8*)"ÎÄ¼þÏµÍ³³õÊ¼»¯Ê§°Ü!");
	DelayMs(3000);
	LCD_Clear(WHITE);
	VS1053_Init();       					//VS1053³õÊ¼»¯
	while(1)
	{	
			
			if(VS_Start)	 // key interrupt for record
			{
				LCD_Clear(WHITE);
				sprintf(clock_buff,"%d%d%d%d.wav",rtc_clock.day,rtc_clock.hour,rtc_clock.minue,rtc_clock.second);
				NT35310_LCD_ShowString(0,0,16,(u8*)"ÕýÔÚÂ¼ÒôÖÐ............");
				NT35310_LCD_ShowString(0,16,16,(u8*)"Â¼ÒôÃû³Æ£º");
				NT35310_LCD_ShowString(80,16,16, (u8*)clock_buff);
				RecoderPlay((u8*)clock_buff);
				ScanVSFile("0:");
				DelayMs(500);
				LCD_Clear(WHITE);
			}	
		
			key=GetKeyValue(1);
			if(key==1) 
			{
				LCD_Clear(WHITE);
				NT35310_LCD_ShowString(0,0,16,(u8*)"²¥·ÅÂ¼ÒôÖÐ............");
				NT35310_LCD_ShowString(0,16,16,(u8*)"Â¼ÒôÃû³Æ£º");
				NT35310_LCD_ShowString(80,16,16,(u8*)VS1053_FileBuff[VS_Cnt]);
				printf("%s\r\n",VS1053_FileBuff[VS_Cnt]);
				VS1053_PlayOneMusic(VS1053_FileBuff[VS_Cnt]);
				if(VS_Cnt == 0)
				{
					NT35310_LCD_ShowString(0,0,32,(u8*)"ÕâÊÇµÚÒ»Ê×Â¼Òô............");
					VS_Cnt++;
				}
				VS_Cnt--;
				DelayMs(500);
				LCD_Clear(WHITE);
			}
			else if(key==3)
			{
				LCD_Clear(WHITE);
				NT35310_LCD_ShowString(0,00,16,(u8*)"²¥·ÅÂ¼ÒôÖÐ............");
				NT35310_LCD_ShowString(0,16,16,(u8*)"Â¼ÒôÃû³Æ£º");
				NT35310_LCD_ShowString(80,16,16,(u8*)VS1053_FileBuff[VS_Cnt]);
				printf("%s\r\n",VS1053_FileBuff[VS_Cnt]);
				if(VS_Cnt>10)
				{
					NT35310_LCD_ShowString(0,32,16,(u8*)"ÕâÊÇ×îºóÒ»Ê×Â¼Òô............");
					VS_Cnt--;
				}
				 VS1053_PlayOneMusic(VS1053_FileBuff[VS_Cnt]);
				 VS_Cnt++;
				 DelayMs(500);
				 LCD_Clear(WHITE);
			}	
			
			LED1=!LED1;
			DelayMs(200);
			if(Flag_RX1)
			{
					if(buff[0]=='*')
					{
							rtc_clock.year=(buff[1]-48)*1000+(buff[2]-48)*100+(buff[3]-48)*10+(buff[4]-48)*1;
							rtc_clock.month=(buff[5]-48)*10+(buff[6]-48)*1;
							rtc_clock.day=(buff[7]-48)*10+(buff[8]-48)*1;
							rtc_clock.hour=(buff[9]-48)*10+(buff[10]-48)*1;
							rtc_clock.minue=(buff[11]-48)*10+(buff[12]-48)*1;
							rtc_clock.second=(buff[13]-48)*10+(buff[14]-48)*1;
							time_transfor(rtc_clock.year,rtc_clock.month,rtc_clock.day,rtc_clock.hour,rtc_clock.minue,rtc_clock.second);	
					}
					Flag_RX1=0;
					cnt_RX1=0;
					
			}
			sprintf(clock_buff,"%dÄê%dÔÂ%dÈÕ%dÊ±%d·Ö%dÃë",rtc_clock.year,rtc_clock.month,rtc_clock.day,rtc_clock.hour,rtc_clock.minue,rtc_clock.second);
			NT35310_LCD_ShowString(0,0,16, (u8*)clock_buff);
		
			

			
	}
}


/*
º¯Êý¹¦ÄÜ£ºÂ¼Òô
²Î    Êý£ºÂ¼ÒôÎÄ¼þµÄÃû³Æ
*/
u8 RecoderPlay(u8 *file_name)
{
	u8 recagc=4,res;											//Ä¬ÈÏÔöÒæÎª4
	u32 cnt;
	u16 w;
	u32 sectorsize=0;
	u8 recbuf[512];													 //Êý¾ÝÄÚ´æ
	u16 idx=0;
	__WaveHeader wavhead;
	FIL f_rec;															  //Â¼ÒôÎÄ¼þ
	VS1053_RecoderInit(1024);			            //¼¤»îPCM Â¼ÒôÄ£Ê½
	VS1053_RecoderWavInit(&wavhead);				  //³õÊ¼»¯wavÊý¾Ý	
	res=f_open(&f_rec,(const TCHAR*)file_name, FA_CREATE_ALWAYS | FA_WRITE);  //´´½¨´æ·ÅÂ¼ÒôµÄÎÄ¼þ
	if(res){printf("Â¼ÒôÎÄ¼þ´´½¨Ê§°Ü!\r\n");return 0;}
	else printf("Â¼ÒôÎÄ¼þ %s ´´½¨³É¹¦!\r\n",file_name);
	res=f_write(&f_rec,(const void*)&wavhead,sizeof(__WaveHeader),&cnt);      //Ð´ÈëÍ·Êý¾Ý		 //Ð´ÈëÍ·Êý¾Ý
	while(1)
	{
			//¶ÁÈ¡Êý¾Ý			  
			w=VS1053_ReadReg(SPI_HDAT1);	
			if((w>=256)&&(w<896))
			{
				idx=0;				   	 
				while(idx<512) 	//Ò»´Î¶ÁÈ¡512×Ö½Ú
				{	 
					w=VS1053_ReadReg(SPI_HDAT0);				   	    
					recbuf[idx++]=w&0XFF;
					recbuf[idx++]=w>>8;
				}	  		 
				res=f_write(&f_rec,recbuf,512,&cnt);//Ð´ÈëÎÄ¼þ ,Ð´Èë512×Ö½Ú
				if(res)
				{
					printf("Ð´Èë³ö´í.!\r\n");
					break;  
				}
				sectorsize++;//ÉÈÇøÊýÔö¼Ó1,Ô¼Îª32ms	 
			}
      if(VS1053_OK)  //½áÊøÂ¼Òô
			{
					wavhead.riff.ChunkSize=sectorsize*512+36;	//Õû¸öÎÄ¼þµÄ´óÐ¡-8;
					wavhead.data.ChunkSize=sectorsize*512;		//Êý¾Ý´óÐ¡
					f_lseek(&f_rec,0);							//Æ«ÒÆµ½ÎÄ¼þÍ·.
					f_write(&f_rec,(const void*)&wavhead,sizeof(__WaveHeader),&cnt);//Ð´ÈëÍ·Êý¾Ý
					f_close(&f_rec);
					sectorsize=0;
					printf("½áÊøÂ¼Òô!\r\n");
					break;
			}				
		}	
		
		VS1053_OK=0;
		VS_Start=0;
		return res;
		
}


//²¥·ÅÒôÆµ				     	   									    	 
//·µ»ØÖµ:0,Õý³£²¥·ÅÍê³É
u8 VS1053_PlayOneMusic(u8 *pname)
{	 
 	FIL fmp3;
  u16 br;
	u8 res,rval;	  
	u8 databuf[4096];	   		   
	u16 i=0;

	printf("VS1053_Reset=%d\r\n",VS1053_Reset());      								//Ó²¸´Î»MP3
	VS1053_SoftReset(); 								//Èí¸´Î»VS10XX
	VS1053_SetVol(250);								  //ÉèÖÃÒôÁ¿
	
	res=f_open(&fmp3,(const TCHAR*)pname,FA_READ);//´ò¿ªÎÄ¼þ	 
	if(res!=0)return 1;  //ÎÄ¼þ´ò¿ªÊ§°Ü 
	printf("%sÎÄ¼þ´ò¿ª³É¹¦!\r\n",pname);				   
	while(1)
	{
		res=f_read(&fmp3,databuf,4096,(UINT*)&br);//¶Á³ö4096¸ö×Ö½Ú  
		i=0;
		while(i<4096) //Ã¿´Î²¥·Å4096¸ö×Ö½Ú
		{  	
				if(VS1053_SendMusicData(databuf+i)==0)//¸øVS10XX·¢ËÍÒôÆµÊý¾Ý
				{
					i+=32;
				}
		}
		if(br!=4096||res!=0)
		{
			rval=0;
			break;//¶ÁÍêÁË.		  
		} 							 
	}
	f_close(&fmp3);	  
	return rval;	  	 		  	    
}

/*
º¯Êý¹¦ÄÜ£ºÉ¨ÃèÂ¼Òô¸ùÄ¿Â¼
º¯Êý·µ»ØÖµ£º0 ±íÊ¾³É¹¦ 1£º±íÊ¾Ê§°Ü
*/
u8 ScanVSFile(const char *path)
{
		int i=0;
		DIR dp;
		FRESULT res;
		FILINFO fno; 
		char *abs_path=NULL; 
		/*1.´ò¿ªÄ¿Â¼*/
		res=f_opendir(&dp,path);
		if(res!=FR_OK) return 1;
	
		/*Ñ­»·¶ÁÈ¡Ä¿Â¼*/
		while(f_readdir(&dp,&fno)==FR_OK)
		{
		
			if(fno.fname[0]==0)break;
			printf("ÎÄ¼þÃû³Æ: %s,ÎÄ¼þ´óÐ¡: %ld ×Ö½Ú\r\n",fno.fname,fno.fsize);
			/*2.¹ýÂËÄ¿Â¼*/
			if(strstr(fno.fname,".wav"))
			{
					
					//ÉêÇë´æ·ÅÎÄ¼þÃû³Æ³¤¶ÈµÄ¿Õ¼ä
					abs_path=malloc(strlen(fno.fname)+1);
			 
					if(abs_path==NULL)break;
			
					strcpy(abs_path,fno.fname);
					VS1053_FileBuff[i++]=(u8*)abs_path;
					if(i>10)i=0;
				
		   }
	}
				f_closedir(&dp);
				return 0;
}
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "LCD1602.h"
#include "usart2.h"
#include "AS608.h"
#include "timer.h"
#include "beep.h"
#include "rtc.h"
#include "date.h"
#include "stm32f10x.h"
#include "stm32f10x_rtc.h"
#include "AT24CXX.h"
#include "iic.h"

#define usart2_baund  57600//´®¿Ú2²¨ÌØÂÊ£¬¸ù¾ÝÖ¸ÎÆÄ£¿é²¨ÌØÂÊ¸ü¸Ä£¨×¢Òâ£ºÖ¸ÎÆÄ£¿éÄ¬ÈÏ57600£©
SysPara AS608Para;//Ö¸ÎÆÄ£¿éAS608²ÎÊý
u16 ValidN;//Ä£¿éÄÚÓÐÐ§Ä£°å¸öÊý
u8** kbd_tbl;

u32 timedata=0;

void Add_FR(u8 a);	//Â¼Ö¸ÎÆ
void Del_FR(u8 a);	//É¾³ýÖ¸ÎÆ
void press_FR(void);//Ë¢Ö¸ÎÆ
void ShowErrMessage(u8 ensure);//ÏÔÊ¾È·ÈÏÂë´íÎóÐÅÏ¢

int d=0;  //É¾³ýÖ¸ÎÆÊ±ÓÃµÄID²ÎÊý
int get_d=0;  //·µ»Ø¸øQTµÃÖ¸ÎÆID

u8 num = 1; //×¢²áID
u8 num_24C02 = 0; //±£´æµØÖ·

int KeyVal;	 //keyVal?????????
int key_number = 0; 
struct rtc_time systmtime;	

unsigned char pass[6] = {1,2,3,4,5,6};
unsigned char in_key[6];			//ÊäÈëÃÜÂë

u16 nao_hour_start = 0;
u16 nao_min_start = 0;

u16 nao_hour_stop = 0;
u16 nao_min_stop = 0;

u8 number = 0; //Ö¸ÎÆ±àºÅ
void GPIO_Configuration(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;
  	
	SystemInit();

	//GPIOÊäÈëÅäÖÃ
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);

	GPIO_InitStructure.GPIO_Pin= GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_9|GPIO_Pin_10;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING;
//	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_Init(GPIOA,&GPIO_InitStructure);
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);	
	GPIO_InitStructure.GPIO_Pin= GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_Init(GPIOA,&GPIO_InitStructure);
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);	
	GPIO_InitStructure.GPIO_Pin= GPIO_Pin_0;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_Init(GPIOB,&GPIO_InitStructure);
}

int key_down(void)  //???????????,??????,???????????
{
	KeyVal = 99;

	GPIO_ResetBits(GPIOA,GPIO_Pin_7); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_6); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_5); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_4); //????? 

	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9)==0)
	{
		 KeyVal = 15;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10)==0)
	{
		 KeyVal = 14;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1)==0)
	{
		 KeyVal = 13;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)==0)
	{
		 KeyVal = 12;
	}

	GPIO_SetBits(GPIOA,GPIO_Pin_7); //????? 
	GPIO_ResetBits(GPIOA,GPIO_Pin_6); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_5); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_4); //????? 

	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9)==0)
	{
		 KeyVal = 11;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10)==0)
	{
		 KeyVal = 10;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1)==0)
	{
		 KeyVal = 9;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)==0)
	{
		 KeyVal = 8;
	}

	GPIO_SetBits(GPIOA,GPIO_Pin_7); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_6); //????? 
	GPIO_ResetBits(GPIOA,GPIO_Pin_5); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_4); //????? 

	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9)==0)
	{
		 KeyVal = 7;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10)==0)
	{
		 KeyVal = 6;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1)==0)
	{
		 KeyVal = 5;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)==0)
	{
		 KeyVal = 4;
	}

	GPIO_SetBits(GPIOA,GPIO_Pin_7); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_6); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_5); //????? 
	GPIO_ResetBits(GPIOA,GPIO_Pin_4); //????? 

	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9)==0)
	{
		 KeyVal = 3;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10)==0)
	{
		 KeyVal = 2;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1)==0)
	{
		 KeyVal = 1;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)==0)
	{
		 KeyVal = 0;
	}
//	GPIO_Write(GPIOA,(GPIOA->ODR & 0xff0f | 0x00f0)); //?PB8?PB11?????,???????????
//	while((GPIOA->IDR & 0x000f) != 0x0000);        //??????????
	if(KeyVal!=99)
	{
		GPIO_SetBits(GPIOB,GPIO_Pin_0); //????? 
		delay_ms(200); 
		GPIO_ResetBits(GPIOB,GPIO_Pin_0); //????? 
		switch(KeyVal)
		{	
			case 0:	 KeyVal = 12;
				break;
			case 1:	 KeyVal = 3;
				break;
			case 2:	 KeyVal = 2;
				break;
			case 3:	 KeyVal = 1;
				break;
			case 4:	 KeyVal = 13;
				break;
			case 5:	 KeyVal = 6;	
				break;		 	
			case 6:	 KeyVal = 5;
				break;
			case 7:	 KeyVal = 4;
				break;
			case 8:	 KeyVal = 14;
				break;
			case 9:	 KeyVal = 9;
				break;		  
			case 10: KeyVal = 8;
				break;
			case 11: KeyVal = 7;
				break;
			case 12: KeyVal = 15;
				break;
			case 13: KeyVal = 11;
				break;
			case 14: KeyVal = 0;
				break;
			case 15: KeyVal = 10;
				break;
		}
	}
	return KeyVal;		
}

//ÐÞ¸ÄÊ±¼ä
void RTC_TimeAdjust(void)
{
  /* Wait until last write operation on RTC registers has finished */
  RTC_WaitForLastTask();

  RTC_SetCounter(mktimev(&systmtime));
  /* Wait until last write operation on RTC registers has finished */
  RTC_WaitForLastTask();
}


void set_time()
{
	int time_flag =0; 			//????????

			//?
					
			LCD_Write_Com(0x80); 
			LCD_Write_Data(systmtime.tm_year/1000+'0');
			LCD_Write_Data((systmtime.tm_year%1000)/100+'0');
			LCD_Write_Data(systmtime.tm_year%100/10+'0');
			LCD_Write_Data(systmtime.tm_year%10+'0');   //?lcd1602????

			time_flag =0; 
			for(;;)
			{				
				LCD_Write_Com(0x80);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_year = time_flag*1000;
					break;
				}	
		   }
			
			for(;;)
			{
				LCD_Write_Com(0x81);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_year += time_flag*100;
					break;
				}	
			}

			for(;;)
			{
				LCD_Write_Com(0x82);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_year += time_flag*10;
					break;
				}	
			}

			for(;;)
			{
				LCD_Write_Com(0x83);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_year += time_flag;

					if(systmtime.tm_year>=2099)	   //?????
						systmtime.tm_year = 2099;
					else if(systmtime.tm_year<=1970)
						systmtime.tm_year = 1970;	
					break;
				}	
			}
			//?
			LCD_Write_Com(0x85);  //????
			LCD_Write_Data(systmtime.tm_mon%100/10+'0');
			LCD_Write_Data(systmtime.tm_mon%10+'0');   //?lcd1602????

			for(;;)
			{
				LCD_Write_Com(0x85);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	

				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_mon = time_flag * 10;
					break;
				}	
			}
			//time_flag = Time_1[4]&0x0f;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0x86);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_mon += time_flag;
					if(systmtime.tm_mon>=12)	   //???
						systmtime.tm_mon = 12;
					break;
				}	
			}

			LCD_Write_Com(0x88);  //????
			LCD_Write_Data(systmtime.tm_mday%100/10+'0');
			LCD_Write_Data(systmtime.tm_mday%10+'0');   //?lcd1602????
			//?
			time_flag = systmtime.tm_mday;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0x88);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	

				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_mday = time_flag * 10;
					break;
				}	
			}


			//time_flag = Time_1[4]&0x0f;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0x89);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(key_number + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_mday += time_flag;
					if(systmtime.tm_mday>=31)	   //???
						systmtime.tm_mday = 31;
					break;
				}	
			}

			//?
			LCD_Write_Com(0xc2);  //????
			LCD_Write_Data(systmtime.tm_hour%100/10+'0');
			LCD_Write_Data(systmtime.tm_hour%10+'0');   //?lcd1602????
			for(;;)
			{
				LCD_Write_Com(0xc2);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	

				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_hour = time_flag * 10;
					break;
				}	
			}
			//time_flag = Time_1[4]&0x0f;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0xc3);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_hour += time_flag;
					if(systmtime.tm_hour>=23)	   //????
						systmtime.tm_hour = 23;
					break;
				}	
			}


			//?
			LCD_Write_Com(0xc5);  //????
			LCD_Write_Data(systmtime.tm_min%100/10+'0');
			LCD_Write_Data(systmtime.tm_min%10+'0');   //?lcd1602????
			for(;;)
			{
				LCD_Write_Com(0xc5);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	

				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_min = time_flag * 10;

					break;
				}	
			}
			//time_flag = Time_1[4]&0x0f;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0xc6);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_min+= time_flag;
					if(systmtime.tm_min>=59)	   //????
						systmtime.tm_min = 59;
					break;
				}	
			}
			//sec
			LCD_Write_Com(0xc8);  //????
			LCD_Write_Data(systmtime.tm_sec%100/10+'0');
			LCD_Write_Data(systmtime.tm_sec%10+'0');   //?lcd1602????
			for(;;)
			{
				LCD_Write_Com(0xc8);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	

				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_sec = time_flag * 10;
					break;
				}	
			}
			//time_flag = Time_1[4]&0x0f;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0xc9);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_sec+= time_flag;
					if(systmtime.tm_sec>=59)	   //???
						systmtime.tm_sec = 59;
					break;
				}	
			}

			//xing?
			LCD_Write_Com(0xc0);  //????
			LCD_Write_Data(systmtime.tm_wday%10+'0');   //?lcd1602????
			for(;;)
			{
				LCD_Write_Com(0xc0);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_wday = time_flag;
					if(systmtime.tm_wday>=7)	   //????
						systmtime.tm_wday = 7;
					break;
				}	
			}
				
			RTC_TimeAdjust();//????
}
void set_nao()
{

	int time_flag =0; 			//????????

		LCD_Write_Com(0x8b);
		LCD_Write_Data('0'+ nao_hour_start/10);
		LCD_Write_Data('0'+ nao_hour_start%10);
		LCD_Write_Data(':');
		LCD_Write_Data('0'+ nao_min_start/10);
		LCD_Write_Data('0'+ nao_min_start%10);
		delay_ms(200);	

				
		for(;;)		 //???? ??
		{

			key_number = key_down();	  //????
			LCD_Write_Com(0x8b);  //????	 
			LCD_Write_Com(0x0e);  //??
			delay_ms(200);	
			LCD_Write_Com(0x0c);  //??
			if(key_number<=9)
			{
				time_flag =  key_number;
				LCD_Write_Com(0x8b);
				LCD_Write_Data('0'+ time_flag);
			}
			else if(key_number==11) //#?? ??
			{
				nao_hour_start = 	time_flag*10;
				break;
			}
		}

		for(;;)		 //???? ??
		{

			key_number = key_down();	  //????
			LCD_Write_Com(0x8c);  //????	 
			LCD_Write_Com(0x0e);  //??
			delay_ms(200);	
			LCD_Write_Com(0x0c);  //??
			if(key_number<=9)
			{
				time_flag =  key_number;
				LCD_Write_Com(0x8c);
				LCD_Write_Data('0'+ time_flag);
			}
			else if(key_number==11) //#?? ??
			{
				nao_hour_start += time_flag;
				if(nao_hour_start>=23)	   //??????
					nao_hour_start = 23;
				break;
			}
		}

//		for(;;)		 //??miao
//		{

//			key_number = key_down();	  //????
//			LCD_Write_Com(0x8e);  //????	 
//			LCD_Write_Com(0x0e);  //??
//			delay_ms(200);	
//			LCD_Write_Com(0x0c);  //??
//			if(key_number<=9)
//			{					
//				time_flag =  key_number;
//				LCD_Write_Com(0x8e);
//				LCD_Write_Data('0'+ time_flag);
//			}
//			else if(key_number==11) //#?? ??
//			{
//				nao_min_start = 	time_flag*10;
//				break;
//			}
//		}

//		for(;;)		 //??? ??
//		{

//			key_number = key_down();	  //????
//			LCD_Write_Com(0x8f);  //????	 
//			LCD_Write_Com(0x0e);  //??
//			delay_ms(200);	
//			LCD_Write_Com(0x0c);  //??
//			if(key_number<=9)
//			{
//				time_flag =  key_number;
//				LCD_Write_Com(0x8f);
//				LCD_Write_Data('0'+ time_flag);
//			}
//			else if(key_number==11) //#?? ??
//			{
//				nao_min_start += time_flag;
//				if(nao_min_start>=59)	   //??????
//					nao_min_start = 59;
//				break;
//			}
//		}
//		

		LCD_Write_Com(0xcb);
		LCD_Write_Data('0'+ nao_hour_stop/10);
		LCD_Write_Data('0'+ nao_hour_stop%10);
		LCD_Write_Data(':');
		LCD_Write_Data('0'+ nao_min_stop/10);
		LCD_Write_Data('0'+ nao_min_stop%10);
		delay_ms(200);	

				
		for(;;)		 //???? ??
		{

			key_number = key_down();	  //????
			LCD_Write_Com(0xcb);  //????	 
			LCD_Write_Com(0x0e);  //??
			delay_ms(200);	
			LCD_Write_Com(0x0c);  //??
			if(key_number<=9)
			{
				time_flag =  key_number;
				LCD_Write_Com(0xcb);
				LCD_Write_Data('0'+ time_flag);
			}
			else if(key_number==11) //#?? ??
			{
				nao_hour_stop = 	time_flag*10;
				break;
			}
		}

		for(;;)		 //???? ??
		{

			key_number = key_down();	  //????
			LCD_Write_Com(0xcc);  //????	 
			LCD_Write_Com(0x0e);  //??
			delay_ms(200);	
			LCD_Write_Com(0x0c);  //??
			if(key_number<=9)
			{
				time_flag =  key_number;
				LCD_Write_Com(0xcc);
				LCD_Write_Data('0'+ time_flag);
			}
			else if(key_number==11) //#?? ??
			{
				nao_hour_stop += time_flag;
				if(nao_hour_stop>=23)	   //??????
					nao_hour_stop = 23;
				break;
			}
		}

//		for(;;)		 //??miao
//		{

//			key_number = key_down();	  //????
//			LCD_Write_Com(0xce);  //????	 
//			LCD_Write_Com(0x0e);  //??
//			delay_ms(200);	
//			LCD_Write_Com(0x0c);  //??
//			if(key_number<=9)
//			{					
//				time_flag =  key_number;
//				LCD_Write_Com(0xce);
//				LCD_Write_Data('0'+ time_flag);
//			}
//			else if(key_number==11) //#?? ??
//			{
//				nao_min_stop = 	time_flag*10;
//				break;
//			}
//		}

//		for(;;)		 //??? ??
//		{

//			key_number = key_down();	  //????
//			LCD_Write_Com(0xcf);  //????	 
//			LCD_Write_Com(0x0e);  //??
//			delay_ms(200);	
//			LCD_Write_Com(0x0c);  //??
//			if(key_number<=9)
//			{
//				time_flag =  key_number;
//				LCD_Write_Com(0xcf);
//				LCD_Write_Data('0'+ time_flag);
//			}
//			else if(key_number==11) //#?? ??
//			{
//				nao_min_stop += time_flag;
//				if(nao_min_stop>=59)	   //??????
//					nao_min_stop = 59;
//				break;
//			}
//		}
}


//·äÃùÆ÷ÏìÒ»Éù
void beep()
{
		 GPIO_SetBits(GPIOB,GPIO_Pin_0); //·äÃùÆ÷±¨¾¯
		 delay_ms(200); 			//ÑÓÊ±200ms
		 GPIO_ResetBits(GPIOB,GPIO_Pin_0);
		 delay_ms(200); 			//ÑÓÊ±200ms			
}


void set_number()
{
	  char num_flag = 0;
	 	LCD_Write_Com(0xc0);  //??
		LCD_Write_Data('N');
		LCD_Write_Data('u');
		LCD_Write_Data('m');
		LCD_Write_Data('b');
		LCD_Write_Data('e');
		LCD_Write_Data('r');
		LCD_Write_Data(' ');
		LCD_Write_Data('>');
		LCD_Write_Data('0'+number%100/10);
		LCD_Write_Data('0'+number%10);			

	for(;;)
	{
		key_number = key_down();	  //????
		LCD_Write_Com(0xc8);  //????	 
		LCD_Write_Com(0x0e);  //??
		delay_ms(100); 
		LCD_Write_Com(0x0c);  //??	
     delay_ms(100); 		
		if(key_number <= 9)   //????????
		{  
			 num_flag =  key_number;
			 LCD_Write_Com(0xc8);  //????
			 LCD_Write_Data('0'+key_number);
		}
		if(key_number==11) //#??
		{
			 number = num_flag*10;
			 break;
		}
	}

	for(;;)
	{
			key_number = key_down();	  //????
			LCD_Write_Com(0xc9);  //????	 
			LCD_Write_Com(0x0e);  //??
			delay_ms(100); 
			LCD_Write_Com(0x0c);  //??	
			delay_ms(100); 		
		
			if(key_number <= 9)   //????????
			{  
				 num_flag =  key_number;
				 LCD_Write_Com(0xc9);  //????
				 LCD_Write_Data('0'+key_number);
			}
			if(key_number==11) //#??
			{
				 number += num_flag;
				 break;
			}
	}

	LCD_Write_Com(0x01); 
}

void set_zhuce(u8 a)
{
		if(a==0)
		{
				
			LCD_Write_Com(0x80);  
			LCD_Write_Data('z');
			LCD_Write_Data('h');
			LCD_Write_Data('u');
			LCD_Write_Data(' ');
			LCD_Write_Data('c');
			LCD_Write_Data('e');
			
		}
		else if(a==1)
		{
			LCD_Write_Com(0x80);  
			LCD_Write_Data('D');
			LCD_Write_Data('e');
			LCD_Write_Data('l');
			LCD_Write_Data('e');
			LCD_Write_Data('t');
			LCD_Write_Data('e');
		}	
		set_number();
}


void time_display()
{

	LCD_Write_Com(0x80);  //LCD1602??????
	LCD_Write_Data('0' + (systmtime.tm_year%10000)/1000);
	LCD_Write_Data('0' + (systmtime.tm_year%1000)/100);
	LCD_Write_Data('0'+(systmtime.tm_year%100)/10);
	LCD_Write_Data('0'+systmtime.tm_year%10);
	LCD_Write_Data('-');
	LCD_Write_Data('0'+systmtime.tm_mon/10);
	LCD_Write_Data('0'+systmtime.tm_mon%10);
	LCD_Write_Data('-');
	LCD_Write_Data('0'+systmtime.tm_mday/10);
	LCD_Write_Data('0'+systmtime.tm_mday%10);
	LCD_Write_Data(' ');	

							
	LCD_Write_Com(0xC0);	//LCD1602
	if(systmtime.tm_wday==0)
	{
			LCD_Write_Data('7');
	}
	else
	{
			LCD_Write_Data('0'+ systmtime.tm_wday);
	}
	LCD_Write_Data(' ');
	LCD_Write_Data('0'+systmtime.tm_hour/10);
	LCD_Write_Data('0'+systmtime.tm_hour%10);
	LCD_Write_Data(':');
	LCD_Write_Data('0'+systmtime.tm_min/10);
	LCD_Write_Data('0'+systmtime.tm_min%10);
	LCD_Write_Data(':');
	LCD_Write_Data('0'+systmtime.tm_sec/10);
	LCD_Write_Data('0'+systmtime.tm_sec%10);
	LCD_Write_Data(' ');

}


void RTC_IRQHandler()	//RTCÊµÊ±Ê±ÖÓ
{
	if(RTC_GetITStatus((RTC_IT_SEC))!=RESET)
	{
		RTC_ClearITPendingBit(RTC_IT_SEC);
		timebz=1;	
	}
}

//¶ÁÈ¡24c02´æ´¢ÐÅÏ¢
void read_24C02()				 //??24C02????
{
	u8 i = 0; //??forÑ­»·
	u8 read_num = 0;
	for(i=0;i<10;i++)
	{
	 	systmtime.tm_year = At24c02Read(0 + 8*i)+1970;	delay_ms(1);	
		systmtime.tm_wday = At24c02Read(1 + 8*i);	delay_ms(1);	
		systmtime.tm_mon = At24c02Read(2 + 8*i);		delay_ms(1);	
		systmtime.tm_mday= At24c02Read(3 + 8*i);	delay_ms(1);	
		systmtime.tm_hour = At24c02Read(4 + 8*i);	delay_ms(1);		
		systmtime.tm_min = At24c02Read(5 + 8*i);	delay_ms(1);	
		systmtime.tm_sec = At24c02Read(6 + 8*i);	delay_ms(1);	
		read_num = At24c02Read(7 + 8*i);	delay_ms(1);		
		time_display();
	 	LCD_Write_Com(0x8c);
		LCD_Write_Data('0'+i%10);
		LCD_Write_Data(' ');
	 	LCD_Write_Data(' ');
	 	LCD_Write_Com(0xcc);
		LCD_Write_Data('0'+ read_num/10);
		LCD_Write_Data('0'+ read_num%10);
		if(systmtime.tm_hour<nao_hour_start)
		{
			LCD_Write_Com(0x8F);	//LCD1602
			LCD_Write_Data('A');						
		}
		else if((systmtime.tm_hour>=nao_hour_start)&&(systmtime.tm_hour<12))
		{
			LCD_Write_Com(0x8F);	//LCD1602
			LCD_Write_Data('B');						
		}
		else if((systmtime.tm_hour<nao_hour_stop)&&(systmtime.tm_hour>=12))
		{
			LCD_Write_Com(0x8F);	//LCD1602
			LCD_Write_Data('C');						
		}		
		else
		{
			LCD_Write_Com(0x8F);	//LCD1602
			LCD_Write_Data('D');						
		}
		delay_ms(1000);
		delay_ms(1000);
	}
	LCD_1602Clear(); //ÇåÆÁ
}

void Save_24C02(u8 a)
{
	 At24c02Write(0 + 8*num_24C02,(systmtime.tm_year-1970));
	 delay_ms(1);	
	 At24c02Write(1 + 8*num_24C02,systmtime.tm_wday);delay_ms(1);	
	 At24c02Write(2 + 8*num_24C02,systmtime.tm_mon);delay_ms(1);	
	 At24c02Write(3 + 8*num_24C02,systmtime.tm_mday);delay_ms(1);	
	 At24c02Write(4 + 8*num_24C02,systmtime.tm_hour);delay_ms(1);	
	 At24c02Write(5 + 8*num_24C02,systmtime.tm_min);delay_ms(1);	
	 At24c02Write(6 + 8*num_24C02,systmtime.tm_sec);delay_ms(1);	
	 At24c02Write(7 + 8*num_24C02,a);delay_ms(1);	

	 num_24C02++;
	 if(num_24C02>=10)
	 	num_24C02 = 0;
}

//ems????
void ems_diaplay()
{
	LCD_1602Clear();  //??

	LCD_Write_Com(0xc0);
	LCD_Write_Data('I'); 
	LCD_Write_Data('N');  
	LCD_Write_Data('P');
	LCD_Write_Data('U');  
	LCD_Write_Data('T');
	LCD_Write_Data(':'); 
}

void input_pass()
{
	 unsigned char x=0,z=0,y=0;
	 
	 ems_diaplay();
	 for(;;)
	 {

		key_number = key_down();  //????

		if(key_number <= 9)   //????????
		{  			
			LCD_Write_Com(0xc6 + z);
			LCD_Write_Data('*'); 	//acsii??*?	 
		  	in_key[z] = key_number;		//????
			z++;
		}
		
		if(key_number == 11)			 //????
		{
			for(x=0;x<6;x++)
			{
				if(pass[x] == in_key[x])
					y++;
			}
			break;	//??????
		}
	 }
	 if(y>=6)  	//????????;
	 {	 
			LCD_1602Clear();
			for(;;)
		  {
				LCD_Write_Com(0xc0);
				LCD_Write_Data('V'); 
				LCD_Write_Data('I');  
				LCD_Write_Data('P');
				LCD_Write_Data(':');  
				LCD_Write_Data(' ');
				LCD_Write_Data(' '); 
					key_number = key_down();  //¶ÁÈ¡°´¼ü
					if(key_number==10)
					{
							break;
					}
					else if(key_number==11)
					{
							time_display(); //ÏÔÊ¾Ê±¼ä
							set_time(); //ÉèÖÃÏµÍ³Ê±¼ä
						  LCD_1602Clear();
					}
					else if(key_number==12) //×¢²áÖ¸ÎÆ
					{	    
							LCD_1602Clear();	//ÇåÆÁ
							set_zhuce(0);
							Add_FR(number);		//Â¼Ö¸ÎÆ	
							LCD_1602Clear();
					}
					else if(key_number==13)  //É¾³ýÖ¸ÎÆ
					{
						LCD_1602Clear();	//ÇåÆÁ
						set_zhuce(1);
						Del_FR(number);	 //É¾³ýÖ¸ÎÆ
						LCD_1602Clear();
					}
					else if(key_number==14) 
					{
							read_24C02();
						  LCD_1602Clear();
					}
					else if(key_number==15) 
					{
							set_nao();   //ÉèÖÃ¶¨Ê±
							LCD_1602Clear();
					}
			}	

	 }

}



int main(void)
{		
 
	u8 ensure;
	delay_init();

	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//ÉèÖÃÏµÍ³ÖÐ¶ÏÓÅÏÈ¼¶·Ö×é2

	//uart_init(115200);	//³õÊ¼»¯´®¿Ú1²¨ÌØÂÊÎª115200£¬ÓÃÓÚÖ§³ÖUSMART

	usart2_init(usart2_baund);//³õÊ¼»¯´®¿Ú2,ÓÃÓÚÓëÖ¸ÎÆÄ£¿éÍ¨Ñ¶
	
	clockinit_RTC();  //³õÊ¼»¯RTCÊ±ÖÓ
	
	LCD_1602Init();  //³õÊ¼»¯lcd1602
	
	PS_StaGPIO_Init();	//³õÊ¼»¯FR¶Á×´Ì¬Òý½Å
	
	GPIO_Configuration(); //³õÊ¼»¯GPIO
	
	I2C_INIT();		 //IIC³õÊ¼»¯
	
	while(PS_HandShake(&AS608Addr))//ÓëAS608Ä£¿éÎÕÊÖ
	{
//		printf("Cannot connect with AS608!"); 
		delay_ms(200);
	//  printf("Try to connect again....");		
		delay_ms(200);	  
	}
	
  // printf("\nÍ¨Ñ¶³É¹¦\n");

	ensure=PS_ValidTempleteNum(&ValidN);//¶Á¿âÖ¸ÎÆ¸öÊý
	
//	if(ensure!=0x00)
//		 printf("´íÎó");
		  
	ensure=PS_ReadSysPara(&AS608Para);  //¶ÁAS608Ä£¿é²ÎÊý 

//	d = 1;			
//	printf("µ±Ç°ÊäÈëµÄidÎª %d\n",d);

	//Del_FR();						
	while(1)
	{			
			
			key_number = key_down();  //¶ÁÈ¡°´¼ü

			if(key_number==10)  
			{
					input_pass();  
				  LCD_1602Clear();	//ÇåÆÁ
			}

			if(timebz==1)	   //Ê±ÖÓÃëÖÐ¶Ï
			{
					timebz=0;	  //ÇåÁã

					timedata=RTC_GetCounter();//»ñÈ¡RTC¼ÆÊýÆ÷µÄÖµ

					to_tm(timedata, &systmtime); //Ê±¼ä×ª»»
					
					time_display(); //ÏÔÊ¾Ê±¼ä
			}

			if(PS_Sta)	 //¼ì²âPS_Sta×´Ì¬£¬Èç¹ûÓÐÊÖÖ¸°´ÏÂ
			{
					press_FR();//Ë¢Ö¸ÎÆ		
			}		
				
			delay_ms(100);	

		}		 
	} 	


//ÏÔÊ¾È·ÈÏÂë´íÎóÐÅÏ¢
void ShowErrMessage(u8 ensure)
{  	
//	printf("´íÎóÐÅÏ¢ ");

}

//Â¼Ö¸ÎÆ
void Add_FR(u8 a)
{
	u8 i=0,ensure ,processnum=0;
	u16 ID;
	
	while(1)
	{  
			delay_ms(50);	
		switch (processnum)
		{
			case 0:
				i++;
		   //	printf("Çë°´ÊÖÖ¸\n");
			 
			  delay_ms(50);
				ensure=PS_GetImage();
				if(ensure==0x00) 
				{	delay_ms(50);	
					ensure=PS_GenChar(CharBuffer1);//Éú³ÉÌØÕ÷
					if(ensure==0x00)
					{ delay_ms(50);
						//printf("Ö¸ÎÆÕýÈ·\n");
						beep();
						i=0;
						delay_ms(50);
						processnum=1;//Ìøµ½µÚ¶þ²½						
					}else ShowErrMessage(ensure);	
	      delay_ms(50);						
				}else ShowErrMessage(ensure);		
	      delay_ms(50);					
				break;
			
			case 1:
				i++;
				//printf("ÔÙ°´Ò»´ÎÊÖÖ¸\n");//
			  
			 delay_ms(50);
				ensure=PS_GetImage();
				if(ensure==0x00) 
				{   	delay_ms(50);	
					ensure=PS_GenChar(CharBuffer2);//Éú³ÉÌØÕ÷			
					if(ensure==0x00)
					{ 	delay_ms(50);	
					//	printf("Ö¸ÎÆÕýÈ·\n");
	        
						i=0;
						processnum=2;//Ìøµ½µÚÈý²½
					}else ShowErrMessage(ensure);	
						delay_ms(50);	
				}else ShowErrMessage(ensure);		
					delay_ms(50);	
				break;

			case 2:
				//printf("¶Ô±ÈÁ½´ÎÖ¸ÎÆ\n");//
					  
				ensure=PS_Match();
				if(ensure==0x00) 
				{	delay_ms(50);	
					//printf("Á½´ÎÖ¸ÎÆÊÇÒ»ÑùµÄ\n");//
					beep();beep();  
					processnum=3;//Ìøµ½µÚËÄ²½
				}
				else 
				{  
  					delay_ms(50);	
				//	 printf("¶Ô±ÈÊ§°Ü£¬ÇëÖØÐÂ°´ÊÖÖ¸\n");//
					
					ShowErrMessage(ensure);
					i=0;
					processnum=0;//Ìø»ØµÚÒ»²½		
				}
				delay_ms(1000);
				break;

			case 3:
				//printf("²úÉúÒ»¸öÖ¸ÎÆÄ£°å\n");//
			
				ensure=PS_RegModel();
				if(ensure==0x00) 
				{	delay_ms(50);	 
			//		printf("Éú³ÉÖ¸ÎÆÄ£°å³É¹¦\n");//
									
					processnum=4;//Ìøµ½µÚÎå²½
				}else {processnum=0;ShowErrMessage(ensure);}
				delay_ms(500);
				break;
				
			case 4:	
		
				do
				{	
					PS_ValidTempleteNum(&ValidN);//¶Á¿âÖ¸ÎÆ¸öÊý
					ID = a;
					delay_ms(50);
				}
				while(!(ID<300));//ÊäÈëDI±ØÐëÐ¡ÓÚ300
				ensure=PS_StoreChar(CharBuffer2,ID);//´¢´æÄ£°å
				delay_ms(50);
				if(ensure==0x00) 
				{			
					delay_ms(50);
			//		printf("Ìí¼ÓÖ¸ÎÆ³É¹¦\n");//
					PS_ValidTempleteNum(&ValidN);//¶Á¿âÖ¸ÎÆ¸öÊý
					d=0;
					delay_ms(50);
				//	printf("Ê£ÓàÖ¸ÎÆ¸öÊý  %d  \n",AS608Para.PS_max-ValidN);				
					 delay_ms(500);			
					beep();beep();beep();
					return ;
				}else {processnum=0;ShowErrMessage(ensure);}					
				break;				
		}
		delay_ms(800);
		if(i==5)//³¬¹ý5´ÎÃ»ÓÐ°´ÊÖÖ¸ÔòÍË³ö
		{
      // printf("Ìí¼ÓÖ¸ÎÆÊ§°Ü\n");
			break;	
		}				
	}
}
//Ë¢Ö¸ÎÆ
void press_FR(void)
{
	SearchResult seach;
	u8 ensure;

	ensure=PS_GetImage();
	if(ensure==0x00)//»ñÈ¡Í¼Ïñ³É¹¦ 
	{	
		
		ensure=PS_GenChar(CharBuffer1);
		//printf("»ñÈ¡Í¼Ïñ³É¹¦ \n");
		if(ensure==0x00) //Éú³ÉÌØÕ÷³É¹¦
		{	
			
			//printf("»ñÈ¡Í¼Ïñ³É¹¦ \n");
			ensure=PS_HighSpeedSearch(CharBuffer1,0,300,&seach);
			if(ensure==0x00)//ËÑË÷³É¹¦
			{			
			//	printf("ËÑË÷Ö¸ÎÆ³É¹¦\n ");//ËÑË÷Ö¸ÎÆ³É¹¦	

				get_d = seach.pageID;	
			//	printf(" Æ¥ÅäÖ¸ÎÆµÄID%d\n",get_d);
				LCD_Write_Com(0x8C);	//LCD1602
				LCD_Write_Data('O');
				LCD_Write_Data('K');				
				
				if(systmtime.tm_hour<nao_hour_start)
				{
					LCD_Write_Com(0x8F);	//LCD1602
					LCD_Write_Data('A');						
				}
				else if((systmtime.tm_hour>=nao_hour_start)&&(systmtime.tm_hour<12))
				{
					LCD_Write_Com(0x8F);	//LCD1602
					LCD_Write_Data('B');						
				}
				else if((systmtime.tm_hour<nao_hour_stop)&&(systmtime.tm_hour>=12))
				{
					LCD_Write_Com(0x8F);	//LCD1602
					LCD_Write_Data('C');						
				}		
				else
				{
					LCD_Write_Com(0x8F);	//LCD1602
					LCD_Write_Data('D');						
				}
				
				LCD_Write_Com(0xCC);	//LCD1602
				LCD_Write_Data('0'+ get_d/10);
				LCD_Write_Data('0'+ get_d%10);
				Save_24C02(get_d); //±£´æµØÖ·
				beep();
				delay_ms(1000);
				delay_ms(1000);
				LCD_Write_Com(0xCC);	//LCD1602
				LCD_Write_Data(' ');
				LCD_Write_Data(' ');
				LCD_Write_Com(0x8C);	//LCD1602
				LCD_Write_Data(' ');
				LCD_Write_Data(' ');
				LCD_Write_Data(' ');
				LCD_Write_Data(' ');
			}
			else 
			{				
					LCD_Write_Com(0x8b);	//LCD1602
					LCD_Write_Data('E');
					LCD_Write_Data('R');	
				  LCD_Write_Data('R');
				  LCD_Write_Data('O');
				  LCD_Write_Data('R');
					beep();beep();beep();//·äÃùÆ÷Ïì3ÏÂ
					LCD_Write_Com(0x8b);	//LCD1602
					LCD_Write_Data(' ');
					LCD_Write_Data(' ');	
				  LCD_Write_Data(' ');
				  LCD_Write_Data(' ');
				  LCD_Write_Data(' ');
			}
			//	printf("Ê§°ÜAA\n ");		
	   delay_ms(50);			
	  }
		else
			//printf("Ê§°ÜBB\n ");	
			delay_ms(50);

	}
		
}

//É¾³ýÖ¸ÎÆ
void Del_FR(u8 a)
{
	u8  ensure;
  int v;
   PS_ValidTempleteNum(&ValidN);//¶Á¿âÖ¸ÎÆ¸öÊý
			v=ValidN;		 
		ensure=PS_DeletChar(a,1);//É¾³ýµ¥¸öÖ¸ÎÆ 
	  PS_ValidTempleteNum(&ValidN);//¶Á¿âÖ¸ÎÆ¸öÊý
	if(ensure==0&&v==ValidN+1)
	{
		     // printf("É¾³ý³É¹¦"); 
	}
  else
	{	
		ShowErrMessage(ensure);	
   // printf("É¾³ýÊ§°Ü"); 

	}       
}



/**
  ******************************************************************************
  * @file    main.c
  * @author  pcf
  * @version V4.0
  * @date    2018-4-23
  * @brief   ÖÇÄÜÊÖ»·
  ******************************************************************************
  */ 

#include "stm32f10x.h"
#include "led.h"
#include "bsp_exti.h"
#include "delay.h"
#include "GY-MCU90615.h"
#include "OLED_I2C.h"
#include "bsp_adc.h"
#include "bsp_TiMbase.h" 
#include "Step_Num.h"
#include "./mpu6050/mpu6050.h"
#include "bsp_GeneralTim.h" 

extern int LED_SIGN;							//¹¦ÄÜÇÐ»»±êÖ¾	
float ADC_ConvertedValueLocal; 			// ¾Ö²¿±äÁ¿£¬ÓÃÓÚ±£´æ×ª»»¼ÆËãºóµÄµçÑ¹Öµ 	 
extern __IO unsigned char QS;       	// µ±·¢ÏÖÒ»¸ö½ÚÅÄÊ±£¬±äÎªÕæ
int sign1=0, sign2=0;
/**
  * @brief  Ö÷º¯Êý
  * @param  ÎÞ
  * @retval ÎÞ
  */ 
int main(void)
{
	int i = 0;
	/*ÏµÍ³Ê±ÖÓÉèÖÃ*/
	delay_init(72);
	
	/* LED ¶Ë¿Ú³õÊ¼»¯ */
	LED_Init();

	/*³õÊ¼»¯´®¿ÚÒ»£¬ÓÃÓÚÎÂ¶È¼ì²â£¨½ÓÊÕÊý¾Ý£©*/ 	
	Usart1_Int(115200);

	/*ÅäÖÃIIC1£¬ÓÃÓÚOLEDÏÔÊ¾ÆÁ*/
	I2C_Configuration();	

	/*³õÊ¼»¯OLED*/
	OLED_Init();											
	
	MPU6050_Init();
	
	/*µÈ´ýÄ£¿é³õÊ¼»¯Íê³É*/
	delay_ms(1);

	/*¿ª»úÏÔÊ¾*/
	LED_ON;
	for(i=0;i<4;i++)
	{
		OLED_ShowCN(22+i*16,3,i);									//²âÊÔÏÔÊ¾"ÖÇÄÜÊÖ»·"
	}
	delay_ms(3000);
	OLED_Fill(0x00);	//È«ÆÁÃð
	
	
	/*Íâ²¿ÖÐ¶Ï³õÊ¼»¯£¬ÓÃÓÚ¹¦ÄÜÇÐ»»*/
	EXTI_Key_Config(); 
	
	/*ADC ³õÊ¼»¯*/ 
	ADCx_Init();
	
	/*¶¨Ê±Æ÷³õÊ¼»¯*/
	BASIC_TIM_Init();
	
	GENERAL_TIM_Init();	

	LED_OFF;
	/* µÈ´ýÖÐ¶Ï£¬ÓÉÓÚÊ¹ÓÃÖÐ¶Ï·½Ê½£¬CPU²»ÓÃÂÖÑ¯°´¼ü */
	while(1)                            
	{
		switch(LED_SIGN%4)
		{
			/*³õÊ¼×´Ì¬*/
			case 0 :
				LED_OFF;
				OLED_Fill(0x00);	//È«ÆÁÃð
				break;
			/*¹¦ÄÜ1£º²âÁ¿Ìå±íÎÂ¶È*/
			case 1 :
				send_com(0x15);				//·¢ËÍÃüÁî
				delay_ms(1000); 				//µÈ´ýÃüÁî½ÓÊÕÍê±Ï
				temp_float();					//Êý¾Ý×ª»»
				OLED_Display_Temp();			//ÏÔÊ¾¶ÁÈ¡µÄÎÂ¶È
				break;
			/*¹¦ÄÜ2£º²âÁ¿ÐÄÂÊ*/
			case 2 :
				if (sign1 ==0)
				{
					OLED_Fill(0x00);	//È«ÆÁÃð
//					delay_ms(100); 
				}
				if (QS == 1)
				{
					sign1 = 1;
					
					OLED_Display_HeareRate();
					delay_ms(1000); 				//µÈ´ýÃüÁî½ÓÊÕÍê±Ï
					QS = 0;                    // ÏÂ´ÎÖØÐÂÉèÖÃÁ¿»¯µÄ×ÔÎÒ±êÖ¾
				}
				break;
			/*¹¦ÄÜ3£º¼Æ²½*/
			case 3 :
				
				if (sign2 == 0)
				{
					OLED_Fill(0x00);	//È«ÆÁÃð
//					delay_ms(100); 
				}
				sign2 = 1;
				OLED_Display_StepNumber();
				delay_ms(1000);
				break;
		}
		
	}
}
/*********************************************END OF FILE**********************/
#include "led.h"
#include "delay.h"
#include "sys.h"
#include "usart.h"
#include "oled.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "adc.h"
#include "DHT11.h"
extern u8 hum_set;


 int main(void)
 { 
	volatile u16 adcx;
	u8 temp,hum,buf[20],buf1[20],times;
	delay_init();	    	 //ÑÓÊ±º¯Êý³õÊ¼»¯	  
	uart_init(9600);	 	//´®¿Ú³õÊ¼»¯Îª9600
    OLED_Init();  //oled³¬ÊæÊÊ»¯  PB 3,4,5,6
    DHT11_Init();  //PB 0
    Adc_Init();  //PA1
    Relay_Init();// PB 12,13
	memset(buf,0,16);
    memset(buf1,0,16);
    Relay_Init(); 
	while(1)
	{
    
           // Relay=1;
     	adcx=Get_Adc_Average(ADC_Channel_3,10);
	    if(times>3)
        {
            times=0;
            DHT11_Read_Data(&temp,&hum);
            sprintf( buf,"T %d -- H %d",temp,hum-30);
            OLED_ShowString(5,0,buf); 
            sprintf(buf,"ADC %d ",adcx);
            OLED_ShowString(5,20,buf);
            memset(buf,0,16);            
            OLED_Refresh_Gram();	 
                    //ÏÔÊ¾Êý¾Ý
        }
        if(hum_set>0)
        {
             if(adcx>1800+((100-hum_set)*23))  //1800  ËµÃ÷Êµ²âÒ»°ãadc ÔÚ1800 Ë®·Ö³ä×ã
            {
                Relay=0; 
                Beep=1;       //·äÃùÆ÷ ºÍ¼ÌµçÆ÷¹²ÓÃÒ»¸öIO
            }else
            {
                Relay=1;
                Beep=0;
              
            }
        }
        delay_ms(1000);
        
        times++;
	}						
 
}
					    
#include "led.h"
#include "delay.h"
#include "sys.h"
#include "usart.h"
#include "oled.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "scan.h"
extern u8 hum_set,Is_Ture;
u8 out_state[3];

/*
         1.ÏÔÊ¾ÈýÂ·³¬Éù²¨µÄ¾àÀë
         2.µÚ¶þÆÁÄ»ÉèÖÃ ±¨¾¯¾àÀë
*/
void Targ_GPIO()
{
    GPIO_InitTypeDef  GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_10|GPIO_Pin_1;	 //PD3,PD6ÍÆÍìÊä³ö  
 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //ÍÆÍìÊä³ö
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//ËÙ¶È50MHz
 	GPIO_Init(GPIOB, &GPIO_InitStructure);	  //³õÊ¼»¯GPIOD3,6
    
 	GPIO_ResetBits(GPIOB,GPIO_Pin_0|GPIO_Pin_10|GPIO_Pin_1);	//PD3,PD6 Êä³ö¸ß
}
extern volatile u8  TIM4_CAPTURE_STA,state;	//ÊäÈë²¶»ñ×´Ì¬		    				
extern volatile u16 TIM4_CAPTURE_VAL;	//ÊäÈë²¶»ñÖµ
float distance_circulate(u32 date,u8 state)
{
    float dis;
    if(state>0xc1)
        state=0xc1;
    date+=(state-0xc0)*65535;
    date/=2;
    dis=(date*340)/10000.0;
    return dis;
}
u8 dis_warn(float warn,u8 dis)
{
  if((u8)warn<dis)
  {
    TIM_Cmd(TIM2,ENABLE);
    TIM2->PSC=719;
    
      if((u8)warn+2<dis)
       TIM2->PSC=366;
    if((u8)warn+5<dis)
        TIM2->PSC=71;
    return 1;
  }
  return 0;
}
 int main(void)
 { 
    u32 distance[3];
    float dis_save[3];
     float dis_temp;
    u8 distance_warning=10;
	volatile u8 Key_vaule,num_pos=0;
    
	u8 buf[20],buf1[20],Is_distance_set=0,Heart_bit;
	delay_init();	    	 //ÑÓÊ±º¯Êý³õÊ¼»¯	  
	TIM4_Cap_Init(0xffff,71);
    
  //  TIM4_Int_Init(0xffff,71);
    Key_GPIO_Init();  // PA 0-7
     
   // TIM4_Cap_Init(0xffff,71);          //ÈýÂ·³¬Éù²¨³õÊ¼»¯ PB 7-9
     OLED_Init();  //oled³¬ÊæÊÊ»¯  PB 3,4,5,6
    Targ_GPIO();
	memset(buf,0,16);
    memset(buf1,0,16);
    TIME_INIT(); 
    TIM_Cmd(TIM4,ENABLE ); 	//Ê¹ÄÜ¶¨Ê±Æ÷2
	while(1)
	{
      Key_vaule=Key_Scan();
        
       if(Heart_bit>100)
       {
          
 
            state=1;
            PBout(0)=1;
            delay_us(30);
            PBout(0)=0;
            TIM4_CAPTURE_VAL=0;
            while(TIM4_CAPTURE_STA<0xc0);
           out_state[0]=TIM4_CAPTURE_STA;
            distance[0]=TIM4_CAPTURE_VAL;
            TIM4_CAPTURE_STA=0; //ÖØÖÃ±êÖ¾Î»
            state=2;
            PBout(1)=1;
            delay_us(30);
            PBout(1)=0;
            TIM4_CAPTURE_VAL=0;
            while(TIM4_CAPTURE_STA<0xc0);
           out_state[1]=TIM4_CAPTURE_STA;
            distance[1]=TIM4_CAPTURE_VAL;
            TIM4_CAPTURE_STA=0;  //ÖØÖÃ±êÖ¾Î»
            state=3;
            PBout(10)=1;
            delay_us(30);
            PBout(10)=0;
            TIM4_CAPTURE_VAL=0;
           while(TIM4_CAPTURE_STA<0xc0);
           out_state[2]=TIM4_CAPTURE_STA;
           distance[2]=TIM4_CAPTURE_VAL;
           TIM4_CAPTURE_STA=0;  //ÖØÖÃ±êÖ¾Î»
       }
      if(Key_vaule=='A')  
      {
        Is_distance_set=1;
        OLED_Clear();//ÇåÆÁ ÏÔÊ¾ÉèÖÃµÄ¾àÀë
        OLED_ShowString(5,0,"setting/cm");      
        OLED_Refresh_Gram();	 
          
      }
      if(Key_vaule>='0'&&Key_vaule<='9'&&Is_distance_set==1)
      {
        buf[num_pos++]=Key_vaule;
        OLED_ShowString(5,20,buf);  //ÏÔÊ¾°´¼ü
        OLED_Refresh_Gram();
        if(num_pos>3)
            num_pos=0;
      }
      if(Key_vaule=='#'&&(Is_distance_set==1))  //ÉèÖÃ¾àÀë
      {
        Is_distance_set=0;
        if(strlen(buf)>0)
            distance_warning=atoi(buf);
        memset(buf,0,10);
        delay_ms(1000);
        OLED_Clear();
        Heart_bit=111;  //ÎªÁËµÈÏÂÄÜ¿ìËÙ¿´µ½¾àÀë
      }
     
      
     if(Heart_bit>100&&(Is_distance_set==0))
     {
        Heart_bit=0;
         sprintf(buf1,"CH1:%.1f cm",dis_save[0]=distance_circulate(distance[0],out_state[0]));               //²âÁ¿¾àÀë
         OLED_ShowString(5,0,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
         sprintf(buf1,"CH2:%.1f cm",dis_save[1]=distance_circulate(distance[1],out_state[1]));               //²âÁ¿¾àÀë
         OLED_ShowString(5,16,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
         sprintf(buf1,"CH3:%.1f cm",dis_save[2]=distance_circulate(distance[2],out_state[2]));               //²âÁ¿¾àÀë
         OLED_ShowString(5,32,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
     }
     /*-----------------Èý¸öµÈ¼¶----------------------*/
     if(dis_save[0]<distance_warning||dis_save[1]<distance_warning||dis_save[2]<distance_warning)
     {
        dis_warn(dis_save[0],distance_warning);
        dis_warn(dis_save[1],distance_warning);
        dis_warn(dis_save[2],distance_warning);
     }else{
     TIM_Cmd(TIM2,DISABLE);  //DISABLE
     }
//     dis_temp=0;
//     dis_temp+=dis_save[0];
//     dis_temp+=dis_save[1];
//     dis_temp+=dis_save[2];
//     if((int)dis_temp<distance_warning*3)
//     {
//        TIM_Cmd(TIM2,ENABLE);
//        if((int)dis_temp<(distance_warning*3-20))
//         TIM2->PSC=199;
//        if((int)dis_temp<(distance_warning*3-30))
//         TIM2->PSC=71;
//     }else
//     {
//     
//      TIM_Cmd(TIM2,DISABLE);  //DISABLE
//     }
     Heart_bit++;
     delay_ms(10);   
    }
    
}
//TIM_SetCompare2(TIM1,light_table[pre_t][1]);
#include "stm32f10x.h"
#include "led.h"
#include "key.h"
#include "sys.h"
#include "exti.h"
#include "usart.h"
#include "timer.h"
#include "delay.h"
#include <string.h>
#include "adc.h"
#include "oled.h"
#include "oledshow.h"
#include "temperature.h"
#include "mpu6050.h"
#include "step.h"

extern int BPM;          //ÐÄÂÊÖµ        

int main()
{
	Led_Init();		//³õÊ¼»¯LEDµÆ
	OLED_Init();	//³õÊ¼»¯OLED
	Usart_X_Init(USART1,72,115200);	//³õÊ¼»¯´®¿Ú1
	ADC1_Init();	//ADC³õÊ¼»¯
	TimerX_Init(TIM3,72,2000);  //¶¨Ê±ÖÜÆÚ2ms ÓÃÓÚÐÄÂÊ¼ì²â
	
	OLED_Clear();//oledÇåÆÁ
	while(1)
	{
		OLEDPag1();
	}
}


å¶è¯´æå¯¹äºæ æ¥è®²ï¼ä½¿ç¨äºå¤å°åå­ï¼å°±å ç¨å¤å°ç©çé¡µé¢ï¼è¿ä¸å æ¥è®²æ¯ä¸ä¸æ ·çã
ä¸å¤ªæ¸æ¥ä¸ºä»ä¹ä¼è¿ä¹è®¾è®¡ï¼æçæµå¯è½æä¸¤æ¹é¢çåå ï¼
1ã ç¡®å®æ²¡æåéçäºä»¶æ¥è§¦åæ æ®µåå­çåæ¶ã
2ã Linux çæ æ®µè½ç¶å¨å½æ°éåºæ¶ä¸ä¼è¢«éæ¾ï¼ä½å¨ä¸æ¬¡è¿å¥å½æ°æ¶å¯ä»¥å¤ç¨ï¼å æ­¤å¯è½
è®¤ä¸º Linux çæ æ®µåå­éæ¾é®é¢å¯¹äºæ´ä¸ªè¿ç¨çåå­ä½¿ç¨å½±åä¸å¤§ã
èå¯¹æä»¬æ¥è®²ï¼æç¨éå½å½æ°åå¨å½æ°ååéå¤§ååå­ï¼å ä¸ºé£æ¯æä»£ä»·çã
è¯´æè¯¥å­ç¬¦ä½äºå æ®µï¼ç¨åºåç°å¨æ çé¡¶é¨æ æ³ä¿å­æ°çç¯å¢åéï¼å¶ä¾¿å¨å æ®µç³è¯·äº
ä¸æ®µåå­ç¨æ¥ä¿å­ç¯å¢åéã
2ã ç¯å¢åéå­ç¬¦ä¸²æéæ°ç»çå°åä» 0xbefffeac åä¸º 0x11050ã
å ä¸ºç¯å¢åéå­ç¬¦ä¸²æéæ°ç»åå¤äºä¸ä¸ªæéï¼åæ¥çæ çé¡¶é¨å°±æ²¡æç©ºé´ä¿å­äºï¼æ
ä»¥è¿ç¨å¨å æ®µåç³è¯·äºä¸æ®µåå­ï¼ç¨æ¥ä¿å­ææçç¯å¢åéæéã
å æ­¤å¦æè¿ç¨æ°å¢ä¸ä¸ªç¯å¢åéï¼ç³»ç»å°æ¶èçåå­=4Ãç³»ç»ç¯å¢åéæ»æ°+æ°å¢ç¯å¢
åéçé¿åº¦+1ã
æä»¬å¯ä»¥éè¿ glibc çæºç ï¼æ¥è·å¾ç¸å³çä¿¡æ¯ï¼è¯¦ç»å¯ä»¥åè§/glibc/sysdeps/generic/setenv.c
ç__add_to_environ å½æ°ã
å½æä»¬æ´æ°ä¸ä¸ªç¯å¢åéæ¶ï¼libc å¹¶ä¸ä¼å»å¤æ­å¯¹åºçç¯å¢åéæ¯å¦ä¿å­å¨å ä¸­ï¼ç¶åå»è¯
å¾éæ¾å®ï¼èæ¯ç´æ¥å¦å¤åéä¸åå åå­ï¼æ¥ä¿å­æ°çç¯å¢åéå¼ï¼è¿æ¶ä¼æä¸ç¹çåå­æ³
æ¼ï¼å¥½å¨å¹¶ä¸ä¸¥éã
å®å° ELF æä»¶ä¸­æéè¦ä¿å­çä¿¡æ¯æç§ä¿¡æ¯çç±»åãæ ¼å¼çä¸åï¼åå«ä¿å­å¨æä»¶çä¸å
åºåãè¿äºåºåï¼ä¸­ææä»¬å«å®âèâï¼è±æç§°ä¹ä¸ºâsectionâãä¸ºäºè®¿é®è¿äºèåºï¼å¨ ELF
æä»¶ä¸­ååå«äºä¸ä¸ªè¿äºèåºä½ç½®çç´¢å¼ï¼èåºå¤´é¨è¡¨ section headersã
å¦ä¸ç§ä¸»è¦æ¯é¢åç¨åºçå è½½åè¿è¡ï¼ç§°ä¹ä¸ºæ§è¡è§å¾ã
å¨æ§è¡è§å¾ä¸­ï¼å®åä¼å¯¹åé¢æå°ç sectionï¼æç§è¿è¡æ¶çéè¦ï¼ååä¸ºä¸åçç»ï¼ä¸­æ
ç§°ä¹ä¸ºâæ®µâï¼è±æç§°ä¹ä¸ºâsegmentâãä¸ºäºè¯´ææ®µï¼segmentï¼ä¸èï¼sectionï¼çå³ç³»ï¼å¨
ELF æä»¶ä¸­åå¼å¥äºç¨åºå¤´é¨è¡¨ program headersã
èå¨æä»¶å¼å§å¤æ¯ä¸ä¸ª ELF å¤´é¨ï¼ELF Headerï¼
å¯ä»¥çå°ä»åæ¥ç 9172 ä¸ªå­èï¼ç¼©åå° 3628ï¼ææå¾ææ¾ï¼ä¸æ¯åã
4ã æä»¬ä½¿ç¨ readelf æ¥æ¥çä¿®æ¹åç ELF æä»¶çèçæåµã

æä»¬æåçå° section çæ°éä» 39 ä¸ªåå°å° 29 ä¸ªã
5ã æä»¬è¿å¯ä»¥æ.comment èä» ELF æä»¶ä¸­å é¤ã
>strip --remove-section=.comment hello
.bssï¼
ä¸»è¦ç¨æ¥ä¿å­æªåå§åæåå§åä¸ä¸º 0 çå¨å±åéåéæåéã
.dataï¼
ä¸»è¦ç¨æ¥ä¿å­åå§åä¸ä¸º 0 çå¨å±åéæéæåéã
ä¸ºä»ä¹åå¼æ¯å¦ä¸º 0ï¼åå¾å¦æ­¤å³é®å¢ï¼
è¿ä¸»è¦æ¯å ä¸º loader å¯ä»¥å¯¹åå¼ä¸º 0 çåééåä¸å®çä¼åæªæ½ã
å¨ g++ä¸­ï¼const å£°æçæ è¯ç¬¦ï¼å°å·æåé¨é¾æ¥å±æ§ï¼è¿æ¯ä¸ gcc æä¸åçãè¿æ ·å¨ç¼è¯
a1.c æ¶ï¼å¨å±åé m åªæ¯å¨ a1.c ä¸­çæï¼å¶ä»çç¼è¯ååï¼çä¸å°è¯¥å¨å±åé mï¼å¨ç¼è¯
a2.c æ¶ï¼ç¼è¯å¨åçæä¸ä¸ªå¨å±åé mï¼å¶åªæ¯å¨ a2.c ä¸­çæã
æä»¥ï¼æä»¬æä¼çå°å¨ç¼è¯åºæ¥ç hello ä¸­ï¼æä¸¤ä¸ªé½å« m çç¬¦å·
00008540 r m
00008544 r m
å®ä»¬æåä¸åçå°åã
ä¸ºå¼å®¹æ°æ®æ»çº¿å®½åº¦ä¸º 16 ä½çåºç¨ç³»ç»ï¼ ARM ä½ç³»ç»æé¤äºæ¯ææ§è¡æçå¾é«ç 32
ä½ ARM æä»¤éä»¥å¤ï¼åæ¶æ¯æ 16 ä½ç Thumb æä»¤éã Thumb æä»¤éæ¯ ARM æä»¤
éçä¸ä¸ªå­éï¼åè®¸æä»¤ç¼ç ä¸º 16 ä½çé¿åº¦ãä¸ç­ä»·ç 32 ä½ä»£ç ç¸æ¯è¾ï¼ Thumb æä»¤
éå¨ä¿ç 32 ä»£ç ä¼å¿çåæ¶ï¼å¤§å¤§çèçäºç³»ç»çå­å¨ç©ºé´ã
ææç Thumb æä»¤é½æå¯¹åºç ARM æä»¤ï¼èä¸ Thumb çç¼ç¨æ¨¡åä¹å¯¹åºäº ARM ç
ç¼ç¨æ¨¡åï¼å¨åºç¨ç¨åºçç¼åè¿ç¨ä¸­ï¼åªè¦éµå¾ªä¸å®è°ç¨çè§åï¼ Thumb å­ç¨åºå ARM
å­ç¨åºå°±å¯ä»¥äºç¸è°ç¨ãå½å¤çå¨å¨æ§è¡ ARM ç¨åºæ®µæ¶ï¼ç§° ARM å¤çå¨å¤äº ARM å·¥
ä½ç¶æï¼å½å¤çå¨å¨æ§è¡ Thumb ç¨åºæ®µæ¶ï¼ç§° ARM å¤çå¨å¤äº Thumb å·¥ä½ç¶æã
ä¸ ARM æä»¤éç¸æ¯è¾ï¼ Thumb æä»¤éä¸­çæ°æ®å¤çæä»¤çæä½æ°ä»ç¶æ¯ 32 ä½ï¼æä»¤
å°åä¹ä¸º 32 ä½ï¼ä½ Thumb æä»¤éä¸ºå®ç° 16 ä½çæä»¤é¿åº¦ï¼èå¼äº ARM æä»¤éçä¸äº
ç¹æ§ï¼å¦å¤§å¤æ°ç Thumb æä»¤æ¯æ æ¡ä»¶æ§è¡çï¼èå ä¹ææç ARM æä»¤é½æ¯ææ¡ä»¶æ§è¡
çï¼å¤§å¤æ°ç Thumb æ°æ®å¤çæä»¤çç®çå¯å­å¨ä¸å¶ä¸­ä¸ä¸ªæºå¯å­å¨ç¸åã
Thumb æä»¤çç¼è¯

hello.c
#include <stdlib.h>
#include <stdio.h>
int main()
{
printf("hello world!\n");
return 0;
}
ç¼è¯ï¼
#gcc -o hello -mthumb a.c
æä»¬å° a1.c ç¼è¯æ thumb æä»¤:
#gcc -o a1.o -c -mthumb a1.c
å° a2.c ç¼è¯æ ARM æä»¤ï¼
#gcc -o a2.o -c a2.c'
å°å¶é¾æ¥æä¸ä¸ªå¯æ§è¡æä»¶
#gcc -o hello a1.o a2.o
æä»¬ä¸è½½å°è®¾å¤ä¸ï¼è¿è¡ã
# ./hello

ä»ä¸é¢æä»¬å¯ä»¥çå°ï¼ä¸ºäº funca ä¸º Thumb æä»¤ï¼funcb å main ä¸º ARM æä»¤ï¼ä¸ºäºæ¯æ
ARM æä»¤å Thumb æä»¤çè°ç¨ï¼GCC åå®æçæäº 3 ä¸ªå½æ°__funcb_from_thumbã
__funcb_change_to_arm å__funca_from_armã
å¨æåºæä¸¤ç§å¶å è½½æ¹å¼ï¼
1ãéæå è½½
å¨ç¨åºç¼è¯çæ¶åå ä¸â-lâéé¡¹ï¼æå®å¶æä¾èµçå¨æåºï¼è¿ä¸ªåºçåå­å°è®°å½å¨ ELF æ
ä»¶ç.dynamic èãå¨ç¨åºè¿è¡æ¶ï¼loader ä¼é¢åå°ç¨åºæä¾èµçææå¨æåºé½å è½½å¨è¿ç¨ç©º
é´ä¸­ã
éæå è½½çä¼ç¹ï¼
å¨æåºçæ¥å£è°ç¨ç®åï¼å¯ä»¥ç´æ¥è°ç¨ã
ç¼ºç¹ï¼
å¨æåºççå­å¨æç­äºè¿ç¨ççå­å¨æï¼å¶å è½½æ¶æºä¸çµæ´»ã
2ãå¨æå è½½
æä»¬è¿å¯ä»¥å¨ç¨åºä¸­ç¼ç æ¥æå®å è½½å¨æåºçæ¶æºï¼ç»å¸¸ä½¿ç¨çå½æ° dlopen dlcloseã
å¨æå è½½çä¼ç¹ï¼
å¨æåºå è½½çæ¶æºéå¸¸çµæ´»ï¼å¯ä»¥éå¸¸ç»è´çå®ä¹å¨æåºççå­å¨æã
å¨æå è½½çç¼ºç¹:
å¨æåºçæ¥å£è°ç¨èµ·æ¥æ¯è¾éº»ç¦ï¼åæ¶è¿è¦å³æ³¨å¨æåºççå­å¨æã
>gcc âL./ -la hello.c âo hello
>gcc âshared âfPIC

a.c âo liba.so
è½ç¶æä»¬æ²¡æä½¿ç¨ bss æ°æ®ï¼ä½ç³»ç»è¿æ¯å ç¨äºç©çé¡µé¢ï¼è¿å¯è½ä¸è¿ç¨å¤å¶å±äº«åºçæ°æ®
æ®µæé æçã
å æ­¤ï¼ä¸è¦å¨è¿ç¨ä¸­éè¿ extern çæ¹å¼å¼ç¨å±äº«åºä¸­çå¨å±åéï¼ä¸æ¦å¼ç¨ï¼ä¸è®ºå¶æ¯å¦ä½¿
ç¨ï¼é½å°ä¼å ç¨ç©çåå­ãåæ¶è¿ä¼å¢å ç³»ç»å¯å¨æ¶ï¼åå­å¤å¶çä»£ä»·ï¼ä¼å¯¼è´æ§è½çä¸éã
æä»¬ä¹æ³¨æå°ï¼æ°æ®æ®µçå°åä¸å æ æ®µçå°åæ¯è¿ççï¼è¿ä¹å°±æ¯è¯´ï¼å½ä¸»ç¨åºé¾æ¥äºä¸ä¸ª
å±äº«åºçå¨å±åéæ¶ï¼å®ä¼ä¸ºè¯¥åéå®ä¹ä¸ä¸ªå°åï¼ä½å®ä¸ä¼å½±åæ°æ®æ®µçå¤§å°ï¼å°è¯¥å¼æ·
è´å°è¿ä¸ªå°åä¸ãå¦æå°åæ®µä¸å¤ç¨ï¼å®å°å ç¨å æ®µï¼ç³»ç»å°è°ç¨ brk æ¥æ©å±å æ®µã
æä»¬éè¿ strace å¯ä»¥æ¥éªè¯è¿ä¸ªè§ç¹ï¼
å æ­¤ï¼æä»¬å¯ä»¥éè¿è¿ç¨ç.rel.dyn å.rel.pltsection åå±äº«åºä¸­çç¬¦å·ï¼æ¾åºè¿ç¨ä¸å±äº«åºä¹
é´çè°ç¨å³ç³»ã
1ã å¦æå¨å±åéå£°æå¨è¿ç¨ä¸­ï¼å¨å±äº«åºä¸­ä½¿ç¨ï¼åè¯¥åéä½äºè¿ç¨çæ°æ®æ®µã
2ã å¦æå¨å±åéå£°æå¨å±äº«åºä¸­ï¼å¨è¿ç¨ä¸­ä½¿ç¨ï¼åè¯¥åéè¢«å¤å¶å°è¿ç¨çæ°æ®æ®µï¼åæ¶
ä¿®æ¹ä½¿ç¨è¯¥åéçå±äº«åºçæåã
3ã å¦æè¯¥åéå¨å±äº«åºä¸­å£°æï¼å¨å±äº«åºä¸­ä½¿ç¨ï¼åè¯¥åéä½äºå£°æå®çå±äº«åºçæ°æ®æ®µ
ä¸­ã
PIC ä½¿.so æä»¶çä»£ç æ®µåä¸ºçæ­£æä¹ä¸çå±äº«ã
å¦æä¸å -fPIC,åå è½½.so æä»¶çä»£ç æ®µæ¶,ä»£ç æ®µå¼ç¨çæ°æ®å¯¹è±¡éè¦éå®ä½, éå®ä½ä¼ä¿®æ¹
ä»£ç æ®µçåå®¹,è¿å°±é ææ¯ä¸ªä½¿ç¨è¿ä¸ª.so æä»¶ä»£ç æ®µçè¿ç¨å¨åæ ¸éé½ä¼çæè¿ä¸ª.so æä»¶
ä»£ç æ®µç copy.æ¯ä¸ª copy é½ä¸ä¸æ ·,åå³äºè¿ä¸ª.so æä»¶ä»£ç æ®µåæ°æ®æ®µåå­æ å°çä½ç½®.
æä»¬å¯ä»¥ä½¿ç¨ ulimit å½ä»¤ï¼æ¥æ¥çåè®¾ç½®ä¸ä¸ªè¿ç¨çæ ç©ºé´çå¤§å°ï¼
ä¸è¬æåµä¸ï¼ä¸ä¸ªè¿ç¨ææ¥æççº¿ç¨æ°éå¾å°ï¼å¤§æ¦ 10 ä¸ªä»¥åï¼å¦ææ¯ä¸ªçº¿ç¨çæ ä½¿ç¨ 20K
çåå­çè¯ï¼é£ä¹æ»å±æ¶è 200K çåå­ï¼å¯¹ç³»ç»çå½±åè¿æ¯å¾å°çã
æ³¨ï¼æ¯ä¸ä¸ªå±äº«åå­åºé½æä¸ä¸ªæ§å¶ç»æ struct shmid_kernelï¼shmid_kernel æ¯å±äº«åå­åºå
ä¸­éå¸¸éè¦çä¸ä¸ªæ°æ®ç»æï¼å®æ¯å­å¨ç®¡çåæä»¶ç³»ç»ç»åèµ·æ¥çæ¡¥æ¢ï¼å®ä¹å¦ä¸ï¼
æ­£å¦æ¶æ¯éååä¿¡å·ç¯ä¸æ ·ï¼åæ ¸éè¿æ°æ®ç»æ struct ipc_ids shm_ids ç»´æ¤ç³»ç»ä¸­çææå±
äº«åå­åºåãä¸å¾ä¸­ç shm_ids.entries åéæåä¸ä¸ª ipc_id ç»ææ°ç»ï¼èæ¯ä¸ª ipc_id ç»ææ°
ä¸ºä»ä¹æçç¨åºä½¿ç¨äºè¿ä¹å¤çåå­ï¼
ææ ·æ£æµåå­æ³æ¼ï¼
1ã å å¥å¤´æä»¶<mcheck.h>
2ã å¨éè¦åå­æ³æ¼æ£æ¥çä»£ç çå¼å§è°ç¨ void mtrace()ï¼å¨éè¦åå­æ³æ¼æ£æ¥ä»£ç çç»æ
è°ç¨ void muntrace()ã
ä¸è¬æåµä¸ä¸è¦è°ç¨ muntraceï¼èè®©ç¨åºèªç¶ç»æï¼å ä¸ºå¯è½æäºåå­éæ¾ä»£ç è¦å°
muntrace ä¹åè¿è¡ã
3ã ç¨ debug æ¨¡å¼ç¼è¯æ£æ¥ä»£ç ï¼-g æ-ggdbï¼
4ã å¨è¿è¡ç¨åºé±ï¼åè®¾ç½®ç¯å¢åé MALLOC_TRACE ä¸ºä¸æä»¶åï¼è¿ä¸æä»¶å°å­æåå­
åéä¿¡æ¯ã
5ã è¿è¡ç¨åºï¼åå­åéç log å°è¾åºå° MALLOC_TRACE ææåçæä»¶ä¸­ã
å¨ glibc ä¸­ï¼æä¾äº mallocãfreeãreallocãmemalign çé©å­å½æ°ã
ä½ å¯ä»¥æç§é©å­å½æ°çååï¼å®ä¹èªå·±çå½æ°ï¼å¹¶å¨ glibc ä¸­è®¾ç½®ç¸åºçé©å­å½æ°ï¼è¿æ · glibc
å¨å¤çå½æ°æ¶ï¼ä¼è°ç¨ä½ çé©å­å½æ°ï¼ä»èè·å¾ç¸åºçä¿¡æ¯ã
#! /usr/bin/perl
my $log = shift (@ARGV);
open flog ,"<$log" or die "cannot open $log:$!";
while(<flog>)
{
if(/^@@@/)
{
@items = split/\s+/;
if($items[2] eq '+')
{
$size=hex(substr($items[4],2));
$memory{$items[3]}=$size;
}
if($items[2] eq '-')
{
delete $memory{$items[3]};
}
}
}
foreach $key(sort keys %memory)
{
print "$key $memory{$key}\n";
}
4.1. gcc ä¸ g++çä¸å
gcc å g++é½æ¯ GNU çä¸ä¸ªç¼è¯å¨ã
å¾å¤äººé½è®¤ä¸º gcc åªè½ç¼è¯ C ç¨åºï¼è g++åªè½ç¼è¯ C++ä»£ç ãå®éä¸èè¿é½å¯ä»¥ã
1.åç¼ä¸º.c çï¼gcc æå®å½ä½æ¯ C ç¨åºï¼è g++å½ä½æ¯ c++ç¨åºï¼åç¼ä¸º.cpp çï¼ä¸¤èé½ä¼
è®¤ä¸ºæ¯ c++ç¨åºï¼æ³¨æï¼è½ç¶ c++æ¯ c çè¶éï¼ä½æ¯ä¸¤èå¯¹è¯­æ³çè¦æ±æ¯æåºå«çãC++ç
è¯­æ³è§åæ´å ä¸¥è°¨ä¸äºã
2.ç¼è¯é¶æ®µï¼g++ä¼è°ç¨ gccï¼å¯¹äº c++ä»£ç ï¼ä¸¤èæ¯ç­ä»·çï¼ä½æ¯å ä¸º gcc å½ä»¤ä¸è½èªå¨å
Cï¼ï¼ç¨åºä½¿ç¨çåºèæ¥ï¼æä»¥éå¸¸ç¨ g++æ¥å®æé¾æ¥ï¼ä¸ºäºç»ä¸èµ·è§ï¼å¹²èç¼è¯/é¾æ¥ç»ç»
ç¨ g++äºï¼è¿å°±ç»äººä¸ç§éè§ï¼å¥½å cpp ç¨åºåªè½ç¨ g++ä¼¼çã
å¨è¿éæä¸ç¯æç« åäºè¯¦ç»éè¿°ã
http://blog.chinaunix.net/u/30686/showart.php?id=519752
è¿éæè¦çéè¯´æçæ¯ï¼å¨ä½¿ç¨ g++ç¼è¯çæ¶åï¼æ è®ºè¿ä¸ªç¨åºæ¯å¦ä½¿ç¨äºç±»ï¼é½å°ä¼å°ä¾
èµäº C++çå¨æåºï¼libstdc++.soï¼ã
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
pause();
return 0;
}
ç¼è¯ï¼
gcc âo hello hello.c
è¿è¡
# ./hello
# cat maps

æä»¬ä¼åç° hello æä¾èµçåºå¢å äº 3 ä¸ª libstdc++.so libm.so libgcc_s.so,å¶ä¸­ libm.so å
libgcc_s.so æ¯ç± libstdc++.so å¼å¥çãä¸è¦å°çè¿ä¸ä¸ªåºï¼è¿ç¨æ¯å è½½ä¸ä¸ªåºï¼å°±è¦ä¸ºå¶å
éç¸åºçæ°æ®æ®µï¼åä¸äºéå®åå·¥ä½ç­ï¼æ¯ä¸ªåºçæ°æ®æ®µæå°è¦å æ® 4K çç©çåå­ï¼ä¹å°±
æ¯è¯´ä½¿ç¨ g++ç¼è¯åºç helloï¼è¦æ¯ä½¿ç¨ gcc ç¼è¯åºæ¥çï¼æå°åå­å¤äº 12Kã
/proc/sys/vm/pagecache
è¯¥æä»¶ä¸ /proc/sys/vm/buffermem çå·¥ä½åå®¹ä¸æ ·ï¼ä½å®æ¯éå¯¹æä»¶çåå­æ å°åä¸è¬é«é
å®ç°ä¸ä¸ªstm32h750 ADCè¿å·ææ¨¡æçé¨çåè½ï¼åè®¸ç²¾ç¡®å°çæµä¸ä¸ªæå¤ä¸ªæ¨¡æçµåï¼å½æ¨¡æçµåè¶åºå¯ç¼ç¨éå¼æ¶ä¼äº§çä¸ä¸ªä¸­æ­ã
ç¸æ¯èè¨ï¼Androidåæ´è¿ä¸æ­¥ï¼å®æ¯æå¤ä¸ªåºç¨å¥å£ç¹ï¼å¼å¥äºæ´ä¸°å¯çæºå¶ãå¨Androidç³»ç»ä¸­åå®çåææ¯ï¼ç³»ç»ä¼å¨ä¸åçå°æ¹å¯å¨å®ä»¬ï¼è¿åå³äºç¨æ·å½åæ­£å¨åªéä»¥åç¨æ·æ¥ä¸æ¥æ³åçæ¯ä»ä¹ã
å¨å¶ä¸­ä¸ä¸ªæ½è±¡å±ï¼Androidåºç¨çèµ·æ¥åWebåºç¨å¾ç¸ä¼¼ãæ´»å¨ç±»ä¼¼äºWebåºç¨ä¸­çservletãè®¾è®¡è¯å¥½çæ´»å¨è´è´£ç®¡çåä¸ªUIé¡µé¢ï¼æ¯ä¸ªUIé½æèªå·±å¯ä¸çåç§°ãç¨æ·æ ¹æ®è¿äºé¾æ¥ï¼ä»Webé¡µé¢çä¸ä¸ªé¡µé¢è·³è½¬å°å¦ä¸ä¸ªé¡µé¢ï¼èå¨Androidåºç¨ä¸­ï¼ç¨æ·äº¤äºæ¯éè¿intentè°ç¨çãæ°é¡µé¢å¯ä»¥éè¿é¾æ¥å¯¼èªå°èé¡µé¢ãæ­£å¦å¨Webåºç¨ä¸çä¸­ï¼æäºservletæä¾UIåè½ï¼å¶ä»çæä¾æå¡çAPIãå æ­¤ï¼å¨Androidä¸çä¸­ï¼æ´»å¨æä¾UIï¼èServiceåContentProviderç±»ï¼å¾å¿«ä¼ä»ç»ï¼æä¾å¯¹è¿äºæå¡çè®¿é®åè½ãçè§£è¿ç§æ¶æä¸çç¸ä¼¼æ§æå©äºååææå©ç¨Androidæ¡æ¶è®¾è®¡Androidåºç¨ã
Androidåºç¨è¿æä¸äºå¶ä»ç»ä»¶ï¼å·ä½åæ¬ï¼Serviceï¼æå¡ï¼ãContent Providerï¼åå®¹æä¾èï¼åBroadcast Receiverï¼å¹¿æ­æ¥æ¶å¨ï¼ãServiceç±»è´è´£ä¸ºåå°åè½æä¾æ¯æï¼ContentProviderç±»æ¯å¤ä¸ªåºç¨ä½¿ç¨æ°æ®å­å¨çè®¿é®æ¹å¼ï¼Broadcast Receiveræ¯æå¤æ¹æ¥æ¶åºç¨æå¹¿æ­çæå¾ä¿¡æ¯ã
æå°æä»¶çè¯»åï¼é£ä¹ä¸å¾ä¸æå°æä»¶ç³»ç»è¿ä¸ªæä½ç³»ç»ä¸­æä¸ºéè¦çç»æé¨åä¹ä¸ãæä»¶ç³»ç»ç®¡ççç£çä¸­æä»¶çå­å¨æ¹å¼ï¼æ¯å¦æä»¬å¨Linuxç³»ç»ä¸æä¸ä¸ªæä»¶â/home/user/test.datâï¼é¿åº¦ä¸º8 000ä¸ªå­èãé£ä¹æä»¬å¨åå»ºè¿ä¸ªæä»¶çæ¶åï¼Linuxçext3æä»¶ç³»ç»æå¯è½å°è¿ä¸ªæä»¶æç§è¿æ ·çæ¹å¼å­å¨å¨ç£çä¸­ï¼æä»¶çå4 096å­èå­å¨å¨ç£çç1000å·æåºå°1007å·æåºï¼æ¯ä¸ªæåº512å­èï¼8ä¸ªæåºåå¥½4 096å­èï¼æä»¶çç¬¬4 097ä¸ªå­èå°ç¬¬8 000å­èå±3 904ä¸ªå­èï¼å­å¨å¨ç£çç2000å·æåºå°2007å·æåºï¼8ä¸ªæåºä¹æ¯4 096å­èï¼åªä¸è¿åªå­å¨äº3 904ä¸ªææçå­èï¼å©ä¸ç192ä¸ªå­èæ æãå¦ææè¿ä¸ªæä»¶çå­å¨æ¹å¼çä½æ¯ä¸ä¸ªé¾ç¶çç»æï¼å®çç»æå¦å¾1-4æç¤ºã
è¿éæä»¬åç©¿æä¸ä¸ªå³äºç¡¬ççç»æä»ç»ï¼å³äºç¡¬çç»æå¯è½å¾å¤è¯»èå·²ç»æä¸ä¸ªå¤§æ¦çäºè§£ï¼é£å°±æ¯ç¡¬çåºæ¬å­å¨åä½ä¸ºæåºï¼Sectorï¼ï¼æ¯ä¸ªæåºä¸è¬ä¸º512å­èãä¸ä¸ªç¡¬çå¾å¾æå¤ä¸ªççï¼æ¯ä¸ªççåä¸¤é¢ï¼æ¯é¢æç§åå¿åååä¸ºè¥å¹²ä¸ªç£éï¼æ¯ä¸ªç£éååä¸ºè¥å¹²ä¸ªæåºãæ¯å¦ä¸ä¸ªç¡¬çæ2ä¸ªççï¼æ¯ä¸ªçé¢å65 536ç£éï¼æ¯ä¸ªç£éå1 024ä¸ªæåºï¼é£ä¹ç¡¬ççå®¹éå°±æ¯2 * 2 * 65 536 * 1 024 * 512 = 137 438 953 472å­èï¼128GBï¼ãä½æ¯æä»¬å¯ä»¥æ³è±¡ï¼æ¯ä¸ªçé¢ä¸åå¿åçå¨é¿ä¸ä¸æ ·ï¼å¦ææç§æ¯ä¸ªç£éé½æ¥æç¸åæ°éçæåºï¼é£ä¹é è¿çé¢å¤å´çç£éå¯åº¦è¯å®æ¯ååæ´å ç¨çï¼è¿æ ·æ¯æ¯è¾æµªè´¹ç©ºé´çãä½æ¯å¦æä¸åçç£éæåºæ°åä¸åï¼è®¡ç®èµ·æ¥å°±ååéº»ç¦ãä¸ºäºå±è½è¿äºå¤æçç¡¬ä»¶ç»èï¼ç°ä»£çç¡¬çæ®éä½¿ç¨ä¸ç§å«åLBAï¼Logical Block Addressï¼çæ¹å¼ï¼å³æ´ä¸ªç¡¬çä¸­ææçæåºä»0å¼å§ç¼å·ï¼ä¸ç´å°æåä¸ä¸ªæåºï¼è¿ä¸ªæåºç¼å·å«åé»è¾æåºå·ãé»è¾æåºå·æå¼äºææå¤æçç£éãçé¢ä¹ç±»çæ¦å¿µãå½æä»¬ç»åºä¸ä¸ªé»è¾çæåºå·æ¶ï¼ç¡¬çççµå­è®¾å¤ä¼å°å¶è½¬æ¢æå®éççé¢ãç£éç­è¿äºä½ç½®ã
è¿éæä»¬åç©¿æä¸ä¸ªå³äºç¡¬ççç»æä»ç»ï¼å³äºç¡¬çç»æå¯è½å¾å¤è¯»èå·²ç»æä¸ä¸ªå¤§æ¦çäºè§£ï¼é£å°±æ¯ç¡¬çåºæ¬å­å¨åä½ä¸ºæåºï¼Sectorï¼ï¼æ¯ä¸ªæåºä¸è¬ä¸º512å­èãä¸ä¸ªç¡¬çå¾å¾æå¤ä¸ªççï¼æ¯ä¸ªççåä¸¤é¢ï¼æ¯é¢æç§åå¿åååä¸ºè¥å¹²ä¸ªç£éï¼æ¯ä¸ªç£éååä¸ºè¥å¹²ä¸ªæåºãæ¯å¦ä¸ä¸ªç¡¬çæ2ä¸ªççï¼æ¯ä¸ªçé¢å65 536ç£éï¼æ¯ä¸ªç£éå1 024ä¸ªæåºï¼é£ä¹ç¡¬ççå®¹éå°±æ¯2 * 2 * 65 536 * 1 024 * 512 = 137 438 953 472å­èï¼128GBï¼ãä½æ¯æä»¬å¯ä»¥æ³è±¡ï¼æ¯ä¸ªçé¢ä¸åå¿åçå¨é¿ä¸ä¸æ ·ï¼å¦ææç§æ¯ä¸ªç£éé½æ¥æç¸åæ°éçæåºï¼é£ä¹é è¿çé¢å¤å´çç£éå¯åº¦è¯å®æ¯ååæ´å ç¨çï¼è¿æ ·æ¯æ¯è¾æµªè´¹ç©ºé´çãä½æ¯å¦æä¸åçç£éæåºæ°åä¸åï¼è®¡ç®èµ·æ¥å°±ååéº»ç¦ãä¸ºäºå±è½è¿äºå¤æçç¡¬ä»¶ç»èï¼ç°ä»£çç¡¬çæ®éä½¿ç¨ä¸ç§å«åLBAï¼Logical Block Addressï¼çæ¹å¼ï¼å³æ´ä¸ªç¡¬çä¸­ææçæåºä»0å¼å§ç¼å·ï¼ä¸ç´å°æåä¸ä¸ªæåºï¼è¿ä¸ªæåºç¼å·å«åé»è¾æåºå·ãé»è¾æåºå·æå¼äºææå¤æçç£éãçé¢ä¹ç±»çæ¦å¿µãå½æä»¬ç»åºä¸ä¸ªé»è¾çæåºå·æ¶ï¼ç¡¬çççµå­è®¾å¤ä¼å°å¶è½¬æ¢æå®éççé¢ãç£éç­è¿äºä½ç½®ã

æä»¶ç³»ç»ä¿å­äºè¿äºæä»¶çå­å¨ç»æï¼è´è´£ç»´æ¤è¿äºæ°æ®ç»æå¹¶ä¸ä¿è¯ç£çä¸­çæåºè½å¤ææå°ç»ç»åå©ç¨ãé£ä¹å½æä»¬å¨Linuxæä½ç³»ç»ä¸­ï¼è¦è¯»åè¿ä¸ªæä»¶çå4 096ä¸ªå­èæ¶ï¼æä»¬ä¼ä½¿ç¨ä¸ä¸ªreadçç³»ç»è°ç¨æ¥å®ç°ãæä»¶ç³»ç»æ¶å°readè¯·æ±ä¹åï¼å¤æ­åºæä»¶çå4 096ä¸ªå­èä½äºç£çç1000å·é»è¾æåºå°1007å·é»è¾æåºãç¶åæä»¶ç³»ç»å°±åç¡¬çé©±å¨ååºä¸ä¸ªè¯»åé»è¾æåºä¸º1000å·å¼å§ç8ä¸ªæåºçè¯·æ±ï¼ç£çé©±å¨ç¨åºæ¶å°è¿ä¸ªè¯·æ±ä»¥åå°±åç¡¬çååºç¡¬ä»¶å½ä»¤ãåç¡¬ä»¶åéI/Oå½ä»¤çæ¹å¼æå¾å¤ç§ï¼å¶ä¸­æä¸ºå¸¸è§çä¸ç§å°±æ¯éè¿è¯»åI/Oç«¯å£å¯å­å¨æ¥å®ç°ãå¨x86å¹³å°ä¸ï¼å±æ65 536ä¸ªç¡¬ä»¶ç«¯å£å¯å­å¨ï¼ä¸åçç¡¬ä»¶è¢«åéå°äºä¸åçI/Oç«¯å£å°åãCPUæä¾äºä¸¤æ¡ä¸é¨çæä»¤âinâåâoutâæ¥å®ç°å¯¹ç¡¬ä»¶ç«¯å£çè¯»ååã
? ç¬¬0x1F3ï½0x1F6 4ä¸ªå­èçç«¯å£å°åæ¯ç¨æ¥åå¥LBAå°åçï¼é£ä¹1000å·é»è¾æåºçLBAå°åä¸º0x000003E8ï¼æä»¥æä»¬éè¦å¾0x1F3ã0x1F4åå¥0x00ï¼å¾0x1F5åå¥0x03ï¼å¾0x1F6åå¥0xE8ã
? 0x1F2è¿ä¸ªå°åç¨æ¥åå¥å½ä»¤æéè¦è¯»åçæåºæ°ãæ¯å¦è¯»å8ä¸ªæåºå³åå¥8ã

? 0x1F7è¿ä¸ªå°åç¨æ¥åå¥è¦æ§è¡çæä½çå½ä»¤ç ï¼å¯¹äºè¯»åæä½æ¥è¯´ï¼å½ä»¤å­ä¸º0x20ã
æä»¥æä»¬è¦æ§è¡çæä»¤ä¸ºï¼

out 0x1F3, 0x00

out 0x1F4, 0x00

out 0x1F5, 0x03

out 0x1F6, 0xE8

out 0x1F2, 0x08

out 0x1F7, 0x20
? å°åç©ºé´ä¸éç¦» ææç¨åºé½ç´æ¥è®¿é®ç©çå°åï¼ç¨åºæä½¿ç¨çåå­ç©ºé´ä¸æ¯ç¸äºéç¦»çãæ¶æçç¨åºå¯ä»¥å¾å®¹ææ¹åå¶ä»ç¨åºçåå­æ°æ®ï¼ä»¥è¾¾å°ç ´åçç®çï¼æäºéæ¶æçãä½æ¯æè­è«çç¨åºå¯è½ä¸å°å¿ä¿®æ¹äºå¶ä»ç¨åºçæ°æ®ï¼å°±ä¼ä½¿å¶ä»ç¨åºä¹å´©æºï¼è¿å¯¹äºéè¦å®å¨ç¨³å®çè®¡ç®ç¯å¢çç¨æ·æ¥è¯´æ¯ä¸è½å®¹å¿çãç¨æ·å¸æä»å¨ä½¿ç¨è®¡ç®æºçæ¶åï¼å¶ä¸­ä¸ä¸ªä»»å¡å¤±è´¥äºï¼è³å°ä¸ä¼å½±åå¶ä»ä»»å¡ã

? åå­ä½¿ç¨æçä½ ç±äºæ²¡æææçåå­ç®¡çæºå¶ï¼éå¸¸éè¦ä¸ä¸ªç¨åºæ§è¡æ¶ï¼çæ§ç¨åºå°±å°æ´ä¸ªç¨åºè£å¥åå­ä¸­ç¶åå¼å§æ§è¡ãå¦ææä»¬å¿½ç¶éè¦è¿è¡ç¨åºCï¼é£ä¹è¿æ¶åå­ç©ºé´å¶å®å·²ç»ä¸å¤äºï¼è¿æ¶åæä»¬å¯ä»¥ç¨çä¸ä¸ªåæ³æ¯å°å¶ä»ç¨åºçæ°æ®ææ¶åå°ç£çéé¢ï¼ç­å°éè¦ç¨å°çæ¶ååè¯»åæ¥ãç±äºç¨åºæéè¦çç©ºé´æ¯è¿ç»­çï¼é£ä¹è¿ä¸ªä¾å­éé¢ï¼å¦ææä»¬å°ç¨åºAæ¢åºå°ç£çæéæ¾çåå­ç©ºé´æ¯ä¸å¤çï¼æä»¥åªè½å°Bæ¢åºå°ç£çï¼ç¶åå°Cè¯»å¥å°åå­å¼å§è¿è¡ãå¯ä»¥çå°æ´ä¸ªè¿ç¨ä¸­æå¤§éçæ°æ®å¨æ¢å¥æ¢åºï¼å¯¼è´æçååä½ä¸ã

? ç¨åºè¿è¡çå°åä¸ç¡®å® å ä¸ºç¨åºæ¯æ¬¡éè¦è£å¥è¿è¡æ¶ï¼æä»¬é½éè¦ç»å®ä»åå­ä¸­åéä¸åè¶³å¤å¤§çç©ºé²åºåï¼è¿ä¸ªç©ºé²åºåçä½ç½®æ¯ä¸ç¡®å®çãè¿ç»ç¨åºçç¼åé æäºä¸å®çéº»ç¦ï¼å ä¸ºç¨åºå¨ç¼åæ¶ï¼å®è®¿é®æ°æ®åæä»¤è·³è½¬æ¶çç®æ å°åå¾å¤é½æ¯åºå®çï¼è¿æ¶åç¨åºçéå®ä½é®é¢ï¼æä»¬å¨ç¬¬2é¨ååç¬¬3é¨åè¿ä¼è¯¦ç»æ¢è®¨éå®ä½çé®é¢ã

è§£å³è¿å ä¸ªé®é¢çæè·¯å°±æ¯ä½¿ç¨æä»¬åææå°è¿çæ³å®ï¼å¢å ä¸­é´å±ï¼å³ä½¿ç¨ä¸ç§é´æ¥çå°åè®¿é®æ¹æ³ãæ´ä¸ªæ³æ³æ¯è¿æ ·çï¼æä»¬æç¨åºç»åºçå°åçä½æ¯ä¸ç§èæå°åï¼Virtual Addressï¼ï¼ç¶åéè¿æäºæ å°çæ¹æ³ï¼å°è¿ä¸ªèæå°åè½¬æ¢æå®éçç©çå°åãè¿æ ·ï¼åªè¦æä»¬è½å¤å¦¥åå°æ§å¶è¿ä¸ªèæå°åå°ç©çå°åçæ å°è¿ç¨ï¼å°±å¯ä»¥ä¿è¯ä»»æä¸ä¸ªç¨åºæè½å¤è®¿é®çç©çåå­åºåè·å¦å¤ä¸ä¸ªç¨åºç¸äºä¸éå ï¼ä»¥è¾¾å°å°åç©ºé´éç¦»çææã

write a stm32f103 example to explain 

åè®¾æä»¬çè®¡ç®æºæ128 MBåå­ï¼ç¨åºAè¿è¡éè¦10 MBï¼ç¨åºBéè¦100 MBï¼ç¨åºCéè¦20 MBãå¦ææä»¬éè¦åæ¶è¿è¡ç¨åºAåBï¼é£ä¹æ¯è¾ç´æ¥çåæ³æ¯å°åå­çå10 MBåéç»ç¨åºAï¼10 MBï½110 MBåéç»Bãè¿æ ·å°±è½å¤å®ç°AåBä¸¤ä¸ªç¨åºåæ¶è¿è¡ï¼ä½æ¯è¿ç§ç®åçåå­åéç­ç¥é®é¢å¾å¤ã

? å°åç©ºé´ä¸éç¦» ææç¨åºé½ç´æ¥è®¿é®ç©çå°åï¼ç¨åºæä½¿ç¨çåå­ç©ºé´ä¸æ¯ç¸äºéç¦»çãæ¶æçç¨åºå¯ä»¥å¾å®¹ææ¹åå¶ä»ç¨åºçåå­æ°æ®ï¼ä»¥è¾¾å°ç ´åçç®çï¼æäºéæ¶æçãä½æ¯æè­è«çç¨åºå¯è½ä¸å°å¿ä¿®æ¹äºå¶ä»ç¨åºçæ°æ®ï¼å°±ä¼ä½¿å¶ä»ç¨åºä¹å´©æºï¼è¿å¯¹äºéè¦å®å¨ç¨³å®çè®¡ç®ç¯å¢çç¨æ·æ¥è¯´æ¯ä¸è½å®¹å¿çãç¨æ·å¸æä»å¨ä½¿ç¨è®¡ç®æºçæ¶åï¼å¶ä¸­ä¸ä¸ªä»»å¡å¤±è´¥äºï¼è³å°ä¸ä¼å½±åå¶ä»ä»»å¡ã

æå¼å§äººä»¬ä½¿ç¨çæ¯ä¸ç§å«ååæ®µï¼Segmentationï¼çæ¹æ³ï¼åºæ¬æè·¯æ¯æä¸æ®µä¸ç¨åºæéè¦çåå­ç©ºé´å¤§å°çèæç©ºé´æ å°å°æä¸ªå°åç©ºé´ãæ¯å¦ç¨åºAéè¦10 MBåå­ï¼é£ä¹æä»¬åè®¾æä¸ä¸ªå°åä»0x00000000å°0x00A00000ç10MBå¤§å°çä¸ä¸ªåè±¡çç©ºé´ï¼ä¹å°±æ¯èæç©ºé´ï¼ç¶åæä»¬ä»å®éçç©çåå­ä¸­åéä¸ä¸ªç¸åå¤§å°çç©çå°åï¼åè®¾æ¯ç©çå°å0x00100000å¼å§å°0x00B00000ç»æçä¸åç©ºé´ãç¶åæä»¬æè¿ä¸¤åç¸åå¤§å°çå°åç©ºé´ä¸ä¸æ å°ï¼å³èæç©ºé´ä¸­çæ¯ä¸ªå­èç¸å¯¹åºäºç©çç©ºé´ä¸­çæ¯ä¸ªå­èãè¿ä¸ªæ å°è¿ç¨ç±è½¯ä»¶æ¥è®¾ç½®ï¼æ¯å¦æä½ç³»ç»æ¥è®¾ç½®è¿ä¸ªæ å°å½æ°ï¼å®éçå°åè½¬æ¢ç±ç¡¬ä»¶å®æãæ¯å¦å½ç¨åºAä¸­è®¿é®å°å0x00001000æ¶ï¼CPUä¼å°è¿ä¸ªå°åè½¬æ¢æå®éçç©çå°å0x00101000ãé£ä¹æ¯å¦ç¨åºAåç¨åºBå¨è¿è¡æ¶ï¼å®ä»¬çèæç©ºé´åç©çç©ºé´æ å°å³ç³»å¯è½å¦å¾1-5æç¤ºã
åé¡µçåºæ¬æ¹æ³æ¯æå°åç©ºé´äººä¸ºå°ç­åæåºå®å¤§å°çé¡µï¼æ¯ä¸é¡µçå¤§å°ç±ç¡¬ä»¶å³å®ï¼æç¡¬ä»¶æ¯æå¤ç§å¤§å°çé¡µï¼ç±æä½ç³»ç»éæ©å³å®é¡µçå¤§å°ãæ¯å¦Intel Pentiumç³»åå¤çå¨æ¯æ4KBæ4MBçé¡µå¤§å°ï¼é£ä¹æä½ç³»ç»å¯ä»¥éæ©æ¯é¡µå¤§å°ä¸º4KBï¼ä¹å¯ä»¥éæ©æ¯é¡µå¤§å°ä¸º4MBï¼ä½æ¯å¨åä¸æ¶å»åªè½éæ©ä¸ç§å¤§å°ï¼æä»¥å¯¹æ´ä¸ªç³»ç»æ¥è¯´ï¼é¡µå°±æ¯åºå®å¤§å°çãç®åå ä¹ææçPCä¸çæä½ç³»ç»é½ä½¿ç¨4KBå¤§å°çé¡µãæä»¬ä½¿ç¨çPCæºæ¯32ä½çèæå°åç©ºé´ï¼ä¹å°±æ¯4GBï¼é£ä¹æ4KBæ¯é¡µåçè¯ï¼æ»å±æ1 048 576ä¸ªé¡µãç©çç©ºé´ä¹æ¯åæ ·çåæ³ã
çº¿ç¨ï¼Threadï¼ï¼ææ¶è¢«ç§°ä¸ºè½»éçº§è¿ç¨ï¼Lightweight Process, LWPï¼ï¼æ¯ç¨åºæ§è¡æµçæå°ååãä¸ä¸ªæ åççº¿ç¨ç±çº¿ç¨IDãå½åæä»¤æéï¼PCï¼ãå¯å­å¨éååå æ ç»æãéå¸¸æä¹ä¸ï¼ä¸ä¸ªè¿ç¨ç±ä¸ä¸ªå°å¤ä¸ªçº¿ç¨ç»æï¼åä¸ªçº¿ç¨ä¹é´å±äº«ç¨åºçåå­ç©ºé´ï¼åæ¬ä»£ç æ®µãæ°æ®æ®µãå ç­ï¼åä¸äºè¿ç¨çº§çèµæºï¼å¦æå¼æä»¶åä¿¡å·ï¼ãä¸ä¸ªç»å¸ççº¿ç¨ä¸è¿ç¨çå³ç³»å¦å¾1-8æç¤ºã
æä¸ªæä½å¯è½ä¼é·å¥é¿æ¶é´ç­å¾ï¼ç­å¾ççº¿ç¨ä¼è¿å¥ç¡ç ç¶æï¼æ æ³ç»§ç»­æ§è¡ãå¤çº¿ç¨æ§è¡å¯ä»¥ææå©ç¨ç­å¾çæ¶é´ãå¸åçä¾å­æ¯ç­å¾ç½ç»ååºï¼è¿å¯è½è¦è±è´¹æ°ç§çè³æ°åç§ã

æä¸ªæä½ï¼å¸¸å¸¸æ¯è®¡ç®ï¼ä¼æ¶èå¤§éçæ¶é´ï¼å¦æåªæä¸ä¸ªçº¿ç¨ï¼ç¨åºåç¨æ·ä¹é´çäº¤äºä¼ä¸­æ­ãå¤çº¿ç¨å¯ä»¥è®©ä¸ä¸ªçº¿ç¨è´è´£äº¤äºï¼å¦ä¸ä¸ªçº¿ç¨è´è´£è®¡ç®ã

ç¨åºé»è¾æ¬èº«å°±è¦æ±å¹¶åæä½ï¼ä¾å¦ä¸ä¸ªå¤ç«¯ä¸è½½è½¯ä»¶ï¼ä¾å¦Bittorrentï¼ã

å¤CPUæå¤æ ¸è®¡ç®æºï¼åºæ¬å°±æ¯æªæ¥çä¸»æµè®¡ç®æºï¼ï¼æ¬èº«å·å¤åæ¶æ§è¡å¤ä¸ªçº¿ç¨çè½åï¼å æ­¤åçº¿ç¨ç¨åºæ æ³å¨é¢å°åæ¥è®¡ç®æºçå¨é¨è®¡ç®è½åã

ç¸å¯¹äºå¤è¿ç¨åºç¨ï¼å¤çº¿ç¨å¨æ°æ®å±äº«æ¹é¢æçè¦é«å¾å¤ã
çº¿ç¨è°åº¦ä¸ä¼åçº§

ä¸è®ºæ¯å¨å¤å¤çå¨çè®¡ç®æºä¸è¿æ¯å¨åå¤çå¨çè®¡ç®æºä¸ï¼çº¿ç¨æ»æ¯âå¹¶åâæ§è¡çãå½çº¿ç¨æ°éå°äºç­äºå¤çå¨æ°éæ¶ï¼å¹¶ä¸æä½ç³»ç»æ¯æå¤å¤çå¨ï¼ï¼çº¿ç¨çå¹¶åæ¯çæ­£çå¹¶åï¼ä¸åççº¿ç¨è¿è¡å¨ä¸åçå¤çå¨ä¸ï¼å½¼æ­¤ä¹é´äºä¸ç¸å¹²ãä½å¯¹äºçº¿ç¨æ°éå¤§äºå¤çå¨æ°éçæåµï¼çº¿ç¨çå¹¶åä¼åå°ä¸äºé»ç¢ï¼å ä¸ºæ­¤æ¶è³å°æä¸ä¸ªå¤çå¨ä¼è¿è¡å¤ä¸ªçº¿ç¨ã

å¨åå¤çå¨å¯¹åºå¤çº¿ç¨çæåµä¸ï¼å¹¶åæ¯ä¸ç§æ¨¡æåºæ¥çç¶æãæä½ç³»ç»ä¼è®©è¿äºå¤çº¿ç¨ç¨åºè½®æµæ§è¡ï¼æ¯æ¬¡ä»æ§è¡ä¸å°æ®µæ¶é´ï¼éå¸¸æ¯å åå°å ç¾æ¯«ç§ï¼ï¼è¿æ ·æ¯ä¸ªçº¿ç¨å°±âçèµ·æ¥âå¨åæ¶æ§è¡ãè¿æ ·çä¸ä¸ªä¸æ­å¨å¤çå¨ä¸åæ¢ä¸åççº¿ç¨çè¡ä¸ºç§°ä¹ä¸ºçº¿ç¨è°åº¦ï¼Thread Scheduleï¼ãå¨çº¿ç¨è°åº¦ä¸­ï¼çº¿ç¨éå¸¸æ¥æè³å°ä¸ç§ç¶æï¼åå«æ¯ï¼

è¿è¡ï¼Runningï¼ï¼æ­¤æ¶çº¿ç¨æ­£å¨æ§è¡ã

å°±ç»ªï¼Readyï¼ï¼æ­¤æ¶çº¿ç¨å¯ä»¥ç«å»è¿è¡ï¼ä½CPUå·²ç»è¢«å ç¨ã

ç­å¾ï¼Waitingï¼ï¼æ­¤æ¶çº¿ç¨æ­£å¨ç­å¾æä¸äºä»¶ï¼éå¸¸æ¯I/Oæåæ­¥ï¼åçï¼æ æ³æ§è¡ã
è¯¥ç®å½ä¸æä»¶æ°ç®å¾å¤ï¼ä½æä»¬ä¸»è¦å³æ³¨ in_voltage3_rawãin_voltage_scale è¿ä¸¤ä¸ªæä»¶å³å¯ï¼å¶
ä¸­ in_voltage3_raw ä¸ºè¯»å adc æ°æ®çåå§æ°å¼ï¼in_voltage_scale ä¸º adc æ°æ®ä¸çµåå¼æ¢ç®æ¯ä¾ï¼
å°ä»è¿ä¸¤ä¸ªè¯»åå°çæ°æ®ç¸ä¹å³å¯å¾å°æä»¬æ³è¦çæ¿è½½çµä½å¨ä¸ççµåå¼ã
ç±äºè¯»åçµåå¼ç¸å¯¹ç®åï¼æ¥ä¸æ¥æä»¬å°ç¼åç®åç shell èæ¬è·åçµåå¼ã
	pthread_detach(id);
    queue_init(&bindReqQueue, sizeof(bindReq_t), 1);
    queue_init(&bindRespQueue, sizeof(bindReq_t), 1);
    queue_init(&secondaryBufferQueue, sizeof(secondaryBufferItem_t), NUM_SECONDARY_BUFFERS);
	c := http.Cookie{
		Name:    flashName,
		Value:   base64.URLEncoding.EncodeToString(value),
		Path:    "/",
		Expires: expire,
		MaxAge:  3,
	}
	http.SetCookie(w, &c)
func GetMessage(w http.ResponseWriter, r *http.Request) ([]byte, error) {
	log.Info("[flash] begin get message...")
	c, err := r.Cookie(flashName)
	if err != nil {
		switch err {
		case http.ErrNoCookie:
			return nil, nil
		default:
			return nil, err
		}
	}

	// delete cookie
	dc := http.Cookie{
		Name:    flashName,
		Path:    "/",
		MaxAge:  -1,
		Expires: time.Unix(1, 0),
	}
	http.SetCookie(w, &dc)

	value, err := base64.URLEncoding.DecodeString(c.Value)
	if err != nil {
		return nil, err
	}

	return value, nil
}
   ©¦1823    void init_cgroup_root(struct cgroup_root *root, struct cgroup_sb_opts *opts)                                              ©¦
   ©¦1824    {                                                                                                                         ©¦
   ©¦1825            struct cgroup *cgrp = &root->cgrp;                                                                                ©¦
   ©¦1826                                                                                                                              ©¦
  >©¦1827            INIT_LIST_HEAD(&root->root_list);                                                                                 ©¦
   ©¦1828            atomic_set(&root->nr_cgrps, 1);                                                                                   ©¦
   ©¦1829            cgrp->root = root;                                                                                                ©¦
   ©¦1830            init_cgroup_housekeeping(cgrp);                                                                                   ©¦
   ©¦1831            idr_init(&root->cgroup_idr);                                                                                      ©¦
   ©¦1832                                                                                                                              ©¦
   ©¦1833            root->flags = opts->flags;                                                                                        ©¦
   ©¦1834            if (opts->release_agent)                                                                                          ©¦
   ©¦1835                    strcpy(root->release_agent_path, opts->release_agent);                                                    ©¦
   ©¦1836            if (opts->name)                                                                                                   ©¦
   ©¦1837                    strcpy(root->name, opts->name);                                                                           ©¦
   ©¦1838            if (opts->cpuset_clone_children)                                                                                  ©¦
   ©¦300     static __always_inline void __write_once_size(volatile void *p, void *res, int size)                                      ©¦
   ©¦301     {                                                                                                                         ©¦
   ©¦302             switch (size) {                                                                                                   ©¦
   ©¦303             case 1: *(volatile __u8 *)p = *(__u8 *)res; break;                                                                ©¦
   ©¦304             case 2: *(volatile __u16 *)p = *(__u16 *)res; break;                                                              ©¦
  >©¦305             case 4: *(volatile __u32 *)p = *(__u32 *)res; break;                                                              ©¦
   ©¦306             case 8: *(volatile __u64 *)p = *(__u64 *)res; break;                                                              ©¦
   ©¦307             default:                                                                                                          ©¦
   ©¦308                     barrier();                                                                                                ©¦
   ©¦309                     __builtin_memcpy((void *)p, (const void *)res, size);                                                     ©¦
   ©¦310                     barrier();                                                                                                ©¦
   ©¦311             }                                                                                                                 ©¦
   ©¦312     }                                                                                                                         ©¦
   ©¦1800    static void init_cgroup_housekeeping(struct cgroup *cgrp)                                                                 ©¦
   ©¦1801    {                                                                                                                         ©¦
   ©¦1802            struct cgroup_subsys *ss;                                                                                         ©¦
   ©¦1803            int ssid;                                                                                                         ©¦
   ©¦1804                                                                                                                              ©¦
   ©¦1805            INIT_LIST_HEAD(&cgrp->self.sibling);                                                                              ©¦
   ©¦1806            INIT_LIST_HEAD(&cgrp->self.children);                                                                             ©¦
   ©¦1807            INIT_LIST_HEAD(&cgrp->cset_links);                                                                                ©¦
   ©¦1808            INIT_LIST_HEAD(&cgrp->pidlists);                                                                                  ©¦
  >©¦1809            mutex_init(&cgrp->pidlist_mutex);                                                                                 ©¦
   ©¦1810            cgrp->self.cgroup = cgrp;                                                                                         ©¦
   ©¦1811            cgrp->self.flags |= CSS_ONLINE;                                                                                   ©¦
   ©¦1812            cgrp->dom_cgrp = cgrp;                                                                                            ©¦
   ©¦1813            cgrp->max_descendants = INT_MAX;                                                                                  ©¦
   ©¦1814            cgrp->max_depth = INT_MAX;                                                                                        ©¦
   ©¦1815                                                                                                                              ©¦
   ©¦1816            for_each_subsys(ss, ssid)                                                                                         ©¦
   ©¦1817                    INIT_LIST_HEAD(&cgrp->e_csets[ssid]);                                                                     ©¦
   ©¦1818                                                                                                                              ©¦
   ©¦1819            init_waitqueue_head(&cgrp->offline_waitq);                                                                        ©¦
   ©¦1820            INIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);                                                      ©¦
   ©¦1821    }                                                                                                                         ©¦
   ©¦152     static inline void idr_init(struct idr *idr)                                                                              ©¦
   ©¦153     {                                                                                                                         ©¦
  >©¦154             INIT_RADIX_TREE(&idr->idr_rt, IDR_RT_MARKER);                                                                     ©¦
   ©¦155             idr->idr_next = 0;                                                                                                ©¦
   ©¦156     }                                                                                                                         ©¦
   ©¦47      static inline void arch_local_irq_disable(void)                                                                           ©¦
   ©¦48      {                                                                                                                         ©¦
  >©¦49              asm volatile(                                                                                                     ©¦
   ©¦50                      "       cpsid i                 @ arch_local_irq_disable"                                                 ©¦
   ©¦51                      :                                                                                                         ©¦
   ©¦52                      :                                                                                                         ©¦
   ©¦53                      : "memory", "cc");                                                                                        ©¦
   ©¦54      }                                                                                                                         ©¦
   ©¦2007    void __init boot_cpu_init(void)                                                                                           ©¦
   ©¦2008    {                                                                                                                         ©¦
  >©¦2009            int cpu = smp_processor_id();                                                                                     ©¦
   ©¦2010                                                                                                                              ©¦
   ©¦2011            /* Mark the boot cpu "present", "online" etc for SMP and UP case */                                               ©¦
   ©¦2012            set_cpu_online(cpu, true);                                                                                        ©¦
   ©¦2013            set_cpu_active(cpu, true);                                                                                        ©¦
   ©¦2014            set_cpu_present(cpu, true);                                                                                       ©¦
   ©¦2015            set_cpu_possible(cpu, true);                                                                                      ©¦
   ©¦2016                                                                                                                              ©¦
   ©¦2017    #ifdef CONFIG_SMP                                                                                                         ©¦
   ©¦2018            __boot_cpu_id = cpu;                                                                                              ©¦
   ©¦2019    #endif                                                                                                                    ©¦
   ©¦2020    }                                                                                                                         ©¦
   ©¦372     static void __init setup_command_line(char *command_line)                                                                 ©¦
   ©¦373     {                                                                                                                         ©¦
  >©¦374             saved_command_line =                                                                                              ©¦
   ©¦375                     memblock_virt_alloc(strlen(boot_command_line) + 1, 0);                                                    ©¦
   ©¦376             initcall_command_line =                                                                                           ©¦
   ©¦377                     memblock_virt_alloc(strlen(boot_command_line) + 1, 0);                                                    ©¦
   ©¦378             static_command_line = memblock_virt_alloc(strlen(command_line) + 1, 0);                                           ©¦
   ©¦379             strcpy(saved_command_line, boot_command_line);                                                                    ©¦
   ©¦380             strcpy(static_command_line, command_line);                                                                        ©¦
   ©¦381     }                                                                                                                         ©¦
   ©¦382                                                                                                                               ©¦
   ©¦169     __lookup_processor_type:                                                                                                  ©¦
B+>©¦170             adr     r3, __lookup_processor_type_data                                                                          ©¦
   ©¦171             ldmia   r3, {r4 - r6}                                                                                             ©¦
   ©¦172             sub     r3, r3, r4                      @ get offset between virt&phys                                            ©¦
   ©¦173             add     r5, r5, r3                      @ convert virt addresses to                                               ©¦
   ©¦174             add     r6, r6, r3                      @ physical address space                                                  ©¦
   ©¦175     1:      ldmia   r5, {r3, r4}                    @ value, mask                                                             ©¦
   ©¦176             and     r4, r4, r9                      @ mask wanted bits                                                        ©¦
   ©¦177             teq     r3, r4                                                                                                    ©¦
   ©¦178             beq     2f                                                                                                        ©¦
   ©¦179             add     r5, r5, #PROC_INFO_SZ           @ sizeof(proc_info_list)                                                  ©¦
   ©¦180             cmp     r5, r6                                                                                                    ©¦
   ©¦181             blo     1b                                                                                                        ©¦
   ©¦243     static int __get_cpu_architecture(void)                                                                                   ©¦
   ©¦244     {                                                                                                                         ©¦
   ©¦245             int cpu_arch;                                                                                                     ©¦
   ©¦246                                                                                                                               ©¦
  >©¦247             if ((read_cpuid_id() & 0x0008f000) == 0) {                                                                        ©¦
   ©¦248                     cpu_arch = CPU_ARCH_UNKNOWN;                                                                              ©¦
   ©¦249             } else if ((read_cpuid_id() & 0x0008f000) == 0x00007000) {                                                        ©¦
   ©¦250                     cpu_arch = (read_cpuid_id() & (1 << 23)) ? CPU_ARCH_ARMv4T : CPU_ARCH_ARMv3;                              ©¦
   ©¦251             } else if ((read_cpuid_id() & 0x00080000) == 0x00000000) {                                                        ©¦
   ©¦252                     cpu_arch = (read_cpuid_id() >> 16) & 7;                                                                   ©¦
   ©¦253                     if (cpu_arch)                                                                                             ©¦
   ©¦254                             cpu_arch += CPU_ARCH_ARMv3;                                                                       ©¦
   ©¦255             } else if ((read_cpuid_id() & 0x000f0000) == 0x000f0000) {                                                        ©¦
   ©¦256                     /* Revised CPUID format. Read the Memory Model Feature                                                    ©¦
   ©¦257                      * Register 0 and check for VMSAv7 or PMSAv7 */                                                           ©¦
   ©¦258                     unsigned int mmfr0 = read_cpuid_ext(CPUID_EXT_MMFR0);                                                     ©¦
   ©¦259                     if ((mmfr0 & 0x0000000f) >= 0x00000003 ||                                                                 ©¦
   ©¦690     #ifdef MULTI_CPU                                                                                                          ©¦
  >©¦691             processor = *list->proc;                                                                                          ©¦
   ©¦692     #endif                                                                                                                    ©¦
   ©¦693     #ifdef MULTI_TLB                                                                                                          ©¦
   ©¦694             cpu_tlb = *list->tlb;                                                                                             ©¦
   ©¦695     #endif                                                                                                                    ©¦
   ©¦696     #ifdef MULTI_USER                                                                                                         ©¦
   ©¦697             cpu_user = *list->user;                                                                                           ©¦
   ©¦698     #endif                                                                                                                    ©¦
   ©¦699     #ifdef MULTI_CACHE                                                                                                        ©¦
$12 = (struct proc_info_list *) 0x806714e4 <__v7_ca9mp_proc_info>
(gdb) p *list
$13 = {cpu_val = 1091551376, cpu_mask = 4279238640, __cpu_mm_mmu_flags = 3086, __cpu_io_mmu_flags = 3074, __cpu_flush = 4289359672,
  arch_name = 0x807015a8 <cpu_arch_name> "armv7", elf_name = 0x807015ae <cpu_elf_name> "v7", elf_hwcap = 32919,
  cpu_name = 0x80118340 <cpu_v7_name> "ARMv7 Processor", proc = 0x80955094 <ca9mp_processor_functions>,
  tlb = 0x80907810 <v7wbi_tlb_fns>, user = 0x8095502c <v6_user_fns>, cache = 0x80955000 <v7_cache_fns>}
   ©¦702                                                                                                                               ©¦
  >©¦703             pr_info("CPU: %s [%08x] revision %d (ARMv%s), cr=%08lx\n",                                                        ©¦
   ©¦704                     cpu_name, read_cpuid_id(), read_cpuid_id() & 15,                                                          ©¦
   ©¦705                     proc_arch[cpu_architecture()], get_cr());                                                                 ©¦
   ©¦706                                                                                                                               ©¦
   ©¦707             snprintf(init_utsname()->machine, __NEW_UTS_LEN + 1, "%s%c",                                                      ©¦
   ©¦708                      list->arch_name, ENDIANNESS);                                                                            ©¦
   ©¦709             snprintf(elf_platform, ELF_PLATFORM_SIZE, "%s%c",                                                                 ©¦
   ©¦710                      list->elf_name, ENDIANNESS);                                                                             ©¦
   ©¦711             elf_hwcap = list->elf_hwcap;                                                                                      ©¦
   ©¦712                                                                                                                               ©¦
   ©¦713             cpuid_init_hwcaps();                                                                                              ©¦
   ©¦714             patch_aeabi_idiv();                                                                                               ©¦
   ©¦136     void __init init_default_cache_policy(unsigned long pmd)                                                                  ©¦
   ©¦137     {                                                                                                                         ©¦
   ©¦138             int i;                                                                                                            ©¦
   ©¦139                                                                                                                               ©¦
  >©¦140             initial_pmd_value = pmd;                                                                                          ©¦
   ©¦141                                                                                                                               ©¦
   ©¦142             pmd &= PMD_SECT_CACHE_MASK;                                                                                       ©¦
   ©¦143                                                                                                                               ©¦
   ©¦144             for (i = 0; i < ARRAY_SIZE(cache_policies); i++)                                                                  ©¦
   ©¦145                     if (cache_policies[i].pmd == pmd) {                                                                       ©¦
   ©¦146                             cachepolicy = i;                                                                                  ©¦
   ©¦147                             break;                                                                                            ©¦
   ©¦148                     }                                                                                                         ©¦
   ©¦149                                                                                                                               ©¦
   ©¦150             if (i == ARRAY_SIZE(cache_policies))                                                                              ©¦
   ©¦151                     pr_err("ERROR: could not find cache policy\n");                                                           ©¦
   ©¦152     }                                                                                                                         ©¦
  >©¦345             pr_info("CPU: %s data cache, %s instruction cache\n",                                                             ©¦
   ©¦346                     cache_is_vivt() ? "VIVT" :                                                                                ©¦
   ©¦347                     cache_is_vipt_aliasing() ? "VIPT aliasing" :                                                              ©¦
   ©¦348                     cache_is_vipt_nonaliasing() ? "PIPT / VIPT nonaliasing" : "unknown",                                      ©¦
   ©¦349                     cache_is_vivt() ? "VIVT" :                                                                                ©¦
   ©¦350                     icache_is_vivt_asid_tagged() ? "VIVT ASID tagged" :                                                       ©¦
   ©¦351                     icache_is_vipt_aliasing() ? "VIPT aliasing" :                                                             ©¦
   ©¦352                     icache_is_pipt() ? "PIPT" :                                                                               ©¦
   ©¦353                     cache_is_vipt_nonaliasing() ? "VIPT nonaliasing" : "unknown");                                            ©¦
  >©¦553             __asm__ (                                                                                                         ©¦
   ©¦554             "msr    cpsr_c, %1\n\t"                                                                                           ©¦
   ©¦555             "add    r14, %0, %2\n\t"                                                                                          ©¦
   ©¦556             "mov    sp, r14\n\t"                                                                                              ©¦
   ©¦557             "msr    cpsr_c, %3\n\t"                                                                                           ©¦
   ©¦558             "add    r14, %0, %4\n\t"                                                                                          ©¦
   ©¦559             "mov    sp, r14\n\t"                                                                                              ©¦
   ©¦560             "msr    cpsr_c, %5\n\t"                                                                                           ©¦
   ©¦561             "add    r14, %0, %6\n\t"                                                                                          ©¦
   ©¦562             "mov    sp, r14\n\t"                                                                                              ©¦
   ©¦563             "msr    cpsr_c, %7\n\t"                                                                                           ©¦
   ©¦564             "add    r14, %0, %8\n\t"                                                                                          ©¦
   ©¦565             "mov    sp, r14\n\t"                                                                                              ©¦
   ©¦566             "msr    cpsr_c, %9"                                                                                               ©¦
   ©¦567                 :                                                                                                             ©¦
   ©¦568                 : "r" (stk),                                                                                                  ©¦
   ©¦569                   PLC (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),                                                                     ©¦
   ©¦570                   "I" (offsetof(struct stack, irq[0])),                                                                       ©¦
   ©¦571                   PLC (PSR_F_BIT | PSR_I_BIT | ABT_MODE),                                                                     ©¦
   ©¦572                   "I" (offsetof(struct stack, abt[0])),                                                                       ©¦
   ©¦573                   PLC (PSR_F_BIT | PSR_I_BIT | UND_MODE),                                                                     ©¦
   ©¦574                   "I" (offsetof(struct stack, und[0])),                                                                       ©¦
   ©¦220             const struct machine_desc *mdesc, *mdesc_best = NULL;                                                             ©¦
   ©¦221                                                                                                                               ©¦
   ©¦222     #if defined(CONFIG_ARCH_MULTIPLATFORM) || defined(CONFIG_ARM_SINGLE_ARMV7M)                                               ©¦
   ©¦223             DT_MACHINE_START(GENERIC_DT, "Generic DT based system")                                                           ©¦
   ©¦224                     .l2c_aux_val = 0x0,                                                                                       ©¦
   ©¦225                     .l2c_aux_mask = ~0x0,                                                                                     ©¦
   ©¦226             MACHINE_END                                                                                                       ©¦
   ©¦227                                                                                                                               ©¦
   ©¦228             mdesc_best = &__mach_desc_GENERIC_DT;                                                                             ©¦
   ©¦229     #endif                                                                                                                    ©¦
   ©¦230                                                                                                                               ©¦
   ©¦231             if (!dt_phys || !early_init_dt_verify(phys_to_virt(dt_phys)))                                                     ©¦
   ©¦232                     return NULL;                                                                                              ©¦
   ©¦233                                                                                                                               ©¦
   ©¦234             mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);                                                 ©¦
   ©¦235                                                                                                                               ©¦
   ©¦236             if (!mdesc) {                                                                                                     ©¦
   ©¦237                     const char *prop;                                                                                         ©¦
   ©¦238                     int size;                                                                                                 ©¦
   ©¦239                     unsigned long dt_root;                                                                                    ©¦
   ©¦240                                                                                                                               ©¦
   ©¦244     static inline unsigned long __phys_to_virt(phys_addr_t x) //__phys_to_virt                                                ©¦
   ©¦245     {                                                                                                                         ©¦
   ©¦246             unsigned long t;                                                                                                  ©¦
   ©¦247                                                                                                                               ©¦
   ©¦248             /*                                                                                                                ©¦
   ©¦249              * 'unsigned long' cast discard upper word when                                                                   ©¦
   ©¦250              * phys_addr_t is 64 bit, and makes sure that inline                                                              ©¦
   ©¦251              * assembler expression receives 32 bit argument                                                                  ©¦
   ©¦252              * in place where 'r' 32 bit operand is expected.                                                                 ©¦
   ©¦253              */                                                                                                               ©¦
  >©¦254             __pv_stub((unsigned long) x, t, "sub", __PV_BITS_31_24);                                                          ©¦
   ©¦255             return t;                                                                                                         ©¦
   ©¦256     }                                                                                                                         ©¦
   ©¦1251    bool __init early_init_dt_verify(void *params)                                                                            ©¦
   ©¦1252    {                                                                                                                         ©¦
   ©¦1253            if (!params)                                                                                                      ©¦
   ©¦1254                    return false;                                                                                             ©¦
   ©¦1255                                                                                                                              ©¦
   ©¦1256            /* check device tree validity */                                                                                  ©¦
   ©¦1257            if (fdt_check_header(params))                                                                                     ©¦
   ©¦1258                    return false;                                                                                             ©¦
   ©¦1259                                                                                                                              ©¦
   ©¦1260            /* Setup flat device-tree pointer */                                                                              ©¦
   ©¦1261            initial_boot_params = params;                                                                                     ©¦
  >©¦1262            of_fdt_crc32 = crc32_be(~0, initial_boot_params,                                                                  ©¦
   ©¦1263                                    fdt_totalsize(initial_boot_params));                                                      ©¦
   ©¦1264            return true;                                                                                                      ©¦
   ©¦1265    }                                                                                                                         ©¦
   ©¦737     int __init of_scan_flat_dt(int (*it)(unsigned long node,                                                                  ©¦
   ©¦738                                          const char *uname, int depth,                                                        ©¦
   ©¦739                                          void *data),                                                                         ©¦
   ©¦740                                void *data)                                                                                    ©¦
   ©¦741     {                                                                                                                         ©¦
  >©¦742             const void *blob = initial_boot_params;                                                                           ©¦
   ©¦743             const char *pathp;                                                                                                ©¦
   ©¦744             int offset, rc = 0, depth = -1;                                                                                   ©¦
   ©¦745                                                                                                                               ©¦
   ©¦746             if (!blob)                                                                                                        ©¦
   ©¦747                     return 0;                                                                                                 ©¦
   ©¦748                                                                                                                               ©¦
   ©¦749             for (offset = fdt_next_node(blob, -1, &depth);                                                                    ©¦
   ©¦750                  offset >= 0 && depth >= 0 && !rc;                                                                            ©¦
   ©¦751                  offset = fdt_next_node(blob, offset, &depth)) {                                                              ©¦
   ©¦752                                                                                                                               ©¦
   ©¦753                     pathp = fdt_get_name(blob, offset, NULL);                                                                 ©¦
   ©¦754                     if (*pathp == '/')                                                                                        ©¦
   ©¦755                             pathp = kbasename(pathp);                                                                         ©¦
   ©¦756                     rc = it(offset, pathp, depth, data);                                                                      ©¦
   ©¦757             }                                                                                                                 ©¦
   ©¦758             return rc;                                                                                                        ©¦
   ©¦759     }                                                                                                                         ©¦
(gdb) p mdesc
$17 = (const struct machine_desc *) 0x809435a0 <__mach_desc_VEXPRESS_DT>
(gdb) p *mdesc
$18 = {nr = 4294967295, name = 0x807bbed0 "ARM-Versatile Express", atag_offset = 0, dt_compat = 0x8095b6c8 <v2m_dt_match>, 
  nr_irqs = 0, video_start = 0, video_end = 0, reserve_lp0 = 0 '\000', reserve_lp1 = 0 '\000', reserve_lp2 = 0 '\000',
  reboot_mode = REBOOT_COLD, l2c_aux_val = 4194304, l2c_aux_mask = 4262461439, l2c_write_sec = 0x0,
  smp = 0x8095b91c <vexpress_smp_dt_ops>, smp_init = 0x80909374 <vexpress_smp_init_ops>, fixup = 0x0, dt_fixup = 0x0, pv_fixup = 0x0,
  reserve = 0x0, map_io = 0x0, init_early = 0x0, init_irq = 0x0, init_time = 0x0, init_machine = 0x0, init_late = 0x0,
  handle_irq = 0x0, restart = 0x0}
type = const struct machine_desc {
    unsigned int nr;
    const char *name;
    unsigned long atag_offset;
    const char * const *dt_compat;
    unsigned int nr_irqs;
    unsigned int video_start;
    unsigned int video_end;
    unsigned char reserve_lp0 : 1;
    unsigned char reserve_lp1 : 1;
    unsigned char reserve_lp2 : 1;
   ©¦1106            if (mdesc->reboot_mode != REBOOT_HARD)                                                                            ©¦
   ©¦1107                    reboot_mode = mdesc->reboot_mode;                                                                         ©¦
   ©¦1108                                                                                                                              ©¦
  >©¦1109            init_mm.start_code = (unsigned long) _text;                                                                       ©¦
   ©¦1110            init_mm.end_code   = (unsigned long) _etext;                                                                      ©¦
   ©¦1111            init_mm.end_data   = (unsigned long) _edata;                                                                      ©¦
   ©¦1112            init_mm.brk        = (unsigned long) _end;                                                                        ©¦
   ©¦1113                                                                                                                              ©¦
   ©¦1114            /* populate cmd_line too for later use, preserving boot_command_line */                                           ©¦
   ©¦1115            strlcpy(cmd_line, boot_command_line, COMMAND_LINE_SIZE);                                                          ©¦
   ©¦1116            *cmdline_p = cmd_line;                                                                                            ©¦
   ©¦1117                                                                                                                              ©¦
   ©¦1118            early_fixmap_init();                                                                                              ©¦
   ©¦1119            early_ioremap_init();                                                                                             ©¦
   ©¦1120                                                                                                                              ©¦
   ©¦1121            parse_early_param();                                                                                              ©¦
   ©¦611     void __init parse_early_param(void)                                                                                       ©¦
   ©¦612     {                                                                                                                         ©¦
   ©¦613             static int done __initdata;                                                                                       ©¦
   ©¦614             static char tmp_cmdline[COMMAND_LINE_SIZE] __initdata;                                                            ©¦
   ©¦615                                                                                                                               ©¦
  >©¦616             if (done)                                                                                                         ©¦
   ©¦617                     return;                                                                                                   ©¦
   ©¦618                                                                                                                               ©¦
   ©¦619             /* All fall through to do_early_param. */                                                                         ©¦
   ©¦620             strlcpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE);                                                       ©¦
   ©¦621             parse_early_options(tmp_cmdline);                                                                                 ©¦
   ©¦622             done = 1;                                                                                                         ©¦
   ©¦623     }                                                                                                                         ©¦
   ©¦164     char *parse_args(const char *doing,                                                                                       ©¦
   ©¦165                      char *args,                                                                                              ©¦
   ©¦166                      const struct kernel_param *params,                                                                       ©¦
   ©¦167                      unsigned num,                                                                                            ©¦
   ©¦168                      s16 min_level,                                                                                           ©¦
   ©¦169                      s16 max_level,                                                                                           ©¦
   ©¦170                      void *arg,                                                                                               ©¦
   ©¦171                      int (*unknown)(char *param, char *val,                                                                   ©¦
   ©¦172                                     const char *doing, void *arg))                                                            ©¦
   ©¦173     {                                                                                                                         ©¦
  >©¦174             char *param, *val, *err = NULL;                                                                                   ©¦
   ©¦175                                                                                                                               ©¦
   ©¦176             /* Chew leading spaces */                                                                                         ©¦
   ©¦177             args = skip_spaces(args);                                                                                         ©¦
   ©¦178                                                                                                                               ©¦
   ©¦179             if (*args)                                                                                                        ©¦
   ©¦180                     pr_debug("doing %s, parsing ARGS: '%s'\n", doing, args);                                                  ©¦
   ©¦181                                                                                                                               ©¦
   ©¦182             while (*args) {                                                                                                   ©¦
   ©¦183                     int ret;                                                                                                  ©¦
   ©¦184                     int irq_was_disabled;                                                                                     ©¦
   ©¦185                                                                                                                               ©¦
   ©¦186                     args = next_arg(args, &param, &val);                                                                      ©¦
   ©¦182             while (*args) {                                                                                                   ©¦
   ©¦183                     int ret;                                                                                                  ©¦
   ©¦184                     int irq_was_disabled;                                                                                     ©¦
   ©¦185                                                                                                                               ©¦
   ©¦186                     args = next_arg(args, &param, &val);                                                                      ©¦
   ©¦187                     /* Stop at -- */                                                                                          ©¦
   ©¦188                     if (!val && strcmp(param, "--") == 0)                                                                     ©¦
   ©¦189                             return err ?: args;                                                                               ©¦
   ©¦190                     irq_was_disabled = irqs_disabled();                                                                       ©¦
   ©¦191                     ret = parse_one(param, val, doing, params, num,                                                           ©¦
   ©¦192                                     min_level, max_level, arg, unknown);                                                      ©¦
   ©¦193                     if (irq_was_disabled && !irqs_disabled())                                                                 ©¦
   ©¦194                             pr_warn("%s: option '%s' enabled irq's!\n",                                                       ©¦
   ©¦195                                     doing, param);                                                                            ©¦
   ©¦196                                                                                                                               ©¦
   ©¦197                     switch (ret) {                                                                                            ©¦
   ©¦198                     case 0:                                                                                                   ©¦
   ©¦199                             continue;                                                                                         ©¦
   ©¦200                     case -ENOENT:                                                                                             ©¦
   ©¦201                             pr_err("%s: Unknown parameter `%s'\n", doing, param);                                             ©¦
   ©¦202                             break;                                                                                            ©¦
   ©¦203                     case -ENOSPC:                                                                                             ©¦
   ©¦518                     if (cpu_arch >= CPU_ARCH_ARMv7 && (cr & CR_TRE)) {                                                        ©¦
   ©¦519                             /*                                                                                                ©¦
   ©¦520                              * For ARMv7 with TEX remapping,                                                                  ©¦
   ©¦521                              * - shared device is SXCB=1100                                                                   ©¦
   ©¦522                              * - nonshared device is SXCB=0100                                                                ©¦
   ©¦523                              * - write combine device mem is SXCB=0001                                                        ©¦
   ©¦524                              * (Uncached Normal memory)                                                                       ©¦
   ©¦525                              */                                                                                               ©¦
   ©¦526                             mem_types[MT_DEVICE].prot_sect |= PMD_SECT_TEX(1);                                                ©¦
   ©¦527                             mem_types[MT_DEVICE_NONSHARED].prot_sect |= PMD_SECT_TEX(1);                                      ©¦
   ©¦528                             mem_types[MT_DEVICE_WC].prot_sect |= PMD_SECT_BUFFERABLE;                                         ©¦
   ©¦692                     mem_types[MT_CACHECLEAN].prot_sect |= PMD_SECT_WB;                                                        ©¦
   ©¦693                     break;                                                                                                    ©¦
   ©¦694             }                                                                                                                 ©¦
   ©¦695             pr_info("Memory policy: %sData cache %s\n",                                                                       ©¦
   ©¦696                     ecc_mask ? "ECC enabled, " : "", cp->policy);                                                             ©¦
   ©¦697                                                                                                                               ©¦
   ©¦698             for (i = 0; i < ARRAY_SIZE(mem_types); i++) {                                                                     ©¦
   ©¦699                     struct mem_type *t = &mem_types[i];                                                                       ©¦
   ©¦700                     if (t->prot_l1)                                                                                           ©¦
   ©¦701                             t->prot_l1 |= PMD_DOMAIN(t->domain);                                                              ©¦
   ©¦702                     if (t->prot_sect)                                                                                         ©¦
   ©¦703                             t->prot_sect |= PMD_DOMAIN(t->domain);                                                            ©¦
   ©¦704             }                                                                                                                 ©¦
   ©¦705     }                                                                                                                         ©¦
  >©¦1180            vmalloc_limit = (u64)(uintptr_t)vmalloc_min - PAGE_OFFSET + PHYS_OFFSET;                                          ©¦
   ©¦1181                                                                                                                              ©¦
   ©¦1182            for_each_memblock(memory, reg) {                                                                                  ©¦
   ©¦1183                    phys_addr_t block_start = reg->base;                                                                      ©¦
   ©¦1184                    phys_addr_t block_end = reg->base + reg->size;                                                            ©¦
   ©¦1185                                                                                                                              ©¦
   ©¦1186                    if (reg->base < vmalloc_limit) {                                                                          ©¦
   ©¦1187                            if (block_end > lowmem_limit)                                                                     ©¦
   ©¦1188                                    /*                                                                                        ©¦
   ©¦1189                                     * Compare as u64 to ensure vmalloc_limit does                                            ©¦
   ©¦1190                                     * not get truncated. block_end should always                                             ©¦
   ©¦1191                                     * fit in phys_addr_t so there should be no                                               ©¦
   ©¦1192                                     * issue with assignment.                                                                 ©¦
   ©¦1193                                     */                                                                                       ©¦
   ©¦1194                                    lowmem_limit = min_t(u64,                                                                 ©¦
   ©¦1195                                                             vmalloc_limit,                                                   ©¦
   ©¦1196                                                             block_end);                                                      ©¦
   ©¦1197                                                                                                                              ©¦
(gdb) n
build_all_zonelists (pgdat=<optimized out>) at mm/page_alloc.c:5259
(gdb) p vm_total_pages 
$37 = 0
(gdb) s
(gdb) p vm_total_pages 
$38 = 130048
   ©¦5272            pr_info("Built %i zonelists, mobility grouping %s.  Total pages: %ld\n",                                                                            ©¦
   ©¦5273                    nr_online_nodes,                                                                                                                            ©¦
   ©¦5274                    page_group_by_mobility_disabled ? "off" : "on",                                                                                             ©¦
   ©¦5275                    vm_total_pages);                                                                                                                            ©¦
   ©¦5276    #ifdef CONFIG_NUMA                                                                                                                                          ©¦
   ©¦5277            pr_info("Policy zone: %s\n", zone_names[policy_zone]);                                                                                              ©¦
  virtual void SetRowAddress(GPIO *io, int row) {
    if (row == last_row_) return;
    io->SetBits(bk_);  // Enable serial input for the shifter
    for (int r = 7; r >= 0; r--) {
      if (row % 8 == r) {
        io->SetBits(din_);
      } else {
        io->ClearBits(din_);
      }
      io->SetBits(dck_);
      io->SetBits(dck_);  // Longer clock time; tested with Pi3
      io->ClearBits(dck_);
    }
    io->ClearBits(bk_);  // Disable serial input to keep unwanted bits out of the shifters
    last_row_ = row;
    // Set bits D and E to enable the proper shifter to display the selected
    // row.
    io->WriteMaskedBits(row_lookup_[row], row_mask_);
  }
// The DirectABCDRowAddressSetter sets the address by one of
// row pin ABCD for 32Ñ16 matrix 1:4 multiplexing. The matrix has
// 4 addressable rows. Row is selected by a low level on the
// corresponding row address pin. Other row address pins must be in high level.
//
// Row addr| 0 | 1 | 2 | 3
// --------+---+---+---+---
// Line A  | 0 | 1 | 1 | 1
// Line B  | 1 | 0 | 1 | 1
// Line C  | 1 | 1 | 0 | 1
// Line D  | 1 | 1 | 1 | 0
      tos_barrier.c                                                                                                                                                                         ©¦ 
      tos_binary_heap.c                                                                                                                                                                     ©¦ 
      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_bitmap.c                                                                                                                                                                          ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_char_fifo.c                                                                                                                                                                       ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_completion.c                                                                                                                                                                      ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_completion.c                                                                                                                                                                      ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_countdownlatch.c                                                                                                                                                                  ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_event.c                                                                                                                                                                           ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_global.c                                                                                                                                                                          ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_mail_queue.c                                                                                                                                                                      ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_message_queue.c                                                                                                                                                                   ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_mmblk.c                                                                                                                                                                           ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_mmheap.c                                                                                                                                                                          ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_mutex.c                                                                                                                                                                           ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_pend.c                                                                                                                                                                            ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_priority_mail_queue.c                                                                                                                                                             ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_priority_message_queue.c                                                                                                                                                          ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_priority_queue.c                                                                                                                                                                  ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_ring_queue.c                                                                                                                                                                      ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_robin.c                                                                                                                                                                           ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_rwlock.c                                                                                                                                                                          ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_sched.c                                                                                                                                                                           ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_sem.c                                                                                                                                                                             ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_stopwatch.c                                                                                                                                                                       ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_sys.c                                                                                                                                                                             ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_task.c                                                                                                                                                                            ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_tick.c                                                                                                                                                                            ©¦>

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_time.c                                                                                                                                                                            ©¦ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_timer.c                                                                                                                                                                           ©¦ 
[tong@free ~/06_files/Download]$ cd ~/02_nvme              
ç¬¬ä¸ç«  æç¥ç®æ ä¸å¯ä¼åï¼ä½ ä¸ºä»ä¹è¿è¦åæï¼

ç¬¬äºç«  çæ¾å¼ååæ¾å¼

ç¬¬ä¸ç«  ç®æ è±ç¦»åç§¯ææç»´

ç¬¬åç«  å¹å»æ¾å¼çè½å

ç¬¬äºç«  ç®¡çä½ çææ³åæç»ª

ç¬¬å­ç«  å³äºç®æ çå¿«ææ¢æ³

ç¬¬ä¸ç«  å¦ä½è§åä½ çäººçç®æ ï¼

ç¬¬å«ç«  å«è®©åææä½ä½ æ¾å¼çèæ­¥

ç¬¬ä¹ç«  éç½®ä½ äººççæåé
Ò»µ©²»Ê¹ÓÃ Make ÖÐÄÇÐ©ÓÃÀ´Éú³É¹¹½¨Á÷³ÌµÄÌØÐÔ£¬Ninja ÕâÖÖ¹¦ÄÜ¸üÉÙ£¬½â¾öÎÊÌâ¸üÃ÷È·µÄ¹¤¾ß¾Í¸üºÏÊÊ¡£
 
Ninjia µÄÉè¼ÆÔ­Ôò¾ÍÊÇ¹¹½¨½Å±¾Ò×ÓÚÈËÔÄ¶Á£¨·½±ãµ÷ÊÔ£©£¬µ«²»Ò×ÓÚÈËÖ±½ÓÊéÐ´£¨·½±ã»úÆ÷½âÎö£©¡£Í¬Ê±£¬¹¹½¨Á÷³Ì¿ÉÒÔ»ñµÃ¸ü¸ßµÄÐ§ÂÊ¡£¼õÉÙ¹¹½¨Ê±¼äÄÜÖ±½ÓÌá¸ß¿ª·¢Ð§ÂÊ¡£
ÓÐÊ±ºò»Ø´ð²»ºÃÎÊÌâ£¬ÊÇÒòÎªÌâÃ»¶ÁÃ÷°×¡£ ÓÐÊ±ºòÐÞ²»ÁË bug£¬ÊÇÒòÎª log Ã»¶ÁÃ÷°×¡£
ÉÏÖÜ±»Í¬ÊÂ±¨ÁËÒ»¸ö¿¨¶Ù bug£¬¿´ÁËÒ»Õó·¢ÏÖ£¬Õæ»úÉÏÃ»ÓÐ£¬Ä£ÄâÆ÷ÉÏÓÐ£¬¾ÍÈÏÎªÊÇÄ£ÄâÆ÷µÄ bug£¬²»ÖØÒª£¬È»ºó¾ÍÃ»ÔÚÉîÈë£¬¾Í²»¹ÜÁË¡£
Èç¹ûÒªÎÒ¸øÄêÇáÈË½¨Òé£¬ÄÇÃ´ÎÒµÄ½¨Òé¾ÍÊÇÑ¡ÔñÊ±£¬ÒªÉ÷Ö®ÓÖÉ÷£¬ÓÈÆä¶ÔÄã²»¿É°Ñ¿ØµÄÊÂÇé¡£ºÜ¶àÊ±ºò£¬ÔÙÀ´Ò»´ÎµÄ³É±¾£¬ÕæµÄÊÇÌ«´óÁË¡£
È¥ÄêÀûÓÃÒµÓàÊ±¼ä£¬¿ª·¢ÁËÒ»¿îÆÁÄ»²âÁ¿Ó¦ÓÃ ¡ª¡ª PixelsMeasure[1]£¬ÕâÆªÎÄÕÂ×Ü½áÒ»ÏÂÕâ¶ÎÊ±¼äµÄ¾­ÀúºÍ¸ÐÎò¡£
×î½ü¿Í»§Óöµ½Ò»¸öÏßÉÏµÄÐÔÄÜÎÊÌâ£¬¿´ÁËÁ½ÌìÃ»½â¾ö£¬×îºó±»ÎÒÃÇÍ¬ÊÂÒ»¸öÐ¡Ê±¸ø·¢ÏÖÎÊÌâ£¬²¢Ìá¹©ÁËÒ»¸öÁ½ÐÐ´úÂëµÄÐÞ¸´·½°¸£¬»º½âÁËÎÊÌâ£¬ÉÏÏßºóµÃµ½ÁËÓÃ»§µÄÈÏ¿É¡£µ«ÊÇ¿Í»§ÔÚ»Ø¹ËµÄÊ±ºò£¬Ó²ËµÊÇÃ»ÓÐ·¢
ÏÖÖ÷ÒªÔ­Òò£¬Ö»ÊÇÐÞ¸´ÁËÒ»¸ö´úÂë»µÎ¶µÀµÄÎÊÌâ£¬ÈÃÈË±¶¸ÐÎÞÄÎ£¡
×î½ü³¢ÊÔÓÃÁË Debug Memory Graph ºÍ Xcode Instruments£¬²»ÓÃ²»ÖªµÀ£¬Ò»ÓÃÏÅÒ»Ìø¡£ÎÒ·¢ÏÖ PixelsMeasure[1] µÚÒ»´Î²âÁ¿ºó£¬´´½¨ÁË 30 
¶àÍò¸ö¶ÔÏó£¬È»ºó×¤ÁôÔÚÄÚ´æÖÐ¡£µ¼ÖÂ¼´Ê¹²»²âÁ¿Ê±£¬ÄÚ´æÒ²Õ¼ÓÃ¹ý´ó¡£Ò»·­ÑÐ¾¿·¢ÏÖ£¬ÊÇ×Ô¼º×Ô¶¨ÒåÁËÒ»¸öµÚÈý·½¿â³öµÄÎÊÌâ 
°ëÄêÀ´£¬ChatGPT (»ùÓÚ GPT ¼Ü¹¹¿ª·¢µÄ´óÐÍÓïÑÔÄ£ÐÍ) ³¹µ×µß¸²ÁËÈËÃÇ¶ÔÈË¹¤ÖÇÄÜµÄÈÏÊ¶£¬¸øºÜ¶àÐÐÒµ¶¼´øÀ´ÁËÇ°ËùÎ´ÓÐµÄ³å»÷¡£ÓÈÆäÔÚ±àÂë·½Ãæ£¬ÄÜÇá¶øÒ×¾ÙµØÐ´³ö¶íÂÞË¹·½¿é¡¢Ì°³ÔÉß¡¢1024 µÈÐ¡ÓÎÏ·£¬ÄÜ
Ð´³öµçÓ°ÍÆ¼öµÈ¿ÉÉÏÏßµÄÓ¦ÓÃ³ÌÐò¡£ÔÚ³öÉ«Íê³É±àÂëÈÎÎñµÄÍ¬Ê±£¬±àÂëÖÊÁ¿ºÍÐ§ÂÊ¶¼ÈÃÈËÕðº³¡£ÒÔÖÁÓÚºÜ¶àÈË¿ªÊ¼½¹ÂÇ£¬¾õµÃ³ÌÐòÔ±ÀëÏÂ¸Ú²»Ô¶ÁË¡£ÎªÁËÁË½âÆäÄÜÁ¦£¬ÎÒÉîÈëÌåÑéÁËÒ»»Ø¡£¾ªÆæµØ·¢ÏÖ£¬GPT 
Ê®·ÖÀûºÃ³ÌÐòÔ±£¬ÓÈÆäÀûºÃ³ÌÐòÔ±¡£
×î½ü¿´ÁËºÜ¶àÊÓÆµ£¬·¿³µÂÃÐÐ¡¢Ä¦ÂÃ¡¢ÆïÐÐºÍ·òÆÞÆïÐÐ£¬Õâ¸öÐÐÒµÔ½À´Ô½¾íÁË¡£µ«ÊÇÎÒÓÖºÜÏÛÄ½ËûÃÇ£¬ÄÜ³Ë×ÅÄêÇáµÄÊ±ºò£¬×öÕâÐ©ÊÂÇé£¬ÅÄÕâÐ©ÊÓÆµ£¬Õâ¾ÍÊÇËûÃÇÈËÉúµÄ¼ÇÂ¼£¬ÊÇËûÃÇµÄ×÷Æ·¡£
¸ÕìÅÒ«ÁËÒ»²¨×Ô¼ºµÄË¯ÃßÖÊÁ¿£¬½á¹ûÕâÖÜ¾ÍÓöµ½ÁËÎÊÌâ¡£²»ÖªµÀÊÇºÈÁË¿§·È£¬»¹ÊÇ½¹ÂÇ£¬×ÜÖ®£¬ÍíÉÏË¯²»×ÅÁË¡£
~
×î½ü±» Keyboardshortcuts ¿¨ÁËÈýÖÜ£¬ÕâÖÖÖÕÓÚÕÒµ½ÁË·½°¸£¬Áø°µ»¨Ã÷¡£×öÒ»¼þÊÂÇé£¬ÕæµÄÊÇ²»ÄÜÌ«ÄÑ£¬Ì«ÄÑÁËÈÝÒ×·ÅÆú£¬»òÕßÍÏÑÓ¡£Ò²²»ÄÜÌ«¼òµ¥£¬Ì«¼òµ¥»á¾õµÃÎÞÁÄ¡£Keyboardshortcuts 
µÄ·½°¸ËäÈ»²»ÍêÃÀ£¬µ«ÊÇÒ²ÃãÇ¿ÄÜÓÃ£¬ÄÜ´ïµ½ÕýÈ·µÄÊ¹ÓÃËü£¬¾Í»á·¢ÏÖËüÄÜÓÃ¡£Èç¹ûÄãÍæµÄ»¨Ò»µã£¬Ëü¿ÉÄÜ²»Õý³£¹¤×÷¡£ÎªÁË´ó²¿·ÖÈËÄÜÓÃ£¬ÏÈÕâÑù°É¡£
ËÄÖÜÇ°·¢ÏÖ£¬×Ô¼º¶Ô¹ÜÀíÖªÊ¶Ò»ÎÞËùÖª¡£½Ó×Å±¨ÁËÍø¿Î£¬Ñ§ÁË¼¸½Ú¿Î£¬×î´óµÄÊÕ»ñ¾ÍÊÇ¿ªÀ«ÁËÑÛ½ç£¬²¢ÖªµÀÁËÓÐÒ»±¾¾Ã¸ºÊ¢ÃûµÄ¹ÜÀíÑ§Êé¼®¡¶×¿ÓÐ³ÉÐ§µÄ¹ÜÀíÕß¡·£¬Ëæ¼´ÂòÁË¡£
´Óºó¶Ë×ªÐÐ iOS ¿ª·¢Ò»ÄêÁË£¬Ò»Ö±Ã»ÓÐÑÐ¾¿¹ýÍøÂçÇëÇóµÄ API£¨ÏîÄ¿ÉÏÓÐÏÖ³ÉµÄ·â×°£©¡£Ö®Ç°ÊÖÐ´ÏîÄ¿µÄÊ±ºò£¬×Ü¸Ð¾õ¶Ô URLSession 
Ò»Öª°ë½â£¬ÓÌÔ¥ÁËºÜ¶à´Î¡£Õâ´ÎÀûÓÃ¼ÙÆÚ£¬ÖÕÓÚÓÐ»ú»áÄÜÍêÕûµÄ¶ÁÁËÒ»±é¹Ù·½ÎÄµµ£¬×Ü½áÁËÒ»ÏÂ£¬ÓÚÊÇÓÐÁËÕâÆªÎÄÕÂ¡¶URL ¼ÓÔØÏµÍ³£¨URL Loading System£©¡·[1]¡£Á·Ï°ÁËÒ»°Ñ£¬ÓÚÊÇÓÐÁËÕâ¸ö repo 
zddhub/url-loading-system[2]¡£Íê³ÉºóÍøÉÏËÑÁËÒ»°Ñ£¬·¢ÏÖ´ó¶¼ÊÇÕÕ°á¹Ù·½ÎÄµµ£¬»òÕßÊÇ¼¸ÄêÇ°µÄÀÏÎÄÕÂ£¬»¹ÊÇÓÐÂúÂúµÄ³É¾Í¸Ð¡£ËüÖÁÉÙÊÇ´ïµ½ÁËÎÒÐ´ÎÄÕÂµÄÄ¿µÄ ¡ª¡ª ¶Ô×Ô¼ºÓÐÓÃ¡£
Ö÷¶¯Ñ§Ï°ÐèÒªºÜÇ¿µÄ×ÔÖÆÁ¦£¬ÎÒºÜÄÑ×öµ½£¬»ØÍ·¿´¿´×Ô¼ºµÄ³É³¤£¬±»¶¯Ñ§Ï°Õ¼ÁËÖØÒªµÄÒ»¿é¡£
uint16_t u16AverageFilter(uint16_t Value[])
{
  uint16_t val, average;
  uint8_t min;
  uint32_t sum;
  if (Value[0] < Value[1])
  {
    val = Value[0];
    min = 0;
  }
  else
  {
    val = Value[1];
    min = 1;
  }
  if (Value[2] < val)
  {
    val = Value[2];
    min = 2;
  }
  sum = (uint32_t)Value[0] + Value[1] + Value[2];
  average = sum / 3;
  if ((average - Value[min]) > 10)
  {
    average = (sum - Value[min]) / 2;
  }
  return average;
}
/* æå·æ°ç¼å­åå¥ 6ä¸ª CGRAMä¸­ */
void Write6CGRAM(unsigned char x)
{
	unsigned char i,j;

    j = x + 40;
	gpio_set_level(PIN_NUM_CS,0);//CSæä½
	usleep(1);
	VFDWriteData(0x40 + 0);//å°åå¯å­å¨èµ·å§ä½ç½®	
	for (i = x; i < j; i++)
	{
		VFDWriteData(refreshData[i]);
	}
	gpio_set_level(PIN_NUM_CS,1);//CSæé«
    usleep(2);
}
void BootAnimation()
{
	unsigned char cnt,i;
	unsigned char G1Temp[5][5] = {
   {0x03, 0x0b, 0x0b, 0x03, 0x03},// 
   {0x03, 0x07, 0x0b, 0x01, 0x05},//
   {0x03, 0x03, 0x0f, 0x07, 0x01},//
   {0x0f, 0x03, 0x0b, 0x01, 0x01},//
   {0x00, 0x00, 0x00, 0x00, 0x00},//
};

	i = 0;
	memset(ADbuff,0xff,13);
	//ä¸æ¾ç¤ºç¹
	ADbuff[6] &= 0xfe;
	ADbuff[7] &= 0xfe;
	ADbuff[8] &= 0xfe;
	ADbuff[9] &= 0xfe;
	ADbuff[10] &= 0xfe;
	ADbuff[11] &= 0xfe;
	VFDWriteAllADRAMAndShow(ADbuff);
	//BootSound();
	for (cnt = 1; cnt < 13; cnt++)
	{
		VFDWriteStrAndShow(cnt, ">");
		WriteCGRAM(6,&G1Temp[0][0],i);
		VFDWriteOneDIYCharAndShow(0,6);//æCGRAM 6çç¼å­æ¾ç¤ºå°G1ä¸
		i++;
		if(i >= 4) i = 0;
		vTaskDelay(50 / portTICK_PERIOD_MS);
	}
	//DDiDi();

	vTaskDelay(200 / portTICK_PERIOD_MS);
	DisappearingAnimation();//æ¾ç¤ºæ¶å¤±å¨ç»

	/*
	VFDWriteStrAndShow(0, " ");
	//WriteCGRAM(6,&G1AnimationTemp[0][0],4);//å³é­G1æ¾ç¤º
	//VFDWriteOneDIYCharAndShow(0,6);//æCGRAM 6çç¼å­æ¾ç¤ºå°G1ä¸
	vTaskDelay(20 / portTICK_PERIOD_MS);

	//å³é­ADæ¾ç¤º
	memset(ADbuff,0x00,13);
	for (cnt = 0; cnt < 13; cnt++)
	{
		VFDWriteOneADRAMAndShow(cnt,ADbuff[cnt]);
		vTaskDelay(20 / portTICK_PERIOD_MS);
	}
	*/
}
A

The Application profile defines an architecture aimed at high performance
processors, supporting a virtual memory system using a Memory Management
Unit (MMU) and therefore capable of running fully featured operating systems.
Support for the ARM and Thumb instruction sets is provided.
ARMv7-A, the Application profile, is implemented by all Cortex-A series
processors, and by processors developed by companies who have licensed the
ARM architecture. At the beginning of 2014, just under three billion Cortex-A
Series chips had been shipped.
The ARMv8-A architecture, which is not described in this book, supports the
AArch32 state, a 32-bit implementation of the architecture that is backwards
compatible with ARMv7-A.

ARM DEN0013D
ID012214

R

The Real-time profile defines an architecture aimed at systems that require
deterministic timing and low interrupt latency. There is no support for a virtual
memory system, but memory regions can be protected using a simple Memory
Protection Unit (MPU).

M

The Microcontroller profile defines an architecture aimed at low cost systems,
where low-latency interrupt processing is vital. It uses a different exception
handling model to the other profiles and supports only a variant of the Thumb
instruction set.

Copyright Â© 2011 â 2013 ARM. All rights reserved.
Non-Confidential
The Cortex-A8 processor
The ARM Cortex-A8 processor, has the ability to scale in speed from 600MHz to greater than
1GHz. The Cortex-A8 processor can meet the requirements for power-optimized mobile
devices needing operation in less than 300mW; and performance-optimized consumer
applications requiring 2000 Dhrystone MIPS. It is available in a number of different devices,
including the S5PC100 from Samsung, the OMAP3530 from Texas Instruments and the
The Cortex-A9 processor
The ARM Cortex-A9 processor is a power-efficient and popular high performance choice in low
power or thermally constrained cost-sensitive devices.
It is currently shipping in large volumes for smartphones, digital TV, consumer and enterprise
applications. The Cortex-A9 processor provides an increase in performance of greater than 50%
compared to the Cortex-A8 processor. The Cortex-A9 processor can be configured with up to
four cores delivering peak performance when required. Configurability and flexibility makes
the Cortex-A9 processor suitable for wide variety of markets and applications.
// º¯ÊýÓÃÓÚ¼ì²âÁ´±íÖÐÊÇ·ñÓÐ»·£¬²¢·µ»Ø»·µÄÆðÊ¼½Úµã                                                                                      
ListNode* detectCycle(ListNode* head) {                                                                                                
    if (head == NULL || head->next == NULL) return NULL;           
                                 
    ListNode *slow = head, *fast = head->next;                                                                                         
    while (slow != fast) {                                                                                                             
        if (fast == NULL || fast->next == NULL) return NULL; // Èç¹ûfast»òfast->nextµ½Á´±íÎ²²¿£¬ÔòÎÞ»·                                 
        slow = slow->next;        // ÂýÖ¸ÕëÏòÇ°×ßÒ»²½              
        fast = fast->next->next;  // ¿ìÖ¸ÕëÏòÇ°×ßÁ½²½                                                                                  
    }                                                                                                                                  
                                 
    // µ±fastºÍslowÏàÓöÊ±£¬ÖØÖÃfastÎªhead£¬È»ºófastºÍslowÒ»ÆðÏòÇ°×ß£¬Ö±µ½ÔÙ´ÎÏàÓö                                                      
    fast = head;                                                   
    while (fast != slow) {                                                                                                             
        fast = fast->next;                                         
        slow = slow->next;                                                                                                             
    }                                                              
                                                                                                                                       
    // ÔÙ´ÎÏàÓöµÄµØ·½¼´Îª»·µÄÆðÊ¼½Úµã                                                                                                  
    return fast;                                                   
}                                                                  
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {                                                 
    struct ListNode *pA = headA, *pB = headB;                                                                                          
    int lenA = 0, lenB = 0;                                                                                                            
                                                                                                                                       
    // Step 1: Traverse both lists to find out their lengths                                                                           
    while (pA) {                                                                                                                       
        pA = pA->next;                                                                                                                 
        lenA++;                                                                                                                        
    }                                                                                                                                  
    while (pB) {                                                                                                                       
        pB = pB->next;                                                                                                                 
        lenB++;                                                                                                                        
    }                                                                                                                                  
                                                                                                                                       
    // Step 2: Align nodes of both lists                                                                                               
    int diff = lenA - lenB;                                                                                                            
    if (lenA > lenB) {                                                                                                                 
        while (diff--) pA = pA->next;                                                                                                  
    } else {                                                       
        while (diff++) pB = pB->next;                                                                                                  
    }                                                                                                                                  
                                                                                                                                       
    // Step 3: Traverse both lists together to find intersection                                                                       
    while (pA && pB) {                                             
        if (pA == pB) {                                                                                                                
            return pA; // Found the intersection                   
        }
        pA = pA->next;
        pB = pB->next;
    }

    return NULL; // No intersection
}
// ¼ì²éÁ´±íÊÇ·ñÊÇ»ØÎÄ                                                                                                                  
int isPalindrome(ListNode* head) {
    if (head == NULL || head->next == NULL) return 1;
     
    // ¿ìÂýÖ¸ÕëÕÒµ½ÖÐµã
    ListNode *slow = head, *fast = head;
    while (fast->next != NULL && fast->next->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }
     
    // ·´×ªÁ´±íµÄºó°ë²¿·Ö
    ListNode *prev = NULL;
    while (slow->next != NULL) {
        ListNode *temp = slow->next;
        slow->next = prev;
        prev = slow;
        slow = temp;
    }
     
    // Èç¹ûfastÖ¸Õë²»Îª¿Õ£¬slowÖ¸ÏòµÄÊÇÖÐµã£¬ÐèÒªÌø¹ýÖÐµã
    if (fast->next != NULL) slow = slow->next;
     
    // ±È½ÏÇ°°ë²¿·ÖºÍºó°ë²¿·Ö
    ListNode *p1 = head, *p2 = prev;
    while (p2 != NULL) {
        if (p1->val != p2->val) return 0;
        p1 = p1->next;
        p2 = p2->next;
    }
     
    return 1;
}
struct ListNode* removeDuplicateNodes(struct ListNode* head) {
    if (head == NULL) return NULL;
     
    struct ListNode *prev = head, *curr = head->next, *temp = NULL; 
    while (curr) {
        if (prev->val == curr->val) {
            temp = curr;
            prev->next = curr->next;
            curr = curr->next;
            free(temp);
        } else {
            prev = curr;
            curr = curr->next;
        }
    }
    return head;
}
struct ListNode* removeDuplicateNodes(struct ListNode* head) {
    if (head == NULL) return NULL;
     
    struct ListNode *prev = head, *curr = head->next, *temp = NULL; 
    while (curr) {
        if (prev->val == curr->val) {
            temp = curr;
            prev->next = curr->next;
            curr = curr->next;
            free(temp);
        } else {
            prev = curr;
            curr = curr->next;
        }
    }
    return head;
}
bool isFlipedString(char *s1, char *s2) {
    // ½« s1 Æ´½Óµ½×ÔÉí
    char *combined = malloc(strlen(s1) * 2 + 1);
    strcpy(combined, s1);
    strcat(combined, s1);
     
    // ¼ì²é s2 ÊÇ·ñÊÇÆ´½ÓºóµÄ×Ö·û´®µÄ×Ó´®
    bool result = strstr(combined, s2) != NULL;
     
    // ÊÍ·ÅÄÚ´æ
    free(combined);
     
    return result;
}
char* compressString(char* S) {                                                                                                        
    int len = strlen(S);                                                                                                               
    if (len <= 1) return S; // Èç¹û×Ö·û´®³¤¶ÈÐ¡ÓÚµÈÓÚ1£¬Ö±½Ó·µ»ØÔ­×Ö·û´®                                                               
                                                                                                                                       
    char *compressed = (char *)malloc(len + 1); // ÎªÑ¹ËõºóµÄ×Ö·û´®·ÖÅä¿Õ¼ä                                                            
    int j = 0; // compressedµÄË÷Òý                                                                                                     
    for (int i = 0; i < len; i++) {                                                                                                    
        char currentChar = S[i];                                                                                                       
        // ¼ÆËãµ±Ç°×Ö·ûÖØ¸´µÄ´ÎÊý                                                                                                      
        int count = 1;                                                                                                                 
        while (i + 1 < len && S[i + 1] == currentChar) {                                                                               
            i++;                                                                                                                       
            count++;                                                                                                                   
        }                                                                                                                              
        // ½«×Ö·ûºÍÆäÖØ¸´´ÎÊýÌí¼Óµ½Ñ¹Ëõ×Ö·û´®ÖÐ                                                                                        
        compressed[j++] = currentChar;                                                                                                 
        if (count > 1) {                                                                                                               
            sprintf(&compressed[j], "%d", count);                                                                                      
            j += strlen(&compressed[j]); // ¸üÐÂË÷ÒýÎ»ÖÃ                                                                               
        }                                                                                                                              
    }                                                                                                                                  
    compressed[j] = '\0'; // È·±£×Ö·û´®ÒÔ¿Õ×Ö·û½áÎ²                                                                                    
                                                                                                                                       
    // ±È½ÏÔ­Ê¼×Ö·û´®ºÍÑ¹Ëõ×Ö·û´®µÄ³¤¶È£¬·µ»Ø½Ï¶ÌµÄÒ»¸ö                                                                                
    if (j >= len) {                                                                                                                    
        free(compressed);                                                                                                              
        return S;                                                                                                                      
    }                                                                                                                                  
    return compressed;                                                                                                                 
} 
void replaceSpaces(char *str, int length) {
    int spaceCount = 0;
    int i, j;
     
    // ¼ÆËã¿Õ¸ñÊýÁ¿
    for (i = 0; i < length; i++) {
        if (str[i] == ' ') spaceCount++;
    }
     
    // ´Ó×Ö·û´®Ä©Î²¿ªÊ¼£¬ÎªÃ¿¸ö¿Õ¸ñÌæ»»Îª"%20"
    for (i = length - 1, j = length + spaceCount * 2 - 1; i >= 0; i--) {
        if (str[i] == ' ') {
            str[j--] = '0';
            str[j--] = '2';
            str[j] = '%';
        } else {
            str[j--] = str[i];
        }
    }
}
bool checkPermutation(char *s1, char *s2) {
    if (strlen(s1) != strlen(s2)) return false;                                                                                        
                                                                                                                                       
    int count[26] = {0}; // ¼ÙÉèÖ»°üº¬Ð¡Ð´×ÖÄ¸
                                                                                                                                       
    // Í³¼Æs1ÖÐÃ¿¸ö×Ö·ûµÄ¸öÊý                                      
    for (int i = 0; s1[i] != '\0'; i++) {                                                                                              
        count[s1[i] - 'a']++;    
    }                                                                                                                                  
                                                                   
    // Í³¼Æs2ÖÐÃ¿¸ö×Ö·ûµÄ¸öÊý£¬²¢¼ì²éÊÇ·ñÓës1ÏàÍ¬
    for (int i = 0; s2[i] != '\0'; i++) {
        count[s2[i] - 'a']--;                                      
        if (count[s2[i] - 'a'] < 0) return false; // Èç¹û³öÏÖ¸ºÊý£¬ÔòËµÃ÷s2ÓÐ¶àÓàµÄ×Ö·û
    }
     
    return true; // Èç¹ûËùÓÐ¼ÆÊý¶¼Îª0£¬ÔòËµÃ÷ÊÇ×Ö·ûÖØÅÅ
}
int countWays(int *nums, int numsSize, int target) {
    // dpÊý×é£¬dp[i]±íÊ¾ÐÎ³ÉiµÄ×éºÏÊýÁ¿
    int dp[target + 1];                                                                                                                
    // ³õÊ¼»¯dpÊý×é£¬0µÄ×éºÏÊýÎª1
    for (int i = 0; i <= target; i++) {
        dp[i] = 0;                                                                                                                     
    }
    dp[0] = 1; // ºÍÎª0µÄ×éºÏÊýÎª1

    // ±éÀúÊý×é£¬¸üÐÂdpÊý×é
    for (int i = 0; i < numsSize; i++) {
        for (int j = target; j >= nums[i]; j--) {
            dp[j] += dp[j - nums[i]];
        }
    }

    return dp[target];
}
int countSpecialCharacters(const char* word) {                                                                                         
    int count = 0;                                                                                                                     
    bool exists[26][2] = {false}; // ÓÃÓÚ¼ÇÂ¼Ã¿¸ö×Ö·ûµÄ´óÐ¡Ð´ÐÎÊ½ÊÇ·ñ´æÔÚ                                                              
                                                                                                                                       
    // ±éÀú×Ö·û´®£¬¼ÇÂ¼Ã¿¸ö×Ö·ûµÄ´óÐ¡Ð´ÐÎÊ½                                                                                            
    for (int i = 0; word[i] != '\0'; i++) {                                                                                            
        char lower = tolower(word[i]);                                                                                                 
        char upper = toupper(word[i]);                                                                                                 
        if (lower == upper) continue; // Èç¹ûÊÇÍ¬Ò»¸ö×Ö·ûµÄ´óÐ¡Ð´ÐÎÊ½£¬Ìø¹ý                                                            
                                                                                                                                       
        // ¼ì²éÁíÒ»¸öÐÎÊ½ÊÇ·ñ´æÔÚ                                                                                                      
        int index = lower - 'a';                                   
        if (!exists[index][0] && !exists[index][1]) {                                                                                  
            exists[index][lower == word[i]] = true; // ±ê¼Ç´æÔÚ                                                                        
        }                                                                                                                              
    }                                                              
                                                                                                                                       
    // ¼ÆËãÌØÊâ×Ö·ûµÄÊýÁ¿                                                                                                              
    for (int i = 0; i < 26; i++) {                                 
        if (exists[i][0] && exists[i][1]) count++;                                                                                     
    }

    return count;
}
int findPermutationDifference(char *s, char *t) {                                                                                      
    int index[26] = {0}; // ¼ÙÉèsºÍt¶¼ÊÇÐ¡Ð´×ÖÄ¸                                                                                       
    int sum = 0;                                                                                                                       
    int sLength = strlen(s);                                                                                                           
    int tLength = strlen(t);                                                                                                           
                                                                   
    // ¼ÇÂ¼sÖÐ×Ö·ûµÄÎ»ÖÃ                                                                                                               
    for (int i = 0; i < sLength; i++) {                                                                                                
        index[s[i] - 'a'] = i;                                                                                                         
    }                                                                                                                                  
                                                                                                                                       
    // ¼ÆËãÅÅÁÐ²î                                                                                                                      
    for (int i = 0; i < tLength; i++) {                                                                                                
        sum += abs(index[t[i] - 'a'] - i);                                                                                             
    }                                                                                                                                  
                                                                                                                                       
    return sum;                                                                                                                        
}                                                                                                                                      
int findWinningPlayer(int* skills, int skillsSize, int k) {                                                                            
    int queue[skillsSize], head = 0, tail = 0;                                                                                         
    // ³õÊ¼»¯¶ÓÁÐ£¬½«ËùÓÐÍæ¼Ò±àºÅÒÀ´Î·ÅÈë¶ÓÁÐ                                                                                          
    for (int i = 0; i < skillsSize; ++i) {                                                                                             
        queue[tail++] = i;                                                                                                             
    }                                                                                                                                  
    int winStreak[skillsSize] = {0}; // ¼ÇÂ¼Ã¿¸öÍæ¼ÒµÄÁ¬Ê¤´ÎÊý                                                                         
    int winner = -1, maxStreak = 0; // ¼ÇÂ¼Ó®¼ÒºÍ×î´óÁ¬Ê¤´ÎÊý                                                                          
                                                                                                                                       
    while (head != tail) {                                                                                                             
        // È¡³ö¶ÓÁÐÍ·²¿µÄÁ½¸öÍæ¼Ò±àºÅ                                                                                                  
        int player1 = queue[head++];                                                                                                   
        int player2 = queue[head++];                                                                                                   
        // Ä£Äâ±ÈÈü£¬¼¼ÄÜµÈ¼¶¸ßµÄÊ¤³ö                                                                                                  
        if (skills[player1] > skills[player2]) {                                                                                       
            winStreak[player1]++;                                                                                                      
            if (winStreak[player1] > maxStreak) {                                                                                      
                winner = player1;                                                                                                      
                maxStreak = winStreak[player1];                                                                                        
            }                                                                                                                          
        } else {                                                                                                                       
            winStreak[player2]++;                                                                                                      
            if (winStreak[player2] > maxStreak) {                                                                                      
                winner = player2;                                                                                                      
                maxStreak = winStreak[player2];                                                                                        
            }                                                                                                                          
        }                                                                                                                              
        // Ê¤Õß»Øµ½¶ÓÁÐÍ·²¿                                                                                                            
        queue[tail++] = (player1 == winner) ? player1 : player2;                                                                       
    }                                                                                                                                  
    return winner;                                                                                                                     
}                                                                                                                                      
bool checkIfGridSatisfiesConditions(int** grid, int gridSize, int* gridColSize) {                                                     
    for (int i = 0; i < gridSize; ++i) {                                                                                               
        for (int j = 0; j < gridColSize[i]; ++j) {
            // ¼ì²éÏÂÃæµÄ¸ñ×Ó
            if (i < gridSize - 1 && grid[i][j] != grid[i + 1][j]) { 
                return false;
            }
            // ¼ì²éÓÒ±ßµÄ¸ñ×Ó
            if (j < gridColSize[i] - 1 && grid[i][j] == grid[i][j + 1]) {
                return false;
            }
        }
    }
    return true;
}
int sumDigitDifferences(int* nums, int numsSize) {                                                                                     
    int result = 0;                                                                                                                    
    int maxNum = nums[0];                                                                                                              
                                                                                                                                       
    // ÕÒ³öÊý×éÖÐµÄ×î´óÊý£¬ÒÔÈ·¶¨ÊýÎ»³¤¶È                                                                                              
    for (int i = 1; i < numsSize; ++i) {                                                                                               
        if (nums[i] > maxNum) {                                                                                                        
            maxNum = nums[i];                                                                                                          
        }                        
    }                                                                                                                                  
     
    int digitLength = (int)log10(maxNum) + 1;
     
    // ¶ÔÓÚÃ¿¸öÊýÎ»
    for (int j = 0; j < digitLength; ++j) {
        int* count = (int*)calloc(10, sizeof(int)); // ³õÊ¼»¯Ã¿¸öÊý×Ö³öÏÖµÄ´ÎÊý
         
        // Í³¼ÆÃ¿Ò»Î»ÉÏÃ¿¸öÊý×Ö³öÏÖµÄ´ÎÊý
        for (int i = 0; i < numsSize; ++i) {
            int digit = (nums[i] / pow(10, j)) % 10;
            count[digit]++;
        }
         
        // ¼ÆËãÃ¿Ò»Î»ÉÏÊý×Ö²»Í¬¶ÔµÄÊýÁ¿
        for (int i = 0; i < 10; ++i) {
            result += count[i] * (numsSize - count[i]);
        }
         
        free(count);
    }
     
    return result;
}
#include <stdlib.h>                                                                                                                    
                                                                                                                                       
int* findOccurrences(int* nums, int numsSize, int* queries, int queriesSize, int x, int* returnSize) {                                 
    // ¶¯Ì¬·ÖÅäÊý×éÒÔ´æ´¢²éÑ¯½á¹û                                                                                                      
    int* answer = (int*)malloc(queriesSize * sizeof(int));                                                                             
    *returnSize = queriesSize;                                                                                                         
                                                                                                                                       
    // ±éÀúËùÓÐ²éÑ¯                                                                                                                    
    for (int i = 0; i < queriesSize; ++i) {                                                                                            
        int count = 0; // ÓÃÓÚ¼ÆÊýx³öÏÖµÄ´ÎÊý                                                                                          
        // ÔÚnumsÖÐ²éÕÒx                                                                                                               
        for (int j = 0; j < numsSize; ++j) {                                                                                           
            if (nums[j] == x) {                                                                                                        
                ++count;                                                                                                               
                // ¼ì²éÊÇ·ñÊÇËùÐèµÄµÚk¸öx                                                                                              
                if (count == queries[i]) {                                                                                             
                    answer[i] = j; // ±£´æË÷Òý                                                                                         
                    break; // Ìø³öÄÚ²ãÑ­»·                                                                                             
                }                                                                                                                      
            }                                                      
        }                                                                                                                              
        // Èç¹ûx³öÏÖ´ÎÊý²»×ãqueries[i]£¬ÔòÉèÖÃ´ð°¸Îª-1                                                                                 
        if (count < queries[i]) {                                                                                                      
            answer[i] = -1;                                                                                                            
        }
    }
     
    return answer;
}
#define MOD (1000000007)                                                                                                               
                                                                                                                                       
int maxSumSubsequence(int *nums, int numsSize, int *queries, int queriesSize) {                                                        
    long long dp[50010]; // ¼ÙÉèÊý×é³¤¶È²»»á³¬¹ý50000                                                                                  
    long long sum = 0;                                                                                                                 
    long long prefixSum[50010] = {0};                                                                                                  
                                                                                                                                       
    // ³õÊ¼»¯dpÊý×éºÍÇ°×ººÍ
    for (int i = 0; i < numsSize; i++) {
        prefixSum[i + 1] = (prefixSum[i] + nums[i] + MOD) % MOD;
        dp[i] = (i > 0) ? (prefixSum[i] - prefixSum[i - 1] + MOD) % MOD : nums[0];
        sum = (sum + dp[i]) % MOD;
    }

    // ´¦Àí²éÑ¯
    for (int i = 0; i < queriesSize; i++) {
        int pos = queries[2 * i]; 
        int val = queries[2 * i + 1];
        // ¸üÐÂnumsÊý×éºÍÇ°×ººÍ
        nums[pos] = val;
        prefixSum[pos + 1] = (prefixSum[pos] + val + MOD) % MOD;
        // ÖØÐÂ¼ÆËãdpÊý×é
        for (int j = pos; j < numsSize; j++) {
            dp[j] = (j > 0) ? (prefixSum[j] - prefixSum[j - 1] + MOD) % MOD : nums[j];
            sum = (sum + dp[j]) % MOD;
        }
    }

    return (int)sum;
}
bool isSpecialArray(int *nums, int numsSize, int *queries, int queriesSize, int *answer, int answerSize) {                             
    for (int i = 0; i < queriesSize; ++i) {                                                                                            
        int from = queries[i * 2];                                                                                                     
        int to = queries[i * 2 + 1];                                                                                                   
        bool isSpecial = true;                                                                                                         
        for (int j = from; j < to && isSpecial; ++j) {                                                                                 
            if ((nums[j] % 2) == (nums[j + 1] % 2)) {                                                                                  
                isSpecial = false;
            }
        }
        answer[i] = isSpecial;
    }
    return true;
}
int findTheXOR(int* nums, int numsSize) {                                                                                              
    int xorAll = 0;                                                                                                                    
    for (int i = 0; i < numsSize; i++) {                                                                                               
        xorAll ^= nums[i]; // ¼ÆËãËùÓÐÊý×ÖµÄXOR                                                                                        
    }                                                                                                                                  
    int xorOnce = 0;                                                                                                                   
    for (int i = 0; i < numsSize; i++) {                                                                                               
        int count = 0;                                                                                                                 
        for (int j = 0; j < numsSize; j++) {                                                                                           
            if (nums[i] == nums[j]) count++;                                                                                           
            if (count > 1) break;                                                                                                      
        }
        if (count == 1) xorOnce ^= nums[i]; // ¼õÈ¥³öÏÖÒ»´ÎµÄÊý×ÖµÄXOR
    }
    return xorAll ^ xorOnce; // ·µ»Ø×îÖÕ½á¹û
}
                                                                                                                                       
// ±È½Ïº¯Êý£¬ÓÃÓÚÅÅÐò                                                                                                                  
int compare(const void *a, const void *b) {                                                                                            
    int *meetA = (int *)a;                                                                                                             
    int *meetB = (int *)b;                                                                                                             
    return meetA[0] - meetB[0];                                                                                                        
}                                                                                                                                      

// Ö÷º¯Êý
int countDaysWithoutMeetings(int days, int **meetings, int meetingsSize) {
    // ÌØÊâÇé¿ö´¦Àí
    if (days < 1 || meetingsSize == 0) return days;
     
    // ¶Ô»áÒéÊý×é½øÐÐÅÅÐò
    qsort(meetings, meetingsSize, sizeof(int[2]), compare);
     
    int count = 0;
    int start = 1, end = 0;
     
    // ±éÀú»áÒéÊý×é£¬ºÏ²¢ÖØµþµÄ»áÒé
    for (int i = 0; i < meetingsSize; i++) {
        if (meetings[i][0] > end) {
            // Èç¹ûµ±Ç°»áÒé¿ªÊ¼Ê±¼ä´óÓÚÉÏÒ»¸ö»áÒéµÄ½áÊøÊ±¼ä£¬¼ÆËã¼ä¸ôÌìÊý
            count += meetings[i][0] - start - 1;
            start = meetings[i][1] + 1; // ¸üÐÂ¿ªÊ¼Ê±¼ä
            end = meetings[i][1]; // ¸üÐÂ½áÊøÊ±¼ä
        } else {
            // ·ñÔò£¬ºÏ²¢»áÒéÊ±¼ä¶Î
            end = (meetings[i][1] > end) ? meetings[i][1] : end;
        }
    }
     
    // ×îºóÒ»¸ö»áÒé½áÊøºóµ½days½áÊøµÄÌìÊý
    count += (days > end) ? (days - end) : 0;
     
    return count;
}
// ¶¯Ì¬¹æ»®½â¾öÕÒ³ö·ÖÊý×îµÍµÄÅÅÁÐÎÊÌâ                              
int findMinScorePermutation(int n, int nums[]) {                   
    // ×´Ì¬±íÊ¾£ºdp[i] ±íÊ¾ÒÔ i ½áÎ²µÄÅÅÁÐµÄ×îÐ¡·ÖÊý                                                                                   
    int dp[15] = {0};                                              
    // ¼ÇÂ¼Ã¿¸öÊý×ÖµÄÎ»ÖÃ                                          
    int indices[15] = {0};                                         
    for (int i = 0; i < n; ++i) {                                  
        indices[nums[i]] = i;                                                                                                          
    }                                                                                                                                  
                                                                                                                                       
    // ³õÊ¼»¯×´Ì¬£¬ÒÔÃ¿¸öÊý×Ö½áÎ²µÄÅÅÁÐµÄ³õÊ¼·ÖÊý                  
    for (int i = 0; i < n; ++i) {                                                                                                      
        int j = indices[i];                                        
        if (i > 0) {                                                                                                                   
            dp[j] = dp[indices[i - 1]] + abs(i - nums[j]);         
        } else {                                                                                                                       
            dp[j] = 0;                                                                                                                 
        }                                                                                                                              
    }                                                                                                                                  
                                                                   
    // ¶¯Ì¬¹æ»®£¬¸üÐÂ×´Ì¬
    for (int mask = 1; mask < (1 << n); ++mask) {
        int last = __builtin_ctz(mask); // ÕÒµ½×îµÍÎ»µÄ1
        for (int i = 0; i < n; ++i) {
            if (!(mask & (1 << i))) { // i ²»ÔÚµ±Ç°maskÖÐ
                int next = indices[(i + 1) % n];
                if (dp[next] > dp[indices[last]] + abs(last - i)) { 
                    dp[next] = dp[indices[last]] + abs(last - i);
                }
            }
        }
    }
     
    // ·µ»Ø×îÓÅ½â
    return dp[indices[0]];
}

void findTwoSum(int* nums, int numsSize, int target, int* indices) {                                                                   
    int i;                                                                                                                             
    // ´´½¨Ò»¸ö¹þÏ£±í£¬ÓÃÓÚ´æ´¢ÒÑ¾­±éÀú¹ýµÄÊý×Ö¼°ÆäË÷Òý            
    int hashTable[101] = {0}; // ¼ÙÉèÊý×éÔªËØ²»»á³¬¹ý100    
                                                                   
    for (i = 0; i < numsSize; i++) {                                                                                                   
        // ¼ì²é target ¼õÈ¥µ±Ç°ÔªËØµÄÖµÊÇ·ñ´æÔÚÓÚ¹þÏ£±íÖÐ                                                                              
        if (hashTable[target - nums[i]] != 0) {                    
            // Èç¹û´æÔÚ£¬·µ»ØÕâÁ½¸öÔªËØµÄË÷Òý                                                                                          
            indices[0] = hashTable[target - nums[i]] - 1; // Êý×éË÷Òý´Ó0¿ªÊ¼                                                           
            indices[1] = i;                                        
            return;                                                                                                                    
        }                                                                                                                              
                                                                                                                                       
        // Èç¹û²»´æÔÚ£¬½«µ±Ç°ÔªËØ¼°ÆäË÷Òý´æÈë¹þÏ£±í
        hashTable[nums[i]] = i + 1; // ´æ´¢Ë÷Òý+1£¬ÒòÎªÊý×éË÷Òý´Ó0¿ªÊ¼
    }
}
void findTwoSum(int* nums, int numsSize, int target, int* indices) {                                                                   
    int i;                                                                                                                             
    // ´´½¨Ò»¸ö¹þÏ£±í£¬ÓÃÓÚ´æ´¢ÒÑ¾­±éÀú¹ýµÄÊý×Ö¼°ÆäË÷Òý            
    int hashTable[101] = {0}; // ¼ÙÉèÊý×éÔªËØ²»»á³¬¹ý100    
                                                                   
    for (i = 0; i < numsSize; i++) {                                                                                                   
        // ¼ì²é target ¼õÈ¥µ±Ç°ÔªËØµÄÖµÊÇ·ñ´æÔÚÓÚ¹þÏ£±íÖÐ                                                                              
        if (hashTable[target - nums[i]] != 0) {                    
            // Èç¹û´æÔÚ£¬·µ»ØÕâÁ½¸öÔªËØµÄË÷Òý                                                                                          
            indices[0] = hashTable[target - nums[i]] - 1; // Êý×éË÷Òý´Ó0¿ªÊ¼                                                           
            indices[1] = i;                                        
            return;                                                                                                                    
        }                                                                                                                              
                                                                                                                                       
        // Èç¹û²»´æÔÚ£¬½«µ±Ç°ÔªËØ¼°ÆäË÷Òý´æÈë¹þÏ£±í
        hashTable[nums[i]] = i + 1; // ´æ´¢Ë÷Òý+1£¬ÒòÎªÊý×éË÷Òý´Ó0¿ªÊ¼
    }
}
int minimumDifference(int *nums, int numsSize, int k) {                                                                                
    // ³õÊ¼»¯¹þÏ£±í£¬Ê¹ÓÃÊý×éÄ£Äâ                                                                                                      
    int hashTable[32] = {0}; // ¼ÙÉèintÎª32Î»                                                                                          
    hashTable[0] = 1; // °´Î»»òµÄ³õÊ¼ÖµÎª0                                                                                             
                                                                                                                                       
    int minDiff = __INT_MAX__; // ´æ´¢×îÐ¡¾ø¶Ô²îÖµ                                                                                     
    int prefixOr = 0; // °´Î»»òµÄÇ°×ººÍ                                                                                                
                                                                                                                                       
    for (int i = 0; i < numsSize; ++i) {                                                                                               
        prefixOr |= nums[i]; // ¸üÐÂÇ°×º°´Î»»ò½á¹û                                                                                     
        // ¼ì²é¹þÏ£±íÖÐÊÇ·ñ´æÔÚprefixOr - k£¬¸üÐÂ×îÐ¡¾ø¶Ô²îÖµ                                                                          
        if (hashTable[prefixOr ^ k]) {                                                                                                 
            minDiff = (minDiff < abs(k - prefixOr) ? minDiff : abs(k - prefixOr));                                                     
        }                                                          
        // ¸üÐÂµ±Ç°prefixOrÔÚ¹þÏ£±íÖÐµÄ³öÏÖ´ÎÊý                    
        hashTable[prefixOr]++;                                     
                                                                   
        // ÌØÊâÇé¿ö´¦Àí£ºÈç¹ûprefixOrÒÑ¾­ÊÇk£¬Ö±½Ó·µ»Ø0                                                                                
        if (prefixOr == k) {                                       
            return 0;                                                                                                                  
        }
    }

    return minDiff;
}
int maxTotalReward(int* rewardValues, int rewardValuesSize) {                                                                          
    // ÏÈ¶ÔÊý×é½øÐÐ½µÐòÅÅÐò                                                                                                            
    qsort(rewardValues, rewardValuesSize, sizeof(int), compare);                                                                       
                                                                                                                                       
    int totalReward = 0;                                                                                                               
    int i = 0;                                                                                                                         
    while (i < rewardValuesSize) {                                                                                                     
        // Èç¹ûµ±Ç°½±ÀøÖµ´óÓÚ×Ü½±Àø£¬ÔòÀÛ¼Ó                                                                                            
        if (rewardValues[i] > totalReward) {                                                                                           
            totalReward += rewardValues[i];                                                                                            
        } else {                                                                                                                       
            // ·ñÔòÌø¹ýµ±Ç°½±ÀøÖµ                                                                                                      
            break;                                                                                                                     
        }                                                                                                                              
        i++;                                                                                                                           
    }                                                                                                                                  
    return totalReward;                                                                                                                
}                                                                                                                                      
                                                                                                                                       
// ÓÃÓÚqsortµÄ±È½Ïº¯Êý                                                                                                                 
int compare(const void *a, const void *b) {                                                                                            
    return (*(int*)b - *(int*)a);                                                                                                      
}                                                                                                                                      
int maxTotalReward(int* rewardValues, int rewardValuesSize) {
    // åå¯¹æ°ç»è¿è¡éåºæåº
    qsort(rewardValues, rewardValuesSize, sizeof(int), compare);
    
    int totalReward = 0;
    int i = 0;
    while (i < rewardValuesSize) {
        // å¦æå½åå¥å±å¼å¤§äºæ»å¥å±ï¼åç´¯å 
        if (rewardValues[i] > totalReward) {
            totalReward += rewardValues[i];
        } else {
            // å¦åè·³è¿å½åå¥å±å¼
            break;
        }
        i++;
    }
    return totalReward;
}

// ç¨äºqsortçæ¯è¾å½æ°
int compare(const void *a, const void *b) {
    return (*(int*)b - *(int*)a);
}
int numberOfPairs(int* nums1, int nums1Size, int* nums2, int nums2Size, int k) {
    int result = 0;
    int *count = calloc(1000001, sizeof(int)); // åè®¾nums1ånums2çåç´ ä¸ä¼è¶è¿1000000

    // ç»è®¡nums2ä¸­æ¯ä¸ªæ°åå¶kåæ°çåºç°æ¬¡æ°
    for (int i = 0; i < nums2Size; i++) {
        count[nums2[i]]++; // åå§æ°åºç°æ¬¡æ°
        count[nums2[i] * k]++; // kåæ°åºç°æ¬¡æ°
    }

    // è®¡ç®ä¼è´¨æ°å¯¹çæ°é
    for (int i = 0; i < nums1Size; i++) {
        if (nums1[i] % k == 0) { // å¦ænums1[i]ä¸æ¯kçåæ°ï¼åä¸å¯è½å½¢æä¼è´¨æ°å¯¹
            result += count[nums1[i] / k];
        }
    }

    free(count);
    return result;
}
char* removeStars(char* s) {
    int len = strlen(s);
    char result[len + 1]; // +1 for null terminator
    int resultIndex = 0;
    int i = 0;

    while (i < len) {
        if (s[i] == '*') {
            // Find the smallest character on the left of '*'
            int minIndex = i - 1;
            while (minIndex >= 0 && s[minIndex] == '*') {
                minIndex = resultIndex - (i - minIndex) - 1;
            }
            if (minIndex >= 0) {
                for (int j = i - 1; j > minIndex; --j) {
                    if (s[j] < s[minIndex]) {
                        minIndex = j;
                    }
                }
                result[resultIndex++] = s[minIndex];
            }
            // Skip over the '*' and the character we are removing
            i = i + 2;
        } else {
            result[resultIndex++] = s[i++];
        }
    }
    result[resultIndex] = '\0'; // Null-terminate the result string
    strcpy(s, result); // Copy result back to the input string
    return s;
}
char *clearDigits(char *s) {
    int len = strlen(s);
    int i = 0, j = 0;
    char *result = (char *)malloc(len + 1);
    if (!result) return NULL;

    while (i < len) {
        if (s[i] >= '0' && s[i] <= '9') {
            // æ¾å°æ°å­ï¼åå·¦æ¾å°æè¿çéæ°å­å­ç¬¦
            int left = i;
            while (left > 0 && isdigit(s[left - 1])) --left;
            // è®¡ç®è¦è·³è¿çå­ç¬¦æ°
            int skip = i - left + 1;
            // è·³è¿è¿äºå­ç¬¦
            i += skip;
            // æ´æ°jçä½ç½®ï¼å ä¸ºiå·²ç»ç§»å¨äº
            j -= skip;
        } else {
            // å¤å¶éæ°å­å­ç¬¦å°ç»æå­ç¬¦ä¸²
            result[j++] = s[i];
        }
        i++;
    }
    result[j] = '\0'; // ç¡®ä¿ç»æå­ç¬¦ä¸²ä»¥ç©ºå­ç¬¦ç»å°¾
    return result;
}
int maxConsecutiveAvailable(int* seats, int seatsSize) {
    int maxCount = 0;
    int count = 0; // è®°å½å½åè¿ç»­ç©ºä½åº§ä½çæ°é

    for (int i = 0; i < seatsSize; i++) {
        if (seats[i] == 1) {
            count++; // ç©ºåº§ï¼è¿ç»­è®¡æ°å 1
        } else {
            maxCount = (count > maxCount) ? count : maxCount; // æ¯è¾å¹¶æ´æ°æå¤§è¿ç»­ç©ºä½åº§ä½æ°é
            count = 0; // éç½®è®¡æ°å¨
        }
    }
    
    // æ£æ¥æåä¸ä¸ªè¿ç»­åºå
    maxCount = (count > maxCount) ? count : maxCount;
    return maxCount;
}
## è§£é¢æè·¯
è¿ä¸ªé®é¢å¯ä»¥éè¿é¢å¤çåè´ªå¿ç­ç¥æ¥è§£å³ãé¦åï¼æä»¬éè¦çè§£æ±æè·ç¦»çæ¦å¿µï¼å³ä¸¤ä¸ªæ°å¨äºè¿å¶è¡¨ç¤ºä¸­ä¸åä½æ°çä¸ªæ°ãä¸ºäºæå¤§åæ±æè·ç¦»ï¼æä»¬åºè¯¥å¯»æ¾å·®å¼æå¤§çä¸¤ä¸ªæ°ã

// å½æ°ç¨äºè®¡ç®ä¸¤ä¸ªæ°çæ±æè·ç¦»
int hammingDistance(int x, int y) {
    int dist = 0, xorRes = x ^ y;
    while (xorRes) {
        if (xorRes & 1) dist++;
        xorRes >>= 1;
    }
    return dist;
}

// å½æ°ç¨äºæ¾å°æå¤§æ±æè·ç¦»çä¸å¯¹æ°
int maxHammingDistance(int* nums, int numsSize, int m) {
    int maxDist = 0, xorSum = 0;
    // è®¡ç®æææ°çå¼æç»æ
    for (int i = 0; i < numsSize; i++) {
        xorSum ^= nums[i];
    }
    // å¯»æ¾æ±æè·ç¦»æå¤§çä¸å¯¹æ°
    for (int i = 0; i < numsSize; i++) {
        maxDist = max(maxDist, hammingDistance(nums[i], xorSum ^ nums[i]));
    }
    return maxDist;
}

// è¾å©å½æ°ï¼ç¨äºæ¯è¾ä¸¤ä¸ªæ´æ°
int max(int a, int b) {
    return a > b ? a : b;
}
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

int findMinSumTreeLevel(TreeNode* root) {
    if (!root) return 0;
    
    int minSum = INT_MAX, minLevel = 0;
    int level = 0; // è®°å½å½åå±çº§
    struct TreeNode **queue = malloc(sizeof(TreeNode*) * 10000); // åè®¾èç¹æ°ä¸ä¼è¶è¿10000
    int front = 0, rear = 0;
    
    queue[rear++] = root;
    
    while (front < rear) {
        int count = rear - front; // å½åå±çèç¹æ°
        int levelSum = 0;
        while (count--) {
            TreeNode *node = queue[front++];
            levelSum += node->val;
            if (node->left) {
                queue[rear++] = node->left;
            }
            if (node->right) {
                queue[rear++] = node->right;
            }
        }
        if (levelSum < minSum) {
            minSum = levelSum;
            minLevel = level;
        }
        level++;
    }
    
    free(queue);
    return minLevel;
}
// å½æ°ç¨äºè®¡ç®ç¸é»åç´ çæä½æç»æ
int* getBitwiseOR(int* nums, int numsSize, int* returnSize) {
    // åéä¸ä¸ªæ°ç»ç¨äºå­å¨ç»æï¼å¶å¤§å°ä¸ºnumsSize-1
    int* result = (int*)malloc(sizeof(int) * (numsSize - 1));
    *returnSize = numsSize - 1;

    // åå§åç¬¬ä¸ä¸ªç»æä¸ºç¬¬ä¸ä¸ªåç´ 
    result[0] = nums[0];

    // éåæ°ç»ï¼ä»ç¬¬äºä¸ªåç´ å¼å§
    for (int i = 1; i < numsSize; i++) {
        // å¯¹æ¯å¯¹ç¸é»åç´ æ§è¡æä½ææä½
        result[i - 1] = nums[i - 1] | nums[i];
    }

    return result;
}

int main() {
    // ç¤ºä¾æ°ç»
    int nums[] = {1, 3, 7, 15};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int returnSize = 0;

    // è°ç¨å½æ°å¹¶æå°ç»æ
    int* res = getBitwiseOR(nums, numsSize, &returnSize);
    for (int i = 0; i < returnSize; i++) {
        printf("%d ", res[i]);
    }
    printf("\n");

    // éæ¾åéçåå­
    free(res);

    return 0;
}
// å®ä¹å¾çé»æ¥åè¡¨ç»æ
typedef struct {
    int **edges;
    int size;
} Graph;

// åå»ºå¾
Graph createGraph(int size) {
    Graph graph;
    graph.edges = (int **)malloc(size * sizeof(int *));
    for (int i = 0; i < size; i++) {
        graph.edges[i] = (int *)malloc(0 * sizeof(int)); // åå§åä¸ºç©ºæ°ç»
    }
    graph.size = size;
    return graph;
}

// æ·»å è¾¹
void addEdge(Graph *graph, int start, int end) {
    int index = start;
    graph->edges[index] = (int *)realloc(graph->edges[index], (1 + graph->edges[index][0]) * sizeof(int));
    graph->edges[index][graph->edges[index][0] + 1] = end;
    graph->edges[index][0]++;
}

// æ·±åº¦ä¼åæç´¢æ¥æ¾è·¯å¾
bool dfs(int start, int target, int *visited, Graph graph) {
    if (start == target) return true;
    visited[start] = 1;
    for (int i = 1; i <= graph.edges[start][0]; i++) {
        int next = graph.edges[start][i];
        if (!visited[next] && dfs(next, target, visited, graph)) {
            return true;
        }
    }
    return false;
}

// æ£æ¥èç¹é´æ¯å¦å­å¨éè·¯
bool findWhetherExistsPath(int n, int **graph, int start, int target) {
    if (n <= 0 || !graph || start < 0 || target < 0) return false;
    
    // è½¬æ¢è¾å¥æ ¼å¼
    Graph g = createGraph(n);
    for (int i = 0; i < n; i++) {
        int vertex = i;
        for (int j = 0; j < graph[i][0]; j++) {
            addEdge(&g, vertex, graph[i][j]);
        }
    }
    
    int *visited = (int *)calloc(n, sizeof(int)); // æ è®°æ°ç»
    return dfs(start, target, visited, g);
}

// ç¤ºä¾æµè¯
int main() {
    int n1 = 3;
    int graph1[1][2] = {{0, 1}, {0, 2}, {1, 2}, {1, 2}};
    int start1 = 0, target1 = 2;
    printf("Path exists: %s\n", findWhetherExistsPath(n1, graph1, start1, target1) ? "true" : "false");

    int n2 = 5;
    int graph2[6][2] = {{0, 1}, {0, 2}, {0, 4}, {0, 4}, {1, 3}, {1, 4}, {1, 3}, {2, 3}, {3, 4}};
    int start2 = 0, target2 = 4;
    printf("Path exists: %s\n", findWhetherExistsPath(n2, graph2, start2, target2) ? "true" : "false");

    return 0;
}
#include <stdlib.h>
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// åå»ºæå°é«åº¦æ çéå½å½æ°
TreeNode* sortedArrayToBST(int* nums, int left, int right) {
    if (left > right) return NULL;
    
    // éæ©ä¸­é´ä½ç½®çåç´ ä½ä¸ºæ ¹èç¹
    int mid = (left + right) / 2;
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
    node->val = nums[mid];
    node->left = sortedArrayToBST(nums, left, mid - 1);
    node->right = sortedArrayToBST(nums, mid + 1, right);
    
    return node;
}

// æå»ºæå°é«åº¦æ çæ¥å£å½æ°
TreeNode* sortedArrayToBSTLCCI(int* nums, int numsSize) {
    return sortedArrayToBST(nums, 0, numsSize - 1);
}
   - åå§åä¸ä¸ªéåï¼å°æ ¹èç¹å å¥éåã
   - ä½¿ç¨ä¸ä¸ªè®¡æ°å¨è®°å½å½åæ·±åº¦ã
   - å½éåéç©ºæ¶ï¼è¿è¡ä»¥ä¸æä½ï¼
     - è®°å½å½åæ·±åº¦çèç¹æ°éã
     - åå»ºå½åæ·±åº¦çé¾è¡¨ã
     - éåéåä¸­çææèç¹ï¼å°å®ä»¬æ·»å å°å½åæ·±åº¦çé¾è¡¨ä¸­ï¼å¹¶å¤çå®ä»¬çå­èç¹ï¼å°å­èç¹å å¥éåã

5. **å®ç°ç»è**ï¼å¨Cè¯­è¨ä¸­ï¼æä»¬éè¦å®ä¹åéçç»æä½æ¥è¡¨ç¤ºäºåæ èç¹åé¾è¡¨èç¹ã

## Cè¯­è¨ä»£ç å®ç°ï¼

```c
#include <stdlib.h>

// å®ä¹äºåæ èç¹
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// å®ä¹é¾è¡¨èç¹
typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

// åå»ºé¾è¡¨
ListNode* createListNode(int val) {
    ListNode* node = (ListNode*)malloc(sizeof(ListNode));
    node->val = val;
    node->next = NULL;
    return node;
}

// ä¸ºç¹å®æ·±åº¦åå»ºé¾è¡¨
ListNode** createLinkedLists(TreeNode* root, int* depths, int depthCount) {
    ListNode **lists = (ListNode**)malloc(sizeof(ListNode*) * depthCount);
    for (int i = 0; i < depthCount; i++) {
        lists[i] = NULL;
    }
    if (!root) return lists;

    // ä½¿ç¨éåå®ç°BFS
    int currentDepth = 0;
    int index = 0;
    TreeNode *node, *left, *right;
    ListNode *listNode, *prev = NULL;
    while (root != NULL) {
        int levelSize = 0; // å½åæ·±åº¦çèç¹æ°é
        for (node = root; node != NULL; node = node->right) {
            levelSize++;
            if (lists[currentDepth] == NULL) {
                lists[currentDepth] = createListNode(node->val);
                prev = lists[currentDepth];
            } else {
                prev->next = createListNode(node->val);
                prev = prev->next;
            }
        }
        root = NULL; // éç½®rootä¸ºNULLï¼ä»¥ä¾¿ä¸ä¸è½®å±çº§éå
        for (node = root; node != NULL; node = node->left) {
            if (node->left != NULL) {
                if (!root) root = node->left;
                else root = node->left->right;
                node->left = root;
            }
            if (node->right != NULL) {
                if (!root) root = node->right;
                else root = node->right->right;
                node->right = root;
            }
        }
        currentDepth++;
    }
    return lists;
}

// éæ¾é¾è¡¨åå­
void freeLinkedLists(ListNode** lists, int count) {
    for (int i = 0; i < count; i++) {
        ListNode *node = lists[i], *next;
        while (node != NULL) {
            next = node->next;
            free(node);
            node = next;
        }
    }
    free(lists);
}

// ç¤ºä¾ä½¿ç¨
int main() {
    // æå»ºç¤ºä¾äºåæ 
    TreeNode *root = NULL; // åè®¾è¿éå·²ç»æå»ºäºäºåæ 
    // ...

    // è·åæ·±åº¦
    int depth;
    // è°ç¨å½æ°åå»ºé¾è¡¨
    ListNode **lists = createLinkedLists(root, &depth, /* depthCount */);

    // ä½¿ç¨é¾è¡¨...

    // éæ¾é¾è¡¨åå­
    freeLinkedLists(lists, depth);

    return 0;
}
TreeNode* lowestCommonAncestorIV(TreeNode* root, int x, int y) {
    // å¦ææ ä¸ºç©ºæèå½åèç¹æ¯è¦æ¾çèç¹ä¹ä¸
    if (!root || root->val == x || root->val == y) {
        return root;
    }
    
    // å¨å·¦å­æ ä¸­æ¥æ¾
    TreeNode *left = lowestCommonAncestorIV(root->left, x, y);
    // å¨å³å­æ ä¸­æ¥æ¾
    TreeNode *right = lowestCommonAncestorIV(root->right, x, y);
    
    // å¦æå·¦å³å­æ é½ä¸ºç©ºï¼è¯´æä¸¤ä¸ªèç¹é½ä¸å¨å­æ ä¸­ï¼è¿åNULL
    if (!left && !right) return NULL;
    
    // å¦æå·¦å­æ åå³å­æ é½éç©ºï¼è¯´æä¸¤ä¸ªèç¹åå«å¨å·¦å³å­æ ä¸­ï¼å½åèç¹æ¯LCA
    if (left && right) return root;
    
    // å¦æå·¦å­æ éç©ºï¼è¯´æxåyé½å¨å·¦å­æ ä¸­
    // å¦æå³å­æ éç©ºï¼è¯´æxåyé½å¨å³å­æ ä¸­
    return left ? left : right;
}
int longestPalindromeSubseq(char *s) {
    int len = strlen(s);
    int *dp = (int *)malloc(sizeof(int) * len * len);
    memset(dp, 0, sizeof(int) * len * len);

    for (int i = len - 1; i >= 0; --i) {
        dp[i][i] = 1;
        for (int j = i + 1; j < len; ++j) {
            if (s[i] == s[j]) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = (dp[i + 1][j] > dp[i][j - 1]) ? dp[i + 1][j] : dp[i][j - 1];
            }
        }
    }

    int result = dp[0][len - 1];
    free(dp);
    return result;
}
int largestSubarraySum(int* nums, int numsSize, int k) {
    if (numsSize < k) return 0;
    
    int maxSum = 0, windowSum = 0;
    
    // åå§åçªå£å
    for (int i = 0; i < k; ++i) {
        windowSum += nums[i];
    }
    maxSum = windowSum;
    
    // ç§»å¨çªå£ï¼æ´æ°çªå£å
    for (int i = k; i < numsSize; ++i) {
        windowSum += nums[i] - nums[i - k];
        maxSum = (maxSum > windowSum) ? maxSum : windowSum;
    }
    
    return maxSum;
}
// å½æ°ç¨äºè¿åé¿åº¦ä¸º k çæå¤§å­æ°ç»çå
int largestSubarraySum(int* nums, int numsSize, int k) {
    if (numsSize < k) return 0;
    
    int maxSum = 0, windowSum = 0;
    
    // åå§åçªå£å
    for (int i = 0; i < k; ++i) {
        windowSum += nums[i];
    }
    maxSum = windowSum;
    
    // ç§»å¨çªå£ï¼æ´æ°çªå£å
    for (int i = k; i < numsSize; ++i) {
        windowSum += nums[i] - nums[i - k];
        maxSum = (maxSum > windowSum) ? maxSum : windowSum;
    }
    
    return maxSum;
}
### è§£é¢æè·¯
1. **BFSï¼å¹¿åº¦ä¼åæç´¢ï¼**ï¼ç±äºæä»¬éè¦æ¾å°æç­è·¯å¾ï¼BFSæ¯ä¸ä¸ªèªç¶çéæ©ï¼å ä¸ºå®æå±çº§éåèç¹ï¼å¯ä»¥æ¾å°ä»èµ·ç¹å°ç»ç¹çæç­è·¯å¾ã
2. **ç¶æè¡¨ç¤º**ï¼ä½¿ç¨ä¸ä¸ªäºç»´æ°ç»æ¥è¡¨ç¤ºç½æ ¼ï¼å¶ä¸­`grid[i][j]`è¡¨ç¤ºä»èµ·ç¹å°å½åä½ç½®çæå°æ­¥æ°ã
3. **éç¢ç©å¤ç**ï¼å¦æéå°éç¢ç©ï¼`-1`ï¼ï¼åä¸è½éè¿è¯¥ä½ç½®ï¼éè¦ç»éèè¡ã

### Cè¯­è¨å®ç°
```c
#include <stdio.h>
#define MAXN 301

int shortestPathInHiddenGrid(int** grid, int gridSize, int *gridColSize) {
    // åå§åæ¹åæ°ç»ï¼è¡¨ç¤ºåå³ååä¸çç§»å¨
    int dir[2][2] = {{1, 0}, {0, 1}};
    int visited[MAXN][MAXN]; // è®¿é®æ°ç»ï¼é¿åéå¤è®¿é®
    int queue[MAXN * MAXN][2]; // éåå­å¨ä½ç½®åæ­¥æ°
    int head = 0, tail = 0; // éåçå¤´åå°¾

    // å°èµ·ç¹å å¥éåï¼å¹¶æ è®°ä¸ºå·²è®¿é®
    queue[tail][0] = 0;
    queue[tail][1] = 0;
    tail++;
    visited[0][0] = 1;

    while (head < tail) {
        int x = queue[head][0];
        int y = queue[head][1];
        head++;

        // æ£æ¥æ¯å¦å°è¾¾ç»ç¹
        if (x == gridSize - 1 && y == gridColSize - 1) {
            return visited[x][y];
        }

        // éååä¸ªæ¹å
        for (int k = 0; k < 2; k++) {
            int newX = x + dir[k][0];
            int newY = y + dir[k][1];

            // æ£æ¥æ°ä½ç½®æ¯å¦ææ
            if (newX >= 0 && newY >= 0 && newX < gridSize && newY < *gridColSize && !visited[newX][newY] && grid[newX][newY] != -1) {
                queue[tail][0] = newX;
                queue[tail][1] = newY;
                tail++;
                visited[newX][newY] = visited[x][y] + 1;
            }
        }
    }

    return -1; // å¦ææ²¡ææ¾å°è·¯å¾ï¼åè¿å-1
}
int maximumBeauty(int* flowers, int flowersSize, int k) {
    int maxBeauty = 0;
    int sum = 0;
    for (int i = 0; i < k; i++) {
        sum += flowers[i];
    }
    maxBeauty = sum;
    
    for (int i = k; i < flowersSize; i++) {
        sum += flowers[i] - flowers[i - k];
        maxBeauty = (maxBeauty > sum) ? maxBeauty : sum;
    }
    
    return maxBeauty;
}
æ¨æå°çé®é¢æ¯LeetCodeä¸ç1804é¢ï¼å®ç° Trie ï¼åç¼æ ï¼ IIãè¿ä¸ªé®é¢è¦æ±å®ç°ä¸ä¸ªTrieæ ï¼ä¹ç§°ä¸ºåç¼æ ï¼å®æ¯ä¸ç§ç¨äºæ£ç´¢å­ç¬¦ä¸²æ°æ®éä¸­çé®çç¹æ®ç±»åçæç´¢æ ãTrieæ çæ¯ä¸ªèç¹åå«è¥å¹²å­èç¹ï¼éå¸¸æ¯26ä¸ªï¼å¯¹åºä»aå°zçå­æ¯ãTrieæ å¸¸ç¨äºæ¼åæ£æ¥ãæç´¢å¼æçèªå¨è¡¥å¨ãIPè·¯ç±ç­åºæ¯ã

// å®ä¹ç½æ ¼åç¸å³åé
int grid[M][N]; // åè®¾MxNæ¯ç½æ ¼çå¤§å°
int visited[M][N]; // æ è®°è®¿é®ç¶æ
int start, end; // èµ·ç¹åç»ç¹

// æ§è¡BFSæç´¢
void bfs(int start_x, int start_y) {
    queue<int> q;
    int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // åä¸ªæ¹å
    q.push(start_x * N + start_y);
    visited[start_x][start_y] = 1;

    while (!q.empty()) {
        int current = q.front();
        q.pop();
        int x = current / N;
        int y = current % N;

        if (x == end_x && y == end_y) {
            // æ¾å°ç»ç¹ï¼è¿åè·¯å¾æ¶è
            return;
        }

        for (int i = 0; i < 4; ++i) {
            int new_x = x + directions[i][0];
            int new_y = y + directions[i][1];
            if (new_x >= 0 && new_x < M && new_y >= 0 && new_y < N && !visited[new_x][new_y]) {
                q.push(new_x * N + new_y);
                visited[new_x][new_y] = 1;
            }
        }
    }
}
int maxIceCream(int costs[], int costsSize, int coins) {
    int count[100001] = {0}; // è®¡æ°æ°ç»ï¼ç¨äºè®¡æ°æåº
    for (int i = 0; i < costsSize; i++) {
        count[costs[i]]++; // ç»è®¡æ¯ä¸ªä»·æ ¼çéªç³æ°é
    }
    
    int total = 0; // è®¡ç®è½ä¹°å°çéªç³æ»æ°
    for (int price = 1; price <= 100000 && coins > 0; price++) {
        while (count[price] > 0 && coins >= price) {
            total++; // è´­ä¹°éªç³
            coins -= price; // åå»ç¸åºçé±
            count[price]--; // åå°è¯¥ä»·æ ¼çéªç³æ°é
        }
    }
    return total;
}
int isBeautifulSubstring(const char* word, int length) {
    int max_length = 0;
    int vowels_count[5] = {0}; // è®°å½æ¯ä¸ªåé³çä¸ªæ°
    int required_vowels = 5; // éè¦çåé³å­æ¯ç§ç±»æ°

    // å®ä¹å·¦å³æé
    int left = 0, right = 0;

    while (right < length) {
        char current = word[right];

        // å¢å å½åå­ç¬¦å¯¹åºçåé³è®¡æ°
        vowels_count[current - 'a']++;

        // å¦æå½åå­ç¬¦æ¯åé³ï¼æ£æ¥æ¯å¦æ»¡è¶³æ¡ä»¶
        if (current == 'a' || vowels_count[current - 'a'] > 1) {
            while (left <= right && required_vowels > 0) {
                if (word[left] == 'a') {
                    required_vowels--;
                }
                vowels_count[word[left++] - 'a']--;
            }
        }

        // æ´æ°æå¤§é¿åº¦
        max_length = max_length > right - left ? max_length : right - left;
        right++;
    }

    return max_length;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// å®ä¹ä¸ä¸ªç»æä½æ¥å­å¨åè¯åå®çç´¢å¼
typedef struct {
    char word[201]; // å­å¨åè¯
    int index;      // å­å¨ç´¢å¼
} WordIndex;

// æ¯è¾å½æ°ï¼ç¨äº qsort
int compare(const void *a, const void *b) {
    WordIndex *word1 = (WordIndex *)a;
    WordIndex *word2 = (WordIndex *)b;
    return word1->index - word2->index;
}

char *sortSentence(char *s) {
    int len = strlen(s);
    int wordCount = 0;
    WordIndex words[9]; // ç±äºé¢ç®éå¶åè¯æ°éä¸è¶è¿9ä¸ª

    // è®¡ç®åè¯æ°éå¹¶æååè¯åç´¢å¼
    for (int i = 0; i < len; i++) {
        if (s[i] == ' ') {
            s[i] = '\0'; // æ¿æ¢ç©ºæ ¼ä¸ºå­ç¬¦ä¸²ç»æç¬¦
            words[wordCount].index = atoi(words[wordCount].word + strlen(words[wordCount].word) - 1) - 1; // æåç´¢å¼
            wordCount++;
        }
        else if (s[i] != '\0') {
            words[wordCount].word[strlen(words[wordCount].word)] = s[i]; // æ¼æ¥åè¯
        }
    }

    // æåºåè¯
    qsort(words, wordCount, sizeof(WordIndex), compare);

    // æé å¹¶è¿åç»æå¥å­
    for (int i = 0; i < wordCount; i++) {
        if (i > 0) {
            strcat(s, " "); // æ·»å ç©ºæ ¼
        }
        strcat(s, words[i].word); // æ¼æ¥åè¯
    }
    return s;
}

int main() {
    char s[] = "is2 sentence4 This1 a3";
    char *sorted = sortSentence(s);
    printf("Sorted Sentence: %s\n", sorted);
    return 0;
}
#include <stdio.h>

// å®ä¹ä¸ä¸ªç»æä½æ¥ä¿å­ç»æ
typedef struct {
    int crashTime;    // ç¨åºå´©æºçæ¶é´
    int memory1Crash; // åå­æ¡1å´©æºæ¶çå©ä½åå­
    int memory2Crash; // åå­æ¡2å´©æºæ¶çå©ä½åå­
} Result;

Result incrementallyLeakMemory(int memory1, int memory2) {
    Result result = {0, memory1, memory2}; // åå§åç»æç»æä½
    int second = 1; // ä»ç¬¬1ç§å¼å§

    // å½ä¸¤ä¸ªåå­æ¡é½è¿æåå­æ¶ï¼ç»§ç»­åéåå­
    while (memory1 >= 0 && memory2 >= 0) {
        int allocateMemory = second; // å½åç§æ°å³ä¸ºè¦åéçåå­ä½æ°
        if (memory1 >= memory2) {
            memory1 -= allocateMemory; // åå­æ¡1åéåå­
        } else {
            memory2 -= allocateMemory; // åå­æ¡2åéåå­
        }
        second++; // ç§æ°å¢å 
    }

    // æ ¹æ®åå­åéæåµæ´æ°å´©æºæ¶çåå­æ°
    result.crashTime = second - 1;
    if (memory1 < 0) {
        result.memory1Crash = 0;
    } else {
        result.memory2Crash = 0;
    }

    return result;
}

int main() {
    int memory1 = 2, memory2 = 2;
    Result result = incrementallyLeakMemory(memory1, memory2);
    printf("Crash Time: %d, Memory1: %d, Memory2: %d\n", result.crashTime, result.memory1Crash, result.memory2Crash);
    return 0;
}
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// å½æ°ç¨äºå¤æ­å­ç¬¦ä¸²ä»ç´¢å¼iå¼å§çé¨åæ¯å¦ä¸ºéåçè¿ç»­å¼
int isDecreasingSubsequence(char *s, int i) {
    int num = 0;
    for (int j = i; j < strlen(s); j++) {
        num = num * 10 + (s[j] - '0');
    }
    // æ£æ¥æåçç¬¬ä¸ä¸ªæ°æ¯å¦ä¸ºéåçèµ·å§ç¹
    if (i == 0 || num > s[i - 1] - 1) {
        return 1;
    }
    return 0;
}

// å½æ°ç¨äºå¤æ­å­ç¬¦ä¸²sæ¯å¦è½å¤æè¦æ±æå
int canSplit(char *s, int index) {
    if (index == strlen(s)) return 1;  // å°è¾¾å­ç¬¦ä¸²æ«å°¾ï¼è¿åtrue
    if (s[index] == '0') return 0;  // éå°0ï¼æ æ³å½¢æéååºåï¼è¿åfalse

    // å°è¯ä»å½åç´¢å¼å¼å§æå
    for (int len = 1; len <= strlen(s) - index; len++) {
        int num = 0;
        // æå»ºå½åå­å­ç¬¦ä¸²çæ°å¼
        for (int j = 0; j < len; j++) {
            num = num * 10 + (s[index + j] - '0');
        }

        // å¦æå½åå­å­ç¬¦ä¸²çæ°å¼ä¸åä¸ä¸ªæ°å¼ç¸å·®1ï¼ç»§ç»­éå½æ£æ¥
        if (isDecreasingSubsequence(s, index) && canSplit(s, index + len)) {
            return 1;
        }
    }
    return 0;
}

int splitString(char *s) {
    return canSplit(s, 0);
}

int main() {
    char s1[] = "1234";
    char s2[] = "050043";
    char s3[] = "9080701";
    char s4[] = "10009998";

    printf("%s -> %d\n", s1, splitString(s1));
    printf("%s -> %d\n", s2, splitString(s2));
    printf("%s -> %d\n", s3, splitString(s3));
    printf("%s -> %d\n", s4, splitString(s4));

    return 0;
}
#include <stdio.h>

// å®ä¹åºé´ç»æä½
typedef struct {
    int left, right;
} Interval;

// æ¯è¾å½æ°ï¼ç¨äºå¯¹åºé´çç»æç¹è¿è¡æåº
int compare(const void *a, const void *b) {
    Interval *ia = (Interval *)a;
    Interval *ib = (Interval *)b;
    return ia->right - ib->right; // æç»æç¹æåº
}

int* minInterval(int** intervals, int intervalsSize, int* queries, int queriesSize, int* returnSize) {
    // åå§åè¿åæ°ç»
    int *result = (int *)malloc(sizeof(int) * queriesSize);
    *returnSize = queriesSize;

    // å­å¨åºé´çç»æç¹
    int ends[intervalsSize];
    for (int i = 0; i < intervalsSize; ++i) {
        ends[i] = intervals[i][1];
    }
    
    // å¯¹åºé´çç»æç¹è¿è¡æåº
    qsort(ends, intervalsSize, sizeof(int), compare);

    // ç¨äºå­å¨å½åæ¥è¯¢çæå°åºé´é¿åº¦
    int minLen = -1;
    int minLeft = 0;

    // éåæææ¥è¯¢
    for (int i = 0; i < queriesSize; ++i) {
        int query = queries[i];
        // ä»å½åæå°åºé´å¼å§äºåæ¥æ¾åå«queryçæå°åºé´
        int left = 0, right = intervalsSize - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (intervals[mid][0] <= query && query <= intervals[mid][1]) {
                // æ£æ¥æ¯å¦æ¯æå°çåºé´
                if (mid > 0 && intervals[mid - 1][1] >= query) {
                    left = mid + 1;
                } else {
                    // æ¾å°æå°åºé´ï¼æ´æ°ç»æ
                    result[i] = intervals[mid][1] - intervals[mid][0] + 1;
                    break;
                }
            } else if (query < intervals[mid][0]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        // å¦ææ²¡ææ¾å°åºé´ï¼ç»æä¸º-1
        if (result[i] == 0) {
            result[i] = -1;
        }
    }

    return result;
}
int getMinSwaps(char* num, int k) {
    int len = strlen(num);
    int count = 0;
    int swaps[len];
    memset(swaps, 0, sizeof(swaps));

    // å°numè½¬æ¢ä¸ºæ´æ°æ°ç»å¹¶è¿è¡æåº
    int nums[len];
    for (int i = 0; i < len; ++i) {
        nums[i] = num[i] - '0';
    }
    for (int i = 0; i < len - 1; ++i) {
        for (int j = i + 1; j < len; ++j) {
            if (nums[i] > nums[j]) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }
    }

    // æ¾å°ç¬¬kä¸ªæå°å¦æ°
    for (int i = 0; i < k; ++i) {
        int smallest = len - 1;
        while (nums[smallest] <= nums[smallest - 1]) {
            --smallest;
        }
        if (smallest != len - 1) {
            int temp = nums[smallest];
            nums[smallest] = nums[len - 1];
            nums[len - 1] = temp;
            ++count;
            swaps[len - 1] = 1;
        }
        // å°æ°ç»çæåä¸ä¸ªåç´ ç§»å°åé¢ç»§ç»­å¯»æ¾
        for (int j = len - 1; j > smallest; --j) {
            nums[j] = nums[j - 1];
            swaps[j] = swaps[j - 1] + 1;
        }
        nums[smallest] = INT_MAX; // æ è®°ä¸ºå·²ä½¿ç¨
    }

    return swaps[len - 1];
}
// Definition for singly-linked list.
struct ListNode {
    int val;
    struct ListNode *next;
};

struct ListNode* deleteDuplicatesUnsorted(struct ListNode* head) {
    if (head == NULL) return NULL;
    
    // åå»ºä¸ä¸ªåå¸è¡¨ç¨äºè®°å½éå¤åç´ 
    // åè®¾æä»¬æä¸ä¸ªåå¸è¡¨å®ç°ï¼è¿éç¨ä¸ä¸ªç®åçæ°ç»æ¨¡æ
    int existed[101] = {0}; // åè®¾é¾è¡¨ä¸­åç´ çå¼åä¸º0å°100
    struct ListNode *dummy = (struct ListNode *)malloc(sizeof(struct ListNode)); // åå»ºåèç¹
    struct ListNode *prev = dummy, *curr = head;
    
    while (curr != NULL) {
        if (!existed[curr->val]) {
            existed[curr->val] = 1; // æ è®°åç´ å·²å­å¨
            prev->next = curr; // å°å½åèç¹æ·»å å°ç»æé¾è¡¨
            prev = prev->next;
        } else {
            // å¦æåç´ å·²å­å¨ï¼æ´æ°å½åèç¹çæé
            curr = curr->next;
        }
    }
    prev->next = NULL; // ç»æ­¢é¾è¡¨
    
    return dummy->next; // è¿åç»æé¾è¡¨çå¤´èç¹
}
// æ£æµç¯çå­å¨
int hasCycle(int *colors, int **edges, int n, int m) {
    int *visited = (int *)malloc(n * sizeof(int)); // 0: unvisited, 1: visiting, 2: visited
    for (int i = 0; i < n; ++i) {
        if (!visited[i]) {
            if (dfs(i, visited, colors, edges, n, m)) {
                free(visited);
                return 1;
            }
        }
    }
    free(visited);
    return 0;
}

int dfs(int node, int *visited, char *colors, int **edges, int n, int m) {
    visited[node] = 1; // æ è®°ä¸ºvisiting
    for (int i = 0; i < m; ++i) {
        if (edges[i][0] == node) {
            int nextNode = edges[i][1];
            if (!visited[nextNode]) {
                if (dfs(nextNode, visited, colors, edges, n, m)) return 1;
            } else if (visited[nextNode] == 1) {
                return 1; // æ£æµå°ç¯
            }
        }
    }
    visited[node] = 2; // æ è®°ä¸ºvisited
    return 0;
}

// æææåº
void topologicalSort(int **edges, int n, int m, int *sorted) {
    int *inDegree = (int *)calloc(n, sizeof(int));
    for (int i = 0; i < m; ++i) {
        inDegree[edges[i][1]]++;
    }

    int index = 0;
    for (int i = 0; i < n; ++i) {
        if (inDegree[i] == 0) sorted[index++] = i;
    }

    while (index < n) {
        int node = sorted[index - 1];
        for (int i = 0; i < m; ++i) {
            if (edges[i][0] == node) {
                int nextNode = edges[i][1];
                inDegree[nextNode]--;
                if (inDegree[nextNode] == 0) {
                    sorted[index++] = nextNode;
                }
            }
        }
    }
    free(inDegree);
}

// å¨æè§åæ±è§£æå¤§é¢è²å¼
int largestColorValue(int *colors, int **edges, int n, int m) {
    if (hasCycle(colors, edges, n, m)) return -1;

    int *dp = (int *)calloc(n, sizeof(int));
    int *sorted = (int *)malloc(n * sizeof(int));
    topologicalSort(edges, n, m, sorted);

    for (int i = 0; i < n; ++i) {
        int node = sorted[i];
        dp[node] = 1; // è³å°åå«èªèº«
        for (int j = 0; j < m; ++j) {
            if (edges[j][0] == node) {
                int nextNode = edges[j][1];
                if (colors[node] == colors[nextNode]) {
                    dp[nextNode] = max(dp[nextNode], dp[node] + 1);
                }
            }
        }
    }

    int maxColorValue = 0;
    for (int i = 0; i < n; ++i) {
        maxColorValue = max(maxColorValue, dp[i]);
    }

    free(dp);
    free(sorted);
    return maxColorValue;
}

// è¾å©å½æ°ï¼æ±æå¤§å¼
int max(int a, int b) {
    return a > b ? a : b;
}

#include <stdio.h>
#include <string.h>
#include <stdbool.h>

int countGoodSubstrings(char *s) {
    int count = 0;
    int len = strlen(s);
    bool unique[256] = {false}; // åè®¾å­ç¬¦éå¤§å°ä¸º256

    for (int i = 0; i < len - 2; ++i) {
        // éç½®uniqueæ°ç»
        memset(unique, false, sizeof(unique));
        // æ£æ¥ä»ç´¢å¼iå¼å§çä¸ä¸ªå­ç¬¦æ¯å¦å¯ä¸
        for (int j = i; j < i + 3; ++j) {
            if (unique[s[j]]) {
                break; // å¦æå­ç¬¦éå¤ï¼åéç½®è®¡æ°å¨å¹¶è·³åºå¾ªç¯
                count = 0;
            }
            unique[s[j]] = true;
        }
        // å¦ææ²¡æéå¤å­ç¬¦ï¼åå¢å è®¡æ°å¨
        if (i + 2 < len && !unique[s[i + 2]]) {
            count++;
        }
    }
    return count;
}

int main() {
    char s[] = "aababcabc";
    printf("Good substrings count: %d\n", countGoodSubstrings(s));
    return 0;
}
int minSwaps(char* s) {
    int n = strlen(s);
    int zeroFirst = 0, oneFirst = 0;
    for (int i = 0; i < n; i += 2) {
        if (s[i] == '0') zeroFirst++;
    }
    for (int i = 1; i < n; i += 2) {
        if (s[i] == '1') oneFirst++;
    }
    int swaps = 0;
    char expected = '0';
    for (int i = 0; i < n; i++) {
        if (s[i] != expected) {
            swaps++;
        }
        expected = (expected == '0') ? '1' : '0';
    }
    return swaps > (n / 2) ? (n / 2) - (zeroFirst < oneFirst ? zeroFirst : oneFirst) : swaps;
}
int rearrangeSticks(int n, int k) {
    if (k > n) return 0;
    int MOD = 1e9 + 7;
    int dp[n + 1][k + 1];
    memset(dp, 0, sizeof(dp));
    dp[1][1] = 1;

    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= k; j++) {
            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD;
            if (j > 0) {
                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * (i - j)) % MOD;
            }
        }
    }

    return dp[n][k];
}
bool checkZeroOnes(char *s) {
    int maxOnes = 0, maxZeros = 0, curOnes = 0, curZeros = 0;
    char lastChar = s[0]; // åå§å­ç¬¦

    for (int i = 0; s[i] != '\0'; i++) {
        if (s[i] == '1' && lastChar == '1') {
            curOnes++;
        } else if (s[i] == '1') {
            curOnes = 1;
            curZeros = 0; // éç½®0çè®¡æ°
        } else if (s[i] == '0' && lastChar == '0') {
            curZeros++;
        } else if (s[i] == '0') {
            curZeros = 1;
            curOnes = 0; // éç½®1çè®¡æ°
        }
        
        maxOnes = maxOnes < curOnes ? curOnes : maxOnes; // æ´æ°æé¿1çè®¡æ°
        maxZeros = maxZeros < curZeros ? curZeros : maxZeros; // æ´æ°æé¿0çè®¡æ°
        
        lastChar = s[i]; // æ´æ°lastCharä¸ºå½åå­ç¬¦
    }
    
    return maxOnes > maxZeros; // å¦ææé¿ç1çåºåæ¯0çåºåé¿ï¼åè¿åtrue
}
#include <stdio.h>

int minSpeedToArriveOnTime(int dist[], int n, double hour) {
    // ä½¿ç¨äºåæ¥æ¾æ¥ç¡®å®æå°æ¶é
    double left = 1.0, right = 1e7; // åççéåº¦èå´
    while (left < right) {
        double mid = left + (right - left) / 2.0;
        // è®¡ç®å½åéåº¦ä¸æéçæ»æ¶é´
        double totalTime = 0.0;
        for (int i = 0; i < n; ++i) {
            totalTime += (double)dist[i] / mid; // æ¯è¶åè½¦æéæ¶é´
            if (i < n - 1) { // å¦æä¸æ¯æåä¸è¶åè½¦ï¼éè¦ç­å¾å°æ´ç¹
                totalTime += ((double)totalTime - (int)totalTime) > 0 ? 1.0 - ((double)totalTime - (int)totalTime) : 0.0;
            }
        }
        // å¦æå½åéåº¦ä¸æéçæ¶é´å°äºç­äºç»å®æ¶é´ï¼åå°è¯åå°éåº¦
        if (totalTime <= hour) {
            right = mid;
        } else {
            left = mid + 1.0;
        }
    }
    // æ£æ¥æ¯å¦æ¾å°å¯è¡çæ¶éï¼å¦ææ²¡æï¼åè¿å-1
    return (int)left;
}

int main() {
    int dist[] = {1, 3, 2};
    double hour = 3.0;
    printf("Minimum Speed: %d\n", minSpeedToArriveOnTime(dist, sizeof(dist) / sizeof(dist[0]), hour));
    return 0;
}
bool canReach(char *s, int minJump, int maxJump) {
    int n = strlen(s);
    bool visited[n];  // è®°å½å·²ç»è®¿é®è¿çç´¢å¼
    memset(visited, 0, sizeof(visited));
    visited[0] = true;  // åå§ä½ç½®å·²ç»è®¿é®

    // éåç¨äºå­å¨å¯ä»¥è·³è·çä½ç½®
    int queue[n];
    int front = 0, rear = 0;
    queue[rear++] = 0;  // å¥éåå§ä½ç½®

    while (front < rear) {
        int current = queue[front++];  // ååºéååç«¯çåç´ 
        for (int jump = minJump; jump <= maxJump && current + jump < n; ++jump) {
            int next = current + jump;
            if (s[next] == '0' && !visited[next]) {
                visited[next] = true;
                queue[rear++] = next;  // å°ä¸ä¸ä¸ªå¯ä»¥è·³çä½ç½®å¥é
            }
        }
        // å¦æå·²ç»è®¿é®äºæåä¸ä¸ªä½ç½®ï¼ç´æ¥è¿åtrue
        if (visited[n - 1]) return true;
    }

    return false;  // å¦æéåä¸ºç©ºï¼è¯´ææ æ³å°è¾¾æåä¸ä¸ªä½ç½®
}
int* distinctNumbers(int* nums, int numsSize, int k, int* returnSize) {
    int* result = malloc(sizeof(int) * numsSize); // ä¸ºç»ææ°ç»åéåå­
    if (!result) return NULL; // å¦æåå­åéå¤±è´¥ï¼åè¿åNULL

    // åå§åçªå£çå·¦å³è¾¹ç
    int left = 0, right = 0;
    // åå§ååå¸è¡¨ï¼è¿éä½¿ç¨ç®åçæ°ç»æ¨¡æåå¸è¡¨
    int hashTable[101] = {0}; // åè®¾æ°å­èå´å¨0å°100ä»¥å
    int count = 0; // è®°å½çªå£ä¸­ä¸åæ°å­çæ°é

    while (right < numsSize) {
        // å°æ°è¿å¥çªå£çæ°å­å å¥åå¸è¡¨ï¼å¹¶æ´æ°ç§ç±»æ°
        hashTable[nums[right]]++;
        if (hashTable[nums[right]] == 1) count++; // å¦ææ¯æ°æ°å­ï¼ç§ç±»æ°å ä¸

        // å½çªå£å¤§å°è¾¾å°kæ¶ï¼å¼å§å¤çç»æ
        if (right - left + 1 == k) {
            result[left] = count; // å°å½åçªå£çç§ç±»æ°å å¥ç»ææ°ç»
            // ç§»å¨çªå£ï¼å é¤å·¦è¾¹ççæ°å­
            hashTable[nums[left]]--;
            if (hashTable[nums[left]] == 0) count--; // å¦ææ°å­ç§ç±»æ°åè³0ï¼ç§ç±»æ°åä¸
            left++; // ç§»å¨å·¦è¾¹ç
        }
        right++; // ç§»å¨å³è¾¹ç
    }

    *returnSize = numsSize - k + 1; // è®¾ç½®è¿åæ°ç»çå¤§å°
    return result; // è¿åç»ææ°ç»
}
char* convertDate(char* date) {
    char month[5], day[5], year[5];
    sscanf(date, "%[^-]-%[^-]-%s", year, month, day); // ä½¿ç¨ sscanf å½æ°åå²æ¥æ
    sprintf(date, "%s-%s-%s", month, day, year); // éæ°ç»åå­ç¬¦ä¸²
    return date;
}
int findStudentToReplaceChalk(int chalk[], int k, int n) {
    int total = 0;
    for (int i = 0; i < n; i++) {
        total += chalk[i];
    }
    int i = 0;
    while (k >= 0 && i < n) {
        if (k < chalk[i]) {
            return i;
        }
        k -= chalk[i];
        i = (i + 1) % n; // å¾ªç¯å°æ°ç»çå¼å§
    }
    return -1; // å¦ææ²¡æå­¦çéè¦è¡¥åç²ç¬ï¼è¿å-1
}
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// å½æ°ç¨äºå°å­ç¬¦ä¸²è½¬æ¢ä¸ºæ°å¼
int wordToValue(char *word) {
    int value = 0;
    for (int i = 0; word[i] != '\0'; i++) {
        value = value * 10 + (word[i] - 'a');
    }
    return value;
}

// å¤æ­ä¸¤ä¸ªåè¯çæ°å¼ä¹åæ¯å¦ç­äºç®æ åè¯çæ°å¼
bool isSumEqual(char *firstWord, char *secondWord, char *targetWord) {
    int sum = wordToValue(firstWord) + wordToValue(secondWord);
    return sum == wordToValue(targetWord);
}

int main() {
    // ç¤ºä¾æµè¯
    char *firstWord = "acb";
    char *secondWord = "cba";
    char *targetWord = "cdb";
    
    if (isSumEqual(firstWord, secondWord, targetWord)) {
        printf("true\n");
    } else {
        printf("false\n");
    }
    return 0;
}
char* maxValueAfterInsertion(char* n, int x) {
    int len = strlen(n);
    char maxEnd[11]; // æå¤§é¿åº¦ä¸º10 + 1ï¼ç»æç¬¦ï¼
    int maxEndLen = 0;
    int isNegative = (n[0] == '-');
    
    // å¦ææ¯è´æ°ï¼åè·³è¿è´å·
    int start = isNegative ? 1 : 0;

    for (int i = start; i <= len; ++i) {
        char temp[11];
        int tempLen = 0;
        
        // æé ä¸åå«å½åä½ç½®çå­ç¬¦ä¸²
        for (int j = 0; j < i; ++j) {
            temp[tempLen++] = n[j];
        }
        
        // æå¥æ°å­x
        temp[tempLen++] = 'x';
        
        // æé å©ä½çå­ç¬¦ä¸²
        for (int j = i; j < len; ++j) {
            temp[tempLen++] = n[j];
        }
        temp[tempLen] = '\0'; // æ·»å å­ç¬¦ä¸²ç»æç¬¦
        
        // å¦æå½åæ¯è´æ°ï¼éè¦å¨ç¬¬äºä½ä¹åæå¥x
        if (isNegative) {
            memmove(&temp[2], &temp[1], tempLen - 1);
            temp[1] = 'x';
        }
        
        // æ¯è¾å¹¶æ´æ°æå¤§å­ç¬¦ä¸²
        if (maxEndLen < tempLen - 1 || strcmp(&maxEnd[isNegative], &temp[isNegative]) < 0) {
            strncpy(maxEnd, temp, sizeof(maxEnd));
            maxEndLen = tempLen - 1;
        }
    }
    
    // æ¿æ¢ 'x' ä¸ºå®éçæ°å­ x
    maxEnd[maxEndLen - (isNegative ? 2 : 1)] = '0' + x;
    
    return strdup(maxEnd); // ä½¿ç¨ strdup å¤å¶å­ç¬¦ä¸²ï¼å ä¸ºåå­ç¬¦ä¸²å¯è½ä¼è¢«ä¿®æ¹
}
int reductionOperations(int* nums, int numsSize) {
    int maxValue = 0, secondMaxValue = 0, count = 0;
    for (int i = 0; i < numsSize; ++i) {
        if (nums[i] > maxValue) {
            secondMaxValue = maxValue;
            maxValue = nums[i];
        } else if (nums[i] > secondMaxValue && nums[i] < maxValue) {
            secondMaxValue = nums[i];
        }
    }
    for (int i = 0; i < numsSize; ++i) {
        if (nums[i] == maxValue) {
            count += maxValue - secondMaxValue;
            nums[i] = secondMaxValue;
        }
    }
    return count;
}
bool canBeIncreasing(int* nums, int numsSize) {
    // é¦åæ£æ¥æ°ç»æ¯å¦å·²ç»æ¯ä¸¥æ ¼éå¢ç
    for (int i = 1; i < numsSize; ++i) {
        if (nums[i - 1] >= nums[i]) {
            break;
        }
    }
    
    // å¦ææ²¡ææ¾å°ä¸æ¯ä¸¥æ ¼éå¢çå°æ¹ï¼è¯´ææ°ç»å·²ç»æ¯ä¸¥æ ¼éå¢ç
    if (numsSize - 1 > 0 && nums[numsSize - 2] < nums[numsSize - 1]) {
        return true;
    }
    
    // å¯»æ¾ééå¢çå°æ¹
    for (int i = 0; i < numsSize - 1; ++i) {
        if (nums[i] >= nums[i + 1]) {
            // å°è¯å é¤ nums[i]
            if (i == 0 || nums[i - 1] < nums[i + 1]) {
                return true;
            }
            // å°è¯å é¤ nums[i + 1]
            if (i == numsSize - 2 || nums[i] < nums[i + 2]) {
                return true;
            }
            // å¦æä¸¤ä¸ªæ¡ä»¶é½ä¸æ»¡è¶³ï¼è¯´ææ æ³éè¿å é¤ä¸ä¸ªåç´ ä½¿æ°ç»ä¸¥æ ¼éå¢
            return false;
        }
    }
    
    // å¦ææ²¡ææ¾å°ééå¢çå°æ¹ï¼è¯´ææ°ç»å·²ç»æ¯ä¸¥æ ¼éå¢ç
    return true;
}
char* removeOccurrences(char* s, char* part) {
    int lenS = strlen(s);
    int lenPart = strlen(part);
    char *temp = (char *)malloc(sizeof(char) * (lenS + 1));
    int j = 0;

    for (int i = 0; i <= lenS; ++i) {
        // å¦ææ¾å°äºpartçå­ä¸²
        if (i + lenPart <= lenS && strncmp(s + i, part, lenPart) == 0) {
            i += lenPart - 1; // è·³è¿å·²å¹éçpartå­ç¬¦ä¸²
        } else {
            if (j < lenS) {
                temp[j++] = s[i]; // å°å½åå­ç¬¦å¤å¶å°tempï¼å¹¶è·³è¿part
            }
        }
    }

    temp[j] = '\0'; // ç¡®ä¿å­ç¬¦ä¸²ä»¥ç©ºå­ç¬¦ç»å°¾
    char *result = (char *)malloc(sizeof(char) * (j + 1));
    strcpy(result, temp);
    free(temp);
    return result;
}
int maxAlternatingSum(int* nums, int numsSize) {
    if (numsSize == 0) return 0;
    
    int even = nums[0], odd = 0;
    for (int i = 1; i < numsSize; ++i) {
        if (i % 2 == 0) {
            // å¯¹äºå¶æ°ä½ç½®ï¼å¯ä»¥éæ©ä¸åå«åä¸ä¸ªåç´ 
            even = nums[i] + max(even, odd);
        } else {
            // å¯¹äºå¥æ°ä½ç½®ï¼å¯ä»¥éæ©ä¸åå«åä¸ä¸ªåç´ 
            odd = nums[i] - max(even, odd);
        }
    }
    
    return max(even, odd);
}
// å½æ°ç¨äºå¤æ­æ¯å¦å¯ä»¥éæ°åéå­ç¬¦
// 定义结构体来存储区间的起始和结束
typedef struct {
    int start;
    int end;
} Range;

// 比较函数，用于排序
int compare(const void *a, const void *b) {
    Range *rangeA = (Range *)a;
    Range *rangeB = (Range *)b;
    return rangeA->start - rangeB->start;
}

// 函数来找出最大未覆盖区间
void findMaximalUncoveredRanges(Range *ranges, int size, int n) {
    if (size == 0) {
        printf("0 0\n");
        return;
    }

    // 首先按照区间的起始位置排序
    qsort(ranges, size, sizeof(Range), compare);

    // 初始化变量
    int maxRangeEnd = -1;
    int prevEnd = ranges[0].end;

    // 遍历区间，找出最大的未覆盖区间
    for (int i = 1; i < size; i++) {
        if (ranges[i].start > prevEnd) {
            if (maxRangeEnd < 0 || maxRangeEnd - ranges[i].start < prevEnd - ranges[i].start) {
                maxRangeEnd = ranges[i].start - 1;
            }
            prevEnd = ranges[i].end;
        }
    }

    // 检查最后一个区间之后是否还有未覆盖的区间
    if (maxRangeEnd < n && prevEnd < n) {
        maxRangeEnd = n - 1;
    }

    printf("%d %d\n", maxRangeEnd - (maxRangeEnd > 0), maxRangeEnd);
}

int main() {
    // 示例输入
    Range ranges[] = {{3, 5}, {7, 8}};
    int size = sizeof(ranges) / sizeof(ranges[0]);
    int n = 10;

    // 调用函数
    findMaximalUncoveredRanges(ranges, size, n);

    return 0;
}
int isLeapYear(int year) {
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}

// 获取月份的最大天数
int getMaxDay(int year, int month) {
    switch (month) {
        case 1: case 3: case 5: case 7: case 8: case 10: case 12:
            return 31;
        case 4: case 6: case 9: case 11:
            return 30;
        case 2:
            return isLeapYear(year) ? 29 : 28;
        default:
            return 0;
    }
}

// 计算下一天的日期
void nextDay(char *date) {
    int year, month, day;
    sscanf(date, "%d-%d-%d", &year, &month, &day); // 解析日期

    int maxDay = getMaxDay(year, month); // 获取该月的最大天数
    if (day < maxDay) { // 如果没有超出本月天数
        day++;
    } else {
        day = 1;
        if (month < 12) {
            month++;
        } else {
            month = 1;
            year++;
        }
    }

    // 格式化输出下一天的日期
    printf("%04d-%02d-%02d\n", year, month, day);
}

int main() {
    char date[] = "2014-06-30"; // 测试日期
    nextDay(date); // 计算下一天
    return 0;
}
#include <stdlib.h>

// 方向数组，表示骑士的八个可能移动方向
int moves[8][2] = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}};

// 检查当前位置是否有效
int isValid(int x, int y, int m, int n, int *visited) {
    return x >= 0 && y >= 0 && x < m && y < n && !visited[x * n + y];
}

// 骑士巡逻的递归函数
int *knightTour(int m, int n, int r, int c, int *visited, int *returnSize) {
    int *path = malloc(m * n * sizeof(int)); // 存储路径的数组
    if (!path) return NULL;
    int pathIndex = 0, i, tx, ty;

    // 从起点开始递归搜索
    visited[r * n + c] = 1;
    path[pathIndex++] = r * n + c;

    for (int count = 1; count < m * n; count++) {
        for (i = 0; i < 8; i++) {
            tx = r + moves[i][0];
            ty = c + moves[i][1];
            if (isValid(tx, ty, m, n, visited)) {
                visited[tx * n + ty] = 1;
                path[pathIndex++] = tx * n + ty;
                if (knightTour(m, n, tx, ty, visited, returnSize) != NULL) {
                    return path;
                }
                visited[tx * n + ty] = 0; // 回溯
            }
        }
        if (i == 7) { // 如果所有方向都无效，回溯
            break;
        }
    }
    free(path); // 当前起点无法完成巡逻，释放内存
    return NULL;
}

// 封装函数，初始化visited数组并调用knightTour
int *dfs(int m, int n, int r, int c, int *returnSize) {
    int *visited = (int *)calloc(m * n, sizeof(int)); // 初始化访问数组
    if (!visited) return NULL;
    int *result = knightTour(m, n, r, c, visited, returnSize);
    if (!result) *returnSize = 0;
    free(visited);
    return result;
}

// 用于输出结果的辅助函数
void printResult(int *path, int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", path[i]);
    }
    printf("\n");
}
// Definition for a Node.
typedef struct Node {
    int val;
    struct Node *next;
} Node;

Node* splitList(Node* head, int val) {
    Node *dummy1 = malloc(sizeof(Node)); // 创建一个哑节点，用于存放所有小于val的节点
    Node *dummy2 = malloc(sizeof(Node)); // 创建另一个哑节点，用于存放所有大于等于val的节点
    Node *tail1 = dummy1, *tail2 = dummy2;
    while (head) {
        if (head->val < val) {
            tail1->next = head;
            tail1 = tail1->next;
        } else {
            tail2->next = head;
            tail2 = tail2->next;
        }
        head = head->next;
    }
    tail1->next = dummy2->next; // 连接两个哑节点的列表
    tail2->next = NULL; // 循环链表的尾部设置为NULL
    dummy1->next = dummy2->next; // 将哑节点1的next指向哑节点2的next，形成循环链表
    return dummy1->next; // 返回新的循环链表的头节点
}
#include <stdio.h>
#include <stdlib.h>

// 定义一个结构体来模拟对象
typedef struct {
    // 使用动态数组存储键值对
    char **keys;
    int *values;
    int size;
} Object;

// 初始化对象
Object createObject(int size) {
    Object obj;
    obj.keys = (char **)malloc(size * sizeof(char *));
    obj.values = (int *)malloc(size * sizeof(int));
    obj.size = size;
    return obj;
}

// 添加属性到对象
void addObjectProperty(Object *obj, char *key, int value) {
    if (obj->size > 0) {
        obj->keys[--obj->size] = key;  // 使用引用，简化内存管理
        obj->values[obj->size] = value;
    }
}

int main() {
    // 示例输入
    char *keys[] = {"a", "b", "c"};
    int values[] = {1, 2, 3};
    int n = sizeof(keys) / sizeof(keys[0]);

    // 创建对象
    Object obj = createObject(n);

    // 填充对象属性
    for (int i = 0; i < n; ++i) {
        addObjectProperty(&obj, keys[i], values[i]);
    }

    // 输出结果
    for (int i = 0; i < obj.size; ++i) {
        printf("%s: %d\n", obj.keys[i], obj.values[i]);
    }

    // 释放内存
    for (int i = 0; i < obj.size; ++i) {
        free(obj.keys[i]);
    }
    free(obj.keys);
    free(obj.values);

    return 0;
}
void findTwoSum(int* nums, int numsSize, int target, int* indices) {
    // 使用一个哈希表存储已经遍历过的数字及其索引
    int *hashTable = (int *)malloc(sizeof(int) * 1010); // 假设索引不会超过1000
    for (int i = 0; i < numsSize; ++i) {
        int complement = target - nums[i];
        if (hashTable[complement] != -1) {
            indices[0] = hashTable[complement];
            indices[1] = i;
            return;
        }
        hashTable[nums[i]] = i;
    }
}
int maxHouses(int* street, int streetSize, int k) {
    int maxCount = 0;
    int sum = 0;
    int left = 0;
    
    for (int right = 0; right < streetSize; ++right) {
        sum += street[right];  // 将右侧房屋的人数加到窗口的总和中
        
        while (sum > k) {
            sum -= street[left];  // 如果总和超过k，则从左侧减去人数
            left++;  // 移动左侧窗口
        }
        
        maxCount = max(maxCount, right - left + 1);  // 更新最大房屋数量
    }
    
    return maxCount;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// 用于存储单词和出现次数的结构体
typedef struct {
    char *word;
    int count;
} WordCount;

// 比较两个WordCount结构体的函数，用于排序
int compare(const void *a, const void *b) {
    return strcmp(((WordCount *)a)->word, ((WordCount *)b)->word);
}

// 插入或更新单词计数
void insertOrUpdate(WordCount *wordCounts, int *size, char *word) {
    for (int i = 0; i < *size; i++) {
        if (strcmp(wordCounts[i].word, word) == 0) {
            wordCounts[i].count++;
            return;
        }
    }
    // 如果单词不在列表中，添加新单词
    wordCounts[*size].word = strdup(word); // 复制单词字符串
    wordCounts[*size].count = 1;
    (*size)++;
}

// 读取文件并统计词频
void countWordOccurrences(const char *filename, WordCount *wordCounts, int *size) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        perror("Error opening file");
        return;
    }

    char word[1024];
    while (fscanf(file, "%s", word) == 1) {
        // 预处理单词
        for (int i = 0; word[i]; i++) {
            word[i] = tolower(word[i]);
        }
        insertOrUpdate(wordCounts, size, word);
    }
    fclose(file);
}

int main() {
    const char *filename = "hello.txt"; // 替换为实际文件名
    WordCount wordCounts[1000]; // 假设最多有1000个不同的单词
    int size = 0;

    countWordOccurrences(filename, wordCounts, &size);

    // 根据单词出现次数排序
    qsort(wordCounts, size, sizeof(WordCount), compare);

    // 打印结果
    for (int i = 0; i < size; i++) {
        printf("%s: %d\n", wordCounts[i].word, wordCounts[i].count);
        free(wordCounts[i].word); // 释放分配的内存
    }

    return 0;
}
int countSubstringsWithoutRepeatingCharacters(char *s) {
    int len = strlen(s);
    int count = 0;
    int left = 0;
    int right = 0;
    int lastOccurrence[256] = {-1}; // 存储字符最后出现的位置，假设ASCII字符集

    while (right < len) {
        // 移动右指针直到遇到重复字符
        while (right < len && lastOccurrence[(unsigned char)s[right]] == -1) {
            lastOccurrence[(unsigned char)s[right]] = right;
            right++;
        }
        
        // 当右指针遇到重复字符时，移动左指针
        while (left < len && lastOccurrence[(unsigned char)s[left]] != left) {
            lastOccurrence[(unsigned char)s[left]] = -1; // 重置字符出现位置
            left++;
        }
        
        // 更新结果，从left到right-1都是不重复的子串
        count += right - left;
    }

    return count;
}
// 函数用于计算表达式的值
int calculateExpression(const char* fn, int* args, int argsSize) {
    // 解析函数表达式，这里简化处理，假设表达式格式已知且正确
    // 例如："(a, b, c) => b + a - c"，我们直接按照顺序获取参数b, a, c
    int values[3] = {0}; // 假设最多三个参数
    for (int i = 0; i < argsSize; ++i) {
        // 根据参数索引设置值，这里简化处理，假设args索引与表达式参数索引一致
        values[i] = args[i];
    }
    // 计算表达式结果
    int result = values[1] + values[0] - values[2]; // 根据示例"b + a - c"
    return result;
}

int partial(int* args, int argsSize, const char* restArgs) {
    // 忽略restArgs，因为我们只关注args数组中的值
    return calculateExpression("(a, b, c) => b + a - c", args, argsSize);
}
// 用于存储反转后对象的键值对
typedef struct {
    char *key;
    char *value;
} KeyValuePair;

// 函数用于反转对象
char* invertObject(char* obj) {
    // 分割字符串，获取键值对
    char *temp = strdup(obj); // 使用strdup来复制obj，避免修改原始字符串
    char *key;
    char *value;
    char *start = temp;
    KeyValuePair *kvs = NULL;
    int count = 0;
    
    while ((key = strsep(&start, ","))) {
        value = strchr(key, ':');
        if (value) {
            *value = '\0'; // 将冒号替换为字符串结束符
            value++; // 移动到值的开始位置
            kvs = realloc(kvs, (count + 1) * sizeof(KeyValuePair)); // 重新分配内存
            kvs[count].key = strdup(value); // 复制值
            kvs[count].value = strdup(key); // 复制键
            count++;
        }
    }
    
    // 构建反转后的对象字符串
    char *result = malloc(1024 * (count + 1)); // 假设结果不会超过这个大小
    *result = '\0'; // 初始化为空字符串
    for (int i = 0; i < count; i++) {
        char pair[256];
        sprintf(pair, "%s:%s,", kvs[i].key, kvs[i].value);
        strcat(result, pair);
    }
    if (strlen(result) > 0) {
        result[strlen(result) - 1] = '\0'; // 移除最后一个逗号
    }
    
    // 释放分配的内存
    for (int i = 0; i < count; i++) {
        free(kvs[i].key);
        free(kvs[i].value);
    }
    free(kvs);
    free(temp);
    
    return result;
}

int main() {
    char obj[] = "a:1,b:2,c:3,d:4";
    char *inverted = invertObject(obj);
    printf("Inverted Object: %s\n", inverted);
    free(inverted); // 释放反转后的对象字符串
    return 0;
}
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 计算特殊二叉树的高度
int heightOfTree(TreeNode* root) {
    if (root == NULL) {
        return 0; // 如果节点为空，高度为0
    }
    if (root->left == NULL && root->right == NULL) {
        return 1; // 如果是叶子节点，高度为1
    }
    int leftHeight = heightOfTree(root->left); // 计算左子树的高度
    int rightHeight = heightOfTree(root->right); // 计算右子树的高度
    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1; // 返回左右子树高度的最大值加1
}
int numberOfCategories(int n, int* categoryHandler) {
    // 创建一个足够大的数组作为哈希表
    int hashTable[101] = {0}; // 假设类别数不会超过100
    int uniqueCategories = 0;
    
    // 遍历数组，使用哈希表记录类别出现次数
    for (int i = 0; i < n; i++) {
        if (hashTable[categoryHandler[i]] == 0) {
            // 如果类别是第一次出现，增加不同类别的数量
            uniqueCategories++;
        }
        // 将类别出现次数加1
        hashTable[categoryHandler[i]]++;
    }
    
    // 返回不同类别的数量
    return uniqueCategories;
}
#include <stdio.h>
#include <stdbool.h>

// 函数用于检查一个数字是否是幸运数字
bool isLucky(int num) {
    while (num > 0) {
        if (num % 10 == 4 || num % 10 == 7) {
            return false;
        }
        num /= 10;
    }
    return true;
}

// 函数用于找出第K个幸运数字
int findKthLuckyNumber(int k) {
    int count = 0; // 已找到的幸运数字数量
    int num = 1;   // 当前检查的数字

    // 循环直到找到第K个幸运数字
    while (count < k) {
        if (isLucky(num)) {
            count++;
            if (count == k) {
                return num;
            }
        }
        num++;
    }

    return -1; // 如果没有找到，返回-1
}

int main() {
    int k = 10; // 假设我们要找第10个幸运数字
    printf("The %d-th lucky number is: %d\n", k, findKthLuckyNumber(k));
    return 0;
}
#include <stdio.h>
#include <string.h>
#define MAX_ROW 100
#define MAX_COL 100

int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

int minimumTimeToReachDestination(char land[MAX_ROW][MAX_COL], int rows, int cols) {
    // 检查输入参数
    if (rows <= 0 || cols <= 0) return -1;

    // 定义访问状态数组，初始化为0
    int visited[MAX_ROW][MAX_COL] = {0};
    int queue[MAX_ROW * MAX_COL][2]; // 存储节点和步数
    int front = 0, rear = 0; // 队列的前后指针

    // 寻找起点'S'，初始化队列
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (land[i][j] == 'S') {
                queue[rear][0] = i;
                queue[rear][1] = j;
                rear++;
                visited[i][j] = 1; // 标记为已访问
                break;
            }
        }
    }

    // BFS核心逻辑
    while (front < rear) {
        int x = queue[front][0], y = queue[front][1];
        front++;

        for (int i = 0; i < 4; ++i) {
            int nx = x + directions[i][0], ny = y + directions[i][1];
            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols &&
                !visited[nx][ny] && land[nx][ny] != 'D') {
                if (land[nx][ny] == 'E') {
                    return (visited[nx][ny] = 1) + 1; // 到达终点
                }
                queue[rear][0] = nx;
                queue[rear][1] = ny;
                rear++;
                visited[nx][ny] = 1; // 标记为已访问
            }
        }
    }

    return -1; // 无法到达终点
}
// 定义网格大小
#define N 3

// 检查是否越界
int is_valid(int x, int y) {
    return x >= 0 && x < N && y >= 0 && y < N;
}

// 移动石头的函数
void move_stone(int grid[N][N], int x, int y, int *count) {
    // 寻找可移动的相邻格子
    for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
            if (i == 0 && j == 0) continue; // 跳过自身位置
            int new_x = x + i, new_y = y + j;
            if (is_valid(new_x, new_y) && grid[new_x][new_y] == 0) {
                grid[new_x][new_y] = 1; // 移动石头
                (*count)++; // 增加移动次数
                move_stone(grid, new_x, new_y, count); // 递归移动
                grid[new_x][new_y] = 0; // 回溯
                (*count)--; // 减少移动次数
            }
        }
    }
}

// 计算最少移动次数的函数
int minMovesToSpreadStones(int grid[N][N]) {
    int count = 0; // 初始化移动次数
    memset(grid, 0, sizeof(grid)); // 初始化网格
    int stones = 0; // 石头总数
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (grid[i][j] > 1) {
                stones += grid[i][j] - 1;
                grid[i][j] = 1; // 每个格子只能有一个石头
            }
        }
    }
    move_stone(grid, 0, 0, &count); // 从(0,0)开始移动
    return count + stones; // 返回总移动次数
}

int main() {
    int grid[N][N] = {{1,1,0},{1,1,1},{1,2,1}};
    printf("Minimum moves: %d\n", minMovesToSpreadStones(grid));
    return 0;
}
#include <stdio.h>

int minOperations(int *nums, int numsSize) {
    int maxVal = 0;
    for (int i = 0; i < numsSize; ++i) {
        maxVal = maxVal > nums[i] ? maxVal : nums[i];
    }
    
    // 存储每个数字出现的次数
    int *count = (int *)malloc((maxVal + 1) * sizeof(int));
    for (int i = 0; i <= maxVal; ++i) {
        count[i] = 0;
    }
    for (int i = 0; i < numsSize; ++i) {
        count[nums[i]]++;
    }
    
    int operations = 0;
    for (int i = 1; i <= maxVal; ++i) {
        // 贪心地使用第二种操作，然后使用第一种操作处理剩余的元素
        operations += count[i] / 3;
        if (count[i] % 3 > 0) {
            operations++;
        }
    }
    
    free(count);
    return operations;
}

int main() {
    int nums[] = {2, 3, 3, 2, 2, 4, 2, 3, 4};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    printf("Minimum operations: %d\n", minOperations(nums, numsSize));
    return 0;
}
#include <limits.h>

int maxAlloys(int n, int k, int budget, int composition[][n], int stock[], int cost[]) {
    int maxAlloy = 0;
    // 计算制造一份合金需要的金属总量
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < k; ++j) {
            maxAlloy += composition[j][i] * cost[i];
        }
    }
    // 使用二分查找确定最大合金数
    int left = 0, right = maxAlloy, mid, result = 0;
    while (left <= right) {
        mid = left + (right - left) / 2;
        if (canMakeAlloys(k, n, budget, composition, stock, mid)) {
            result = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}

// 检查是否可以在mid的花费下制造合金
int canMakeAlloys(int k, int n, int budget, int composition[][n], int stock[], int mid) {
    int need = 0;
    for (int i = 0; i < k; ++i) {
        int machineNeed = 0;
        for (int j = 0; j < n; ++j) {
            machineNeed += (composition[i][j] - stock[j]) * cost[j];
        }
        if (machineNeed > mid) return 0; // 如果一种金属的需要量就超过了mid，则直接返回0
        need += machineNeed;
    }
    return need <= budget;
}

int main() {
    int n = 3, k = 2, budget = 15;
    int composition[2][3] = {{1,1,1},{1,1,10}};
    int stock[3] = {0,0,0};
    int cost[3] = {1,2,3};
    printf("Maximum number of alloys: %d\n", maxAlloys(n, k, budget, composition, stock, cost));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

// Define the structure for the result pair
typedef struct {
    int index1;
    int index2;
} ResultPair;

ResultPair twoSum(int* nums, int numsSize, int target) {
    // Create a hash table to store the numbers and their indices
    int *hashTable = (int *)malloc(sizeof(int) * (target + 1));
    for (int i = 0; i < target + 1; ++i) {
        hashTable[i] = -1; // Initialize with -1 indicating not found
    }

    for (int i = 0; i < numsSize; ++i) {
        int complement = target - nums[i];
        if (hashTable[complement] != -1) {
            // If the complement is found, return the indices
            return (ResultPair){hashTable[complement], i};
        }
        // Store the index of the current number in the hash table
        hashTable[nums[i]] = i;
    }

    // In case no pair is found (should not happen as per problem statement)
    ResultPair errorPair = {-1, -1};
    return errorPair;
}

int main() {
    int nums[] = {2, 7, 11, 15};
    int target = 9;
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    ResultPair result = twoSum(nums, numsSize, target);
    printf("Index1: %d, Index2: %d\n", result.index1, result.index2);
    return 0;
}
#include <stdio.h>

// 函数用于返回和为目标值的最长子序列的长度
int lengthOfLongestSubsequence(int *nums, int numsSize, int target) {
    // dp数组，dp[i]表示到当前元素结束，和为i的子序列的最大长度
    int dp[target + 1] = {0};
    int maxLength = 0;

    // 遍历数组
    for (int i = 0; i < numsSize; i++) {
        // 从target往回退，找到小于等于nums[i]的最大的和
        for (int j = target; j >= nums[i]; j--) {
            // 如果dp[j - nums[i]]存在，则更新dp[j]的值
            if (dp[j - nums[i]] != -1) {
                dp[j] = (dp[j] == -1 || dp[j - nums[i]] + 1 > dp[j]) ? dp[j - nums[i]] + 1 : dp[j];
                maxLength = (maxLength > dp[j]) ? maxLength : dp[j];
            }
        }
        // 将dp[target - nums[i]]置为-1，避免使用当前元素多次
        dp[target - nums[i]] = -1;
    }
    return maxLength;
}

int main() {
    int nums[] = {1, 2, 3, 4, 5};
    int target = 9;
    int size = sizeof(nums) / sizeof(nums[0]);
    printf("The length of the longest subsequence is: %d\n", lengthOfLongestSubsequence(nums, size, target));
    return 0;
}
#include <stdio.h>

// 函数用于返回和为目标值的最长子序列的长度
int lengthOfLongestSubsequence(int *nums, int numsSize, int target) {
    // dp数组，dp[i]表示到当前元素结束，和为i的子序列的最大长度
    //int dp[target + 1] = {0};
    int* dp = (int*)malloc((target + 1) * sizeof(int));
    int maxLength = 0;

    // 遍历数组
    for (int i = 0; i < numsSize; i++) {
        // 从target往回退，找到小于等于nums[i]的最大的和
        for (int j = target; j >= nums[i]; j--) {
            // 如果dp[j - nums[i]]存在，则更新dp[j]的值
            if (dp[j - nums[i]] != -1) {
                dp[j] = (dp[j] == -1 || dp[j - nums[i]] + 1 > dp[j]) ? dp[j - nums[i]] + 1 : dp[j];
                maxLength = (maxLength > dp[j]) ? maxLength : dp[j];
            }
        }
        // 将dp[target - nums[i]]置为-1，避免使用当前元素多次
        dp[target - nums[i]] = -1;
    }
    return maxLength;
}

int main() {
    int nums[] = {1, 2, 3, 4, 5};
    int target = 9;
    int size = sizeof(nums) / sizeof(nums[0]);
    printf("The length of the longest subsequence is: %d\n", lengthOfLongestSubsequence(nums, size, target));
    return 0;
}
int maxSpending(int** values, int valuesSize, int* valuesColSize) {
    int m = valuesSize;
    int n = *valuesColSize;
    int dailyCost[m * n]; // 存储每天的开销
    int totalCost = 0; // 总开销
    int itemIndex = 0; // 物品索引

    for (int d = 1; d <= m * n; d++) {
        int maxVal = 0, maxI = -1, maxJ = -1;
        for (int i = 0; i < m; i++) {
            for (int j = n - 1; j >= 0; j--) {
                if (values[i][j] > maxVal && (itemIndex < n || values[i][j] != dailyCost[itemIndex])) {
                    maxVal = values[i][j];
                    maxI = i;
                    maxJ = j;
                }
            }
        }
        dailyCost[itemIndex++] = maxVal * d;
        totalCost += dailyCost[itemIndex - 1];
        // 标记为已购买，通过设置为负数来简化逻辑
        values[maxI][maxJ] = -1;
    }

    return totalCost;
}
#include <stdio.h>
#include <vector>
#include <utility> // for std::pair

using namespace std;

// 辅助函数，判断一个数是否是质数
bool isPrime(int num) {
    if (num <= 1) return false;
    for (int i = 2; i * i <= num; i++) {
        if (num % i == 0) return false;
    }
    return true;
}

// DFS 函数，找出合法路径并计数
void dfs(vector<vector<int>>& tree, int node, int n, vector<bool>& primes, int& count, int primeNode) {
    if (isPrime(node)) {
        primeNode = node;
    }
    count += primes[node];
    for (int nextNode : tree[node]) {
        if (nextNode == primeNode) {
            dfs(tree, nextNode, n, primes, count, primeNode);
        } else {
            dfs(tree, nextNode, n, primes, count, primeNode);
        }
    }
}

// 主函数，构建树并求解
int countValidPaths(int n, vector<vector<int>>& edges) {
    vector<vector<int>> tree(n + 1); // 树的邻接表表示
    vector<bool> primes(n + 1, false); // 标记质数
    int count = 0;

    // 构建树
    for (auto& edge : edges) {
        tree[edge[0]].push_back(edge[1]);
        tree[edge[1]].push_back(edge[0]);
    }

    // 找出所有的质数节点
    for (int i = 2; i <= n; i++) {
        primes[i] = isPrime(i);
    }

    // 从每个节点开始 DFS，找出合法路径
    for (int i = 1; i <= n; i++) {
        int primeNode = 0;
        dfs(tree, i, n, primes, count, primeNode);
    }

    return count;
}

int main() {
    int n = 5;
    vector<vector<int>> edges = {{1, 2}, {1, 3}, {2, 4}, {2, 5}};
    printf("The number of valid paths is: %d\n", countValidPaths(n, edges));
    return 0;
}
#include <stdlib.h>

// 定义图的结构
typedef struct {
    int **edges;
    int n; // 节点的数量
} Graph;

// 创建图
Graph *createGraph(int n) {
    Graph *graph = (Graph *)malloc(sizeof(Graph));
    graph->n = n;
    graph->edges = (int **)malloc(sizeof(int *) * n);
    for (int i = 0; i < n; i++) {
        graph->edges[i] = (int *)malloc(sizeof(int) * 1); // 每个节点至少有一个边
        graph->edges[i][0] = -1; // 初始化为-1，表示没有边
    }
    return graph;
}

// 添加边
void addEdge(Graph *graph, int start, int end) {
    int *temp = graph->edges[start];
    int newSize = 1 + sizeof(temp) / sizeof(temp[0]);
    graph->edges[start] = (int *)realloc(temp, newSize * sizeof(int));
    graph->edges[start][newSize - 1] = end;
}

// 释放图的内存
void freeGraph(Graph *graph) {
    for (int i = 0; i < graph->n; i++) {
        free(graph->edges[i]);
    }
    free(graph->edges);
    free(graph);
}

// 深度优先搜索，计算从节点i开始可以访问的不同节点数
int dfs(Graph *graph, int i, int *visited) {
    int count = 1; // 访问当前节点
    visited[i] = 1;
    for (int j = 0; graph->edges[i][j] != -1; j++) {
        int end = graph->edges[i][j];
        if (!visited[end]) {
            count += dfs(graph, end, visited);
        }
    }
    return count;
}

// 计算所有节点的访问计数
int *countVisitedNodes(Graph *graph, int n) {
    int *answer = (int *)malloc(sizeof(int) * n);
    int *visited = (int *)calloc(n, sizeof(int)); // 初始化所有节点为未访问
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            answer[i] = dfs(graph, i, visited);
        }
    }
    free(visited);
    return answer;
}

int main() {
    // 示例输入
    int n = 4;
    Graph *graph = createGraph(n);
    addEdge(graph, 0, 1);
    addEdge(graph, 1, 2);
    addEdge(graph, 2, 0);
    addEdge(graph, 3, 0);

    // 计算访问计数
    int *answer = countVisitedNodes(graph, n);

    // 输出结果
    for (int i = 0; i < n; i++) {
        printf("%d ", answer[i]);
    }
    printf("\n");

    // 释放内存
    freeGraph(graph);
    free(answer);

    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_N 100
#define MAX_M 100
#define DIRS 4

int visited[MAX_N][MAX_M];
int grid[MAX_N][MAX_M];
int directions[DIRS][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

int is_valid(int x, int y, int n, int m) {
    return x >= 0 && x < n && y >= 0 && y < m && !visited[x][y] && grid[x][y] != -1;
}

void bfs(int x, int y, int n, int m, int *sum) {
    int q[MAX_N * MAX_M];
    int head = 0, tail = 0;
    q[tail++] = x;
    q[tail++] = y;
    visited[x][y] = 1;
    *sum += abs(grid[x][y]);

    while (head < tail) {
        int cx = q[head++];
        int cy = q[head++];
        for (int i = 0; i < DIRS; ++i) {
            int nx = cx + directions[i][0];
            int ny = cy + directions[i][1];
            if (is_valid(nx, ny, n, m)) {
                visited[nx][ny] = 1;
                *sum += abs(grid[nx][ny]) + 1;
                q[tail++] = nx;
                q[tail++] = ny;
            }
        }
    }
}

long long sumOfRemoteness(int** grid, int gridRowSize, int gridColSize) {
    long long sum = 0;
    memset(visited, 0, sizeof(visited));
    for (int i = 0; i < gridRowSize; ++i) {
        for (int j = 0; j < gridColSize; ++j) {
            if (grid[i][j] == 0 && !visited[i][j]) {
                bfs(i, j, gridRowSize, gridColSize, &sum);
            }
        }
    }
    return sum;
}

int main() {
    // 示例输入
    int grid[MAX_N][MAX_M] = {
        {-1, 1, -1},
        {5, -1, 4},
        {-1, 3, -1}
    };
    int n = 3, m = 3;
    int** g = (int**)malloc(n * sizeof(int*));
    for (int i = 0; i < n; ++i) {
        g[i] = grid[i];
    }
    long long result = sumOfRemoteness(g, n, m);
    printf("%lld\n", result);
    free(g);
    return 0;
}
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// 比较两个字符串的字典序
int compare(const char* a, const char* b) {
    return strcmp(a, b);
}

// 找到最短且字典序最小的美丽子字符串
char* shortestBeautifulSubstring(char* s, int k) {
    int len = strlen(s);
    char* result = NULL;
    int minLen = len + 1; // 初始化为不可能的长度

    for (int i = 0; i < len; ++i) {
        int count = 0; // 用于计数1的数量
        for (int j = i; j < len; ++j) {
            if (s[j] == '1') ++count;
            if (count == k && j - i + 1 < minLen) {
                // 找到更短或相同长度但字典序更小的字符串
                result = (char*)realloc(result, (j - i + 2) * sizeof(char));
                strncpy(result, s + i, j - i + 1);
                result[j - i + 1] = '\0'; // 确保字符串结束符
                minLen = j - i + 1;
            }
        }
    }

    return result;
}

int main() {
    char s[] = "100011101";
    int k = 3;
    char* beautifulStr = shortestBeautifulSubstring(s, k);
    printf("最短且字典序最小的美丽子字符串: %s\n", beautifulStr);
    free(beautifulStr); // 释放之前分配的内存
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int cmp(const void *a, const void *b) {
    return (*(int*)b - *(int*)a);
}

int minimumProcessingTime(int *processorTime, int processorTimeSize, int *tasks, int tasksSize) {
    // 对任务执行时间进行排序
    qsort(tasks, tasksSize, sizeof(int), cmp);
    // 对处理器空闲时间排序
    qsort(processorTime, processorTimeSize, sizeof(int), cmp);
    
    int i = 0, j = 0, maxTime = 0;
    while (j < tasksSize) {
        // 为当前处理器分配任务
        for (int k = 3; k > 0 && i < processorTimeSize && j < tasksSize; --k) {
            int timeTaken = processorTime[i] + tasks[j];
            if (timeTaken > maxTime) {
                maxTime = timeTaken;
            }
            j++;
        }
        i++;
    }
    return maxTime;
}

int main() {
    int processorTime[] = {8, 10};
    int tasks[] = {2, 2, 3, 1, 8, 7, 4, 5};
    int n = sizeof(processorTime) / sizeof(processorTime[0]);
    int result = minimumProcessingTime(processorTime, n, tasks, 4 * n);
    printf("Minimum processing time: %d\n", result);
    return 0;
}
#include <stdio.h>

int maxSum(int* nums, int numsSize, int k) {
    int mod = 1000000007;
    // 排序数组，根据元素中1的个数降序排列
    int count[32] = {0}; // 假设int最大为32位
    for (int i = 0; i < numsSize; ++i) {
        int num = nums[i];
        while (num > 0) {
            count[31 - __builtin_clz(num)]++;
            num &= (num - 1); // 清除最低位的1
        }
    }
    int total = 0;
    // 选择具有最多1的前k个数
    for (int i = 31; i >= 0; --i) {
        if (k > count[i]) {
            k -= count[i];
            total += (1 << i) * count[i];
        } else {
            total += (1 << i) * k;
            break;
        }
    }
    // 计算平方和
    long long sum = 0;
    for (int i = 0; i < k; ++i) {
        sum += (long long)(total % mod) * (total % mod);
    }
    return (int)(sum % mod);
}

int main() {
    int nums[] = {2, 6, 5, 8};
    int k = 2;
    printf("Maximum sum of squares: %d\n", maxSum(nums, sizeof(nums) / sizeof(nums[0]), k));
    return 0;
}
#include <stdio.h>

// 定义结构体用于存储步数和日期
typedef struct {
    int user_id;
    int steps_count;
    char steps_date[11];
} Step;

// 计算滚动平均值的函数
double* rollingAverage(Step* steps, int stepsSize, int k, int* returnSize) {
    // 动态分配数组存储滚动平均值
    double* averages = malloc(sizeof(double) * (stepsSize - k + 1));
    int sum = 0; // 当前窗口的步数总和
    for (int i = 0; i < k; i++) {
        sum += steps[i].steps_count;
    }
    // 初始化滚动平均值数组的第一个元素
    averages[0] = (double)sum / k;
    *returnSize = stepsSize - k + 1;
    
    // 遍历步数列表，计算滚动平均值
    for (int i = k; i < stepsSize; i++) {
        sum += steps[i].steps_count - steps[i - k].steps_count; // 更新窗口总和
        averages[i - k + 1] = (double)sum / k;
    }
    
    return averages;
}

int main() {
    // 示例测试用例
    Step steps[] = {
        {1, 687, "2021-09-02"},
        {1, 395, "2021-09-04"},
        {1, 499, "2021-09-05"}
        // ... 更多步数记录
    };
    int k = 3;
    int returnSize;
    double* result = rollingAverage(steps, sizeof(steps) / sizeof(steps[0]), k, &returnSize);
    
    // 打印结果
    for (int i = 0; i < returnSize; i++) {
        printf("Day %d rolling average steps: %.2f\n", i + 1, result[i]);
    }
    
    // 释放内存
    free(result);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int sumOfSquares(int* nums, int numsSize) {
    int result = 0;
    int mod = 1000000007;
    int prefix[101][101] = {0}; // 存储前缀和，索引为不同计数和当前索引
    int count[101] = {0}; // 存储每个不同计数出现的次数

    // 初始化第一个元素
    prefix[1][0] = nums[0];
    count[1] = 1;

    for (int i = 1; i < numsSize; ++i) {
        int num = nums[i];
        // 记录当前元素出现的次数
        for (int j = 1; j <= i; ++j) {
            if (prefix[j][i - 1] == num) {
                prefix[j][i] = prefix[j][i - 1];
                count[j] = count[j] % mod;
            } else {
                prefix[j][i] = (prefix[j][i - 1] + 1) % mod;
                count[j] = (count[j] + 1) % mod;
            }
        }
    }

    // 计算所有不同计数的平方和
    for (int i = 1; i <= numsSize; ++i) {
        result = (result + (count[i] * (count[i] * i * i))) % mod;
    }

    return result;
}

int main() {
    int nums[] = {1, 2, 1};
    int size = sizeof(nums) / sizeof(nums[0]);
    printf("Sum of Squares: %d\n", sumOfSquares(nums, size));
    return 0;
}
int* lastVisited(int* nums, int numsSize, int* returnSize) {
    // 初始化seen和ans数组
    int capacity = 100;
    int* seen = (int*)malloc(capacity * sizeof(int));
    int* ans = (int*)malloc(capacity * sizeof(int));
    int seenSize = 0, ansSize = 0;

    // 遍历nums数组
    for (int i = 0; i < numsSize; i++) {
        if (nums[i] > 0) {
            // 正整数添加到seen数组的开头
            if (seenSize == capacity) {
                capacity *= 2;
                seen = (int*)realloc(seen, capacity * sizeof(int));
            }
            for (int j = seenSize; j > 0; j--) {
                seen[j] = seen[j - 1];
            }
            seen[0] = nums[i];
            seenSize++;
        } else {
            // 处理-1
            int k = 1;
            while (i + k < numsSize && nums[i + k] == -1) {
                k++;
            }
            if (k <= seenSize) {
                // 如果k小于等于seen数组的长度
                if (ansSize == capacity) {
                    capacity *= 2;
                    ans = (int*)realloc(ans, capacity * sizeof(int));
                }
                ans[ansSize++] = seen[seenSize - k];
            } else {
                // 如果k大于seen数组的长度
                if (ansSize == capacity) {
                    capacity *= 2;
                    ans = (int*)realloc(ans, capacity * sizeof(int));
                }
                ans[ansSize++] = -1;
            }
        }
    }

    // 调整ans数组大小
    ans = (int*)realloc(ans, ansSize * sizeof(int));
    *returnSize = ansSize;
    free(seen); // 释放seen数组
    return ans;
}
int* findIndices(int* nums, int numsSize, int indexDifference, int valueDifference, int* returnSize) {
    int *answer = (int *)malloc(2 * sizeof(int)); // 预先分配两个整数的空间
    for (int i = 0; i < numsSize; ++i) {
        for (int j = i + 1; j < numsSize; ++j) { // 从i+1开始，确保索引差至少为1
            if (abs(i - j) >= indexDifference && abs(nums[i] - nums[j]) >= valueDifference) {
                answer[0] = i; // 赋值i到answer的第一个位置
                answer[1] = j; // 赋值j到answer的第二个位置
                *returnSize = 2; // 设置返回数组的大小为2
                return answer; // 直接返回结果
            }
        }
    }
    answer[0] = -1; // 如果没有找到合适的索引对，设置答案为[-1, -1]
    answer[1] = -1;
    *returnSize = 2;
    return answer;
}
int minimum_number_of_groups(int *balls, int ballsSize) {
    // 统计每个数字出现的次数
    int max_val = 0;
    for (int i = 0; i < ballsSize; ++i) {
        if (balls[i] > max_val) {
            max_val = balls[i];
        }
    }
    int *count = (int *)calloc(max_val + 1, sizeof(int));
    for (int i = 0; i < ballsSize; ++i) {
        count[balls[i]]++;
    }

    // 对出现次数进行排序
    int temp;
    for (int i = 0; i < max_val; ++i) {
        for (int j = i + 1; j < max_val + 1; ++j) {
            if (count[i] < count[j]) {
                temp = count[i];
                count[i] = count[j];
                count[j] = temp;
            }
        }
    }

    // 分配盒子
    int boxes = 0;
    int j = max_val;
    while (j > 0) {
        int i = 1;
        while (i <= j && count[i] > 0) {
            count[i] -= (j - 1);
            i++;
            boxes++;
        }
        j--;
    }

    free(count);
    return boxes;
}
#include <stdio.h>
#include <stdlib.h>

// 用于比较两个整数的函数，供 qsort 使用
int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

// 找出满足条件的下标对
int* findIndices(int* nums, int numsSize, int indexDifference, int valueDifference, int* returnSize) {
    // 初始化返回数组和返回数组的大小
    int* result = (int*)malloc(2 * sizeof(int));
    *returnSize = 2;

    // 对数组进行排序
    qsort(nums, numsSize, sizeof(int), compare);

    // 使用双指针查找满足条件的下标对
    for (int i = 0, j = indexDifference; j < numsSize; i++, j++) {
        if (nums[j] - nums[i] >= valueDifference) {
            result[0] = i;
            result[1] = j;
            return result;
        }
    }

    // 如果没有找到满足条件的下标对，返回 [-1, -1]
    result[0] = -1;
    result[1] = -1;
    return result;
}

int main() {
    int nums[] = {5, 1, 4, 1};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int indexDifference = 2;
    int valueDifference = 4;
    int returnSize = 0;

    int* result = findIndices(nums, numsSize, indexDifference, valueDifference, &returnSize);

    printf("Indices: [%d, %d]\n", result[0], result[1]);
    free(result);

    return 0;
}
int minSumEqualize(int* nums1, int m, int* nums2, int n) {
    int sum1 = 0, sum2 = 0, diff = 0, zeros1 = 0, zeros2 = 0;
    
    // 计算两个数组的和以及0的个数
    for (int i = 0; i < m; i++) {
        sum1 += nums1[i];
        if (nums1[i] == 0) zeros1++;
    }
    for (int i = 0; i < n; i++) {
        sum2 += nums2[i];
        if (nums2[i] == 0) zeros2++;
    }
    
    // 计算差值
    diff = abs(sum1 - sum2);
    
    // 替换0以达到和相等
    if (diff > 0) {
        // 如果sum1大于sum2，从nums1中替换0
        diff = (diff <= zeros1) ? diff : -1;
    } else if (diff < 0) {
        // 如果sum2大于sum1，从nums2中替换0
        diff = (-diff <= zeros2) ? -diff : -1;
    }
    
    // 更新和
    if (diff != -1) {
        if (sum1 > sum2) {
            sum1 -= diff;
        } else {
            sum2 += diff;
        }
    }
    
    // 返回最小相等和或-1
    return (sum1 == sum2) ? (sum1 + diff - 1) : -1;
}
#include <stdio.h>
#include <string.h>

int minChanges(char *s) {
    int len = strlen(s);
    int changes = 0;
    
    for (int i = 0; i < len; i += 2) {
        // 检查长度为2的子串中的两个字符是否相同
        if (s[i] != s[i + 1]) {
            changes++;
        }
    }
    
    return changes;
}

int main() {
    char s[] = "1001";
    printf("最少修改次数: %d\n", minChanges(s));
    return 0;
}
int minimumSum(int* nums, int numsSize) {
    int minSum = 51; // 初始化为一个大于50的数
    int i, j, k;

    // 寻找峰值并检查山形三元组
    for (j = 1; j < numsSize - 1; j++) {
        if (nums[j - 1] < nums[j] && nums[j] > nums[j + 1]) {
            // 峰值左侧找到最大的数
            for (i = j - 1; i >= 0; i--) {
                if (nums[i] < nums[j]) {
                    break;
                }
            }
            // 峰值右侧找到最小的数
            for (k = j + 1; k < numsSize; k++) {
                if (nums[k] < nums[j]) {
                    break;
                }
            }
            // 计算当前山形三元组的和，并更新最小和
            int currentSum = nums[i] + nums[j] + nums[k];
            if (currentSum < minSum) {
                minSum = currentSum;
            }
        }
    }

    return (minSum == 51) ? -1 : minSum; // 如果没有找到，则返回-1
}
#include <stdio.h>
#include <stdlib.h>

int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int minimizeArrayAfterReplacements(int* nums, int numsSize, int k) {
    qsort(nums, numsSize, sizeof(int), compare);
    int i = 0;
    while (k--) {
        if (i >= numsSize - 1) break; // 如果只剩下一个元素，结束操作
        int minIndex = (i == 0) ? i : (nums[i - 1] < nums[i] ? i - 1 : i);
        // 选择当前最小的两个数进行乘法操作
        nums[minIndex] *= nums[minIndex + 1];
        // 由于乘法操作可能使得新的元素成为最小值，需要重新排序
        qsort(nums, numsSize, sizeof(int), compare);
        // 更新索引位置
        i = minIndex > 0 ? minIndex : 0;
    }
    return nums[0]; // 返回数组最小化后的第一个元素
}

int main() {
    int nums[] = {2, 3, 3, 7, 3, 5};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int k = 2;
    printf("Minimized array after %d replacements is: %d\n", k, minimizeArrayAfterReplacements(nums, numsSize, k));
    return 0;
}
int maxScore(int* prices, int pricesSize) {
    int maxScore = 0;
    // 计算累积和
    int* prefixSum = (int*)malloc(pricesSize * sizeof(int));
    prefixSum[0] = 0;
    for (int i = 1; i < pricesSize; ++i) {
        prefixSum[i] = prefixSum[i - 1] + prices[i] - prices[i - 1];
    }

    // 使用双指针查找最大得分
    for (int i = 0; i < pricesSize; ++i) {
        int minPrefixSum = prefixSum[i];
        for (int j = i; j < pricesSize; ++j) {
            minPrefixSum = fmin(minPrefixSum, prefixSum[j]);
            int score = prefixSum[j] - minPrefixSum - (j - i) * prices[i];
            maxScore = fmax(maxScore, score);
        }
    }

    free(prefixSum);
    return maxScore;
}
#include <stdio.h>

int findKOr(int* nums, int numsSize, int k) {
    int result = 0;
    for (int bit = 0; bit < 32; ++bit) {
        int count = 0;
        for (int i = 0; i < numsSize; ++i) {
            if ((nums[i] >> bit) & 1) {
                count++;
            }
        }
        if (count >= k) {
            result |= (1 << bit);
        }
    }
    return result;
}

int main() {
    int nums[] = {7, 12, 9, 8, 9, 15};
    int k = 4;
    printf("The K-or value is: %d\n", findKOr(nums, sizeof(nums) / sizeof(nums[0]), k));
    return 0;
}
int maxBalancedSubsequenceSum(int* nums, int numsSize) {
    if (numsSize == 0) return 0;
    
    // 初始化dp数组
    int dp[numsSize];
    dp[0] = nums[0];
    int maxSum = dp[0];
    
    // 动态规划求解
    for (int i = 1; i < numsSize; i++) {
        dp[i] = nums[i];
        for (int j = 0; j < i; j++) {
            if (nums[i] - nums[j] >= i - j) {
                dp[i] = max(dp[i], nums[i] + dp[j]);
            }
        }
        maxSum = max(maxSum, dp[i]);
    }
    
    return maxSum;
}
// 函数用于计算最大利润
int maxProfit(int* prices, int pricesSize) {
    if (pricesSize < 3) return 0;

    int minPrice = prices[0]; // 记录最小买入价格
    int maxProfit = 0; // 记录最大利润

    for (int i = 1; i < pricesSize; i++) {
        // 更新最小买入价格
        if (prices[i] < minPrice) {
            minPrice = prices[i];
        } else {
            // 当前价格大于最小价格，检查是否为卖出点以获取利润
            maxProfit = maxProfit > 0 ? maxProfit : 0;
            maxProfit = max(maxProfit, prices[i] - minPrice);
        }
    }

    return maxProfit;
}
int findChampion(int** grid, int gridRowSize, int gridColSize) {
    for (int i = 0; i < gridRowSize; i++) {
        int isChampion = 1; // 假设当前队伍是冠军
        for (int j = 0; j < gridColSize; j++) {
            if (i != j && grid[i][j] == 1) {
                // 如果存在其他队伍能击败当前队伍，则当前队伍不是冠军
                isChampion = 0;
                break;
            }
        }
        if (isChampion) {
            return i; // 返回冠军队伍的编号
        }
    }
    return -1; // 如果没有队伍能成为冠军，返回-1（这种情况在题目中是不会出现的）
}
#include <stdio.h>
#include <stdlib.h>

typedef struct Edge {
    int to;
    struct Edge* next;
} Edge;

typedef struct {
    Edge* head;
    int inDegree;
} Node;

int findChampion(int n, int** edges, int* edgesRowSize, int* edgesColSize) {
    Node nodes[n];
    for (int i = 0; i < n; ++i) {
        nodes[i].head = NULL;
        nodes[i].inDegree = 0;
    }

    // 构建图
    for (int i = 0; i < edgesRowSize[0]; ++i) {
        int from = edges[0][i];
        int to = edges[1][i];
        Edge* edge = (Edge*)malloc(sizeof(Edge));
        edge->to = to;
        edge->next = nodes[from].head;
        nodes[from].head = edge;
        nodes[to].inDegree++;
    }

    int count = 0;
    int champion = -1;
    // 拓扑排序查找冠军
    for (int i = 0; i < n; ++i) {
        if (nodes[i].inDegree == 0) {
            count++;
            champion = i;
            // 检查是否是唯一冠军
            for (int j = 0; j < n; ++j) {
                if (nodes[j].head != NULL && j != i) {
                    Edge* temp = nodes[j].head;
                    while (temp != NULL) {
                        if (temp->to == i) {
                            break;
                        }
                        temp = temp->next;
                    }
                    if (temp != NULL) break;
                }
            }
            if (count > 1) break;
        }
    }

    return count == 1 ? champion : -1;
}
#include <stdio.h>
#include <string.h>

int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int* findWordsContainingCharacter(char** words, int wordsSize, char x, int* returnSize) {
    int *result = malloc(sizeof(int) * wordsSize);
    *returnSize = 0;
    
    for (int i = 0; i < wordsSize; i++) {
        if (strchr(words[i], x) != NULL) {
            result[*returnSize] = i;
            (*returnSize)++;
        }
    }
    
    qsort(result, *returnSize, sizeof(int), compare);
    
    return result;
}

int main() {
    char* words[] = {"leet", "code"};
    int wordsSize = sizeof(words) / sizeof(words[0]);
    char x = 'e';
    int returnSize = 0;
    
    int *result = findWordsContainingCharacter(words, wordsSize, x, &returnSize);
    
    for (int i = 0; i < returnSize; i++) {
        printf("%d ", result[i]);
    }
    
    free(result);
    return 0;
}
#include <stdio.h>
#include <string.h>

int minimumSwaps(char* s) {
    int length = strlen(s);
    int zeroCount = 0; // 记录 '0' 的数量
    int swapCount = 0; // 交换次数

    for (int i = 0; i < length; ++i) {
        if (s[i] == '0') {
            zeroCount++;
        } else {
            swapCount += zeroCount;
        }
    }

    return swapCount;
}

int main() {
    char s[] = "101";
    printf("Minimum swaps: %d\n", minimumSwaps(s));
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 比较函数，用于qsort
int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

// 二分查找可能的众数
int bsearch(int *nums, int n, int k) {
    int left = 0, right = n - 1;
    int mid, res = 0;
    while (left <= right) {
        mid = left + (right - left) / 2;
        int moves = 0;
        // 计算将mid作为众数时需要的操作次数
        for (int i = 0; i < n; ++i) {
            if (i < mid) {
                moves += mid - nums[i];
            } else if (i > mid) {
                moves += nums[i] - mid;
            }
        }
        // 如果操作次数小于等于k，尝试扩大众数的范围
        if (moves <= k) {
            res = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return res;
}

// 计算最大频率分数
int maxFrequencyScore(int *nums, int numsSize, int k) {
    // 对数组进行排序
    qsort(nums, numsSize, sizeof(int), compare);
    // 使用二分查找可能的众数，并计算最大频率分数
    int mode = bsearch(nums, numsSize, k);
    // 计算以mode为众数时的频率
    int count = 0, maxCount = 0;
    for (int i = 0; i < numsSize; ++i) {
        if (nums[i] == mode) ++count;
        else if (nums[i] > mode) {
            maxCount = max(maxCount, count);
            count = 0;
        }
    }
    maxCount = max(maxCount, count); // 包括数组末尾的连续mode
    return maxCount;
}

// 辅助函数，用于计算两个数的最大值
int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    int nums[] = {1, 2, 6, 4};
    int k = 3;
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    printf("The maximum frequency score is: %d\n", maxFrequencyScore(nums, numsSize, k));
    return 0;
}
int maxStrongPairXor(int* nums, int numsSize) {
    // 排序数组
    qsort(nums, numsSize, sizeof(int), compare);

    int max_xor = 0;
    for (int i = 0; i < numsSize; ++i) {
        for (int j = i + 1; j < numsSize; ++j) {
            // 计算异或值
            int xor_val = nums[i] ^ nums[j];
            // 更新最大异或值
            if (xor_val > max_xor) {
                max_xor = xor_val;
            }
        }
    }
    return max_xor;
}
int numberOfWays(int m, int n, int* source, int* dest) {
    int dp[m][n]; // 动态规划表
    int i, j;

    // 初始化动态规划表
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            dp[i][j] = 0;
        }
    }
    dp[source[0]][source[1]] = 1; // 起点初始化

    // 动态规划填表
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            if (i == 0 && j == 0) continue; // 起点已初始化
            if (i > 0) dp[i][j] += dp[i - 1][j]; // 从上方来
            if (j > 0) dp[i][j] += dp[i][j - 1]; // 从左方来
        }
    }

    return dp[dest[0]][dest[1]]; // 目的地的路径数量
}
#include <stdio.h>

// 计算组合数 C(n, k)
long long combine(int n, int k) {
    long long c = 1;
    if (k > n) return 0;
    if (k > n - k) k = n - k;
    for (int i = 0; i < k; ++i) {
        c *= n - i;
        c /= i + 1;
    }
    return c;
}

// 分糖果的方案数
int distributeCandies(int n, int limit) {
    return n > 2 * limit ? combine(n, 2) : 0;
}

int main() {
    int n = 5, limit = 2;
    printf("Total ways to distribute candies: %d\n", distributeCandies(n, limit));
    return 0;
}
1. **MPU配置**：通过`mpu_set_protection`函数，可以配置MPU的保护区域。
2. **内存区域保护**：`mpu_memory_protection`函数设置了多个内存区域的保护，包括DTCM、AXI SRAM、SRAM1~SRAM3、SRAM4、FMC、SDRAM和NAND FLASH。
3. **错误处理**：`MemManage_Handler`函数处理内存访问错误，并通过LED和串口输出错误信息，最后执行软件复位。
/** 
 * 初始化按键
 * 配置GPIO引脚，设置为输入模式，并启用内部下拉电阻。
 */
void key_init(void)
{
    GPIO_InitTypeDef gpio_init_struct;  // 定义GPIO初始化结构体

    // 使能GPIO时钟，确保GPIO能够正常工作
    KEY0_GPIO_CLK_ENABLE();  // 使能KEY0的GPIO时钟
    WKUP_GPIO_CLK_ENABLE();  // 使能WKUP的GPIO时钟

    // 配置KEY0引脚为输入模式，启用下拉电阻，设置为高速
    gpio_init_struct.Pin = KEY0_GPIO_PIN;  // 设置引脚
    gpio_init_struct.Mode = GPIO_MODE_INPUT;  // 设置为输入模式
    gpio_init_struct.Pull = GPIO_PULLDOWN;  // 设置为下拉
    gpio_init_struct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;  // 设置为高速
    HAL_GPIO_Init(KEY0_GPIO_PORT, &gpio_init_struct);  // 初始化KEY0引脚

    // 配置WKUP引脚，与KEY0引脚配置相同
    gpio_init_struct.Pin = WKUP_GPIO_PIN;  // 设置引脚
    HAL_GPIO_Init(WKUP_GPIO_PORT, &gpio_init_struct);  // 初始化WKUP引脚
}
uint8_t key_scan(uint8_t mode)
{
    static uint8_t key_up = 1;  // 静态变量，用于标记按键是否松开

    if (mode == 1)  // 如果支持连续按键
    {
        key_up = 1;  // 重置按键松开标志
    }

    // 如果按键松开标志为1，并且有按键被按下
    if (key_up && (KEY0 == 1 || WK_UP == 1))
    {
        delay_ms(10);  // 去抖动
        key_up = 0;  // 标记按键已经被按下

        // 检测哪个按键被按下，并设置相应的返回值
        if (KEY0 == 1)
        {
            return KEY0_PRES;  // 返回KEY0按下的值
        }
        if (WK_UP == 1)
        {
            return WKUP_PRES;  // 返回WKUP按下的值
        }
    }
    else if (KEY0 == 0 && WK_UP == 0)  // 如果没有按键被按下
    {
        key_up = 1;  // 重置按键松开标志
    }

    return 0;  // 如果没有按键按下，返回0
}
/* 设置DAC输出电压的函数 */
void dac_set_voltage(uint8_t outx, uint16_t vol)
{
    uint32_t dacdata;
    
    /* 将电压值转换为DAC可接受的数字量 */
    dacdata = vol * 4095 / 3300;
    
    /* 限制dacdata的最大值为4095 */
    if (dacdata >= 4096)
    {
        dacdata = 4095;
    }
    
    /* 根据通道设置DAC值 */
    if (outx == 1)
    {
        HAL_DAC_SetValue(&g_dac_handle, DAC_CHANNEL_1, DAC_ALIGN_12B_R, dacdata);
    }
    else
    {
        HAL_DAC_SetValue(&g_dac_handle, DAC_CHANNEL_2, DAC_ALIGN_12B_R, dacdata);
    }
}
/* 初始化DAC通道的函数 */
void dac_init(uint8_t outx)
{
    /* 配置结构体定义 */
    DAC_ChannelConfTypeDef dac_ch_conf;
    GPIO_InitTypeDef gpio_init_struct;
    
    /* 使能DAC和GPIOA的时钟 */
    __HAL_RCC_DAC12_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    
    /* 根据通道配置GPIO引脚为模拟模式 */
    gpio_init_struct.Pin = (outx == 1) ? GPIO_PIN_4 : GPIO_PIN_5;
    gpio_init_struct.Mode = GPIO_MODE_ANALOG;
    HAL_GPIO_Init(GPIOA, &gpio_init_struct);
    
    /* 初始化DAC */
    g_dac_handle.Instance = DAC1;
    HAL_DAC_Init(&g_dac_handle);
    
    /* 配置DAC通道 */
    dac_ch_conf.DAC_Trigger = DAC_TRIGGER_NONE;
    dac_ch_conf.DAC_OutputBuffer = DAC_OUTPUTBUFFER_DISABLE;
    
    /* 根据outx选择通道并配置 */
    switch(outx)
    {
        case 1 :
            HAL_DAC_ConfigChannel(&g_dac_handle, &dac_ch_conf, DAC_CHANNEL_1);
            HAL_DAC_Start(&g_dac_handle, DAC_CHANNEL_1);
            break;
        case 2 :
            HAL_DAC_ConfigChannel(&g_dac_handle, &dac_ch_conf, DAC_CHANNEL_2);
            HAL_DAC_Start(&g_dac_handle, DAC_CHANNEL_2);
            break;
        default :
            break;
    }
}
void dac_init(uint8_t outx)
{
    /* 配置结构体定义 */
    DAC_ChannelConfTypeDef dac_ch_conf;
    GPIO_InitTypeDef gpio_init_struct;
    
    /* 使能DAC和GPIOA的时钟 */
    __HAL_RCC_DAC12_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    
    /* 根据通道配置GPIO引脚为模拟模式 */
    gpio_init_struct.Pin = (outx == 1) ? GPIO_PIN_4 : GPIO_PIN_5;
    gpio_init_struct.Mode = GPIO_MODE_ANALOG;
    HAL_GPIO_Init(GPIOA, &gpio_init_struct);
    
    /* 初始化DAC */
    g_dac_handle.Instance = DAC1;
    HAL_DAC_Init(&g_dac_handle);
    
    /* 配置DAC通道 */
    dac_ch_conf.DAC_Trigger = DAC_TRIGGER_NONE;
    dac_ch_conf.DAC_OutputBuffer = DAC_OUTPUTBUFFER_DISABLE;
    
    /* 根据outx选择通道并配置 */
    switch(outx)
    {
        case 1 :
            HAL_DAC_ConfigChannel(&g_dac_handle, &dac_ch_conf, DAC_CHANNEL_1);
            HAL_DAC_Start(&g_dac_handle, DAC_CHANNEL_1);
            break;
        case 2 :
            HAL_DAC_ConfigChannel(&g_dac_handle, &dac_ch_conf, DAC_CHANNEL_2);
            HAL_DAC_Start(&g_dac_handle, DAC_CHANNEL_2);
            break;
        default :
            break;
    }
}
/* 定义LED0的IO操作宏，用于控制LED0的亮灭 */
#define LED0(x)                 do{ x ? \
                                    HAL_GPIO_WritePin(LED0_GPIO_PORT, LED0_GPIO_PIN, GPIO_PIN_SET) :  \
                                    HAL_GPIO_WritePin(LED0_GPIO_PORT, LED0_GPIO_PIN, GPIO_PIN_RESET); \
                                }while(0)

/* 定义LED0的状态翻转宏 */
#define LED0_TOGGLE()           do{ HAL_GPIO_TogglePin(LED0_GPIO_PORT, LED0_GPIO_PIN); }while(0)

```c
#ifndef __NORFLASH_EX_H // 确保头文件只被包含一次
#define __NORFLASH_EX_H

#include "./SYSTEM/sys/sys.h" // 包含系统头文件

/* 函数声明 */
// 以下函数用于操作QSPI闪存

void norflash_ex_erase_chip(void); // 擦除整个QSPI闪存芯片
uint16_t norflash_ex_read_id(void); // 从QSPI闪存读取制造商和设备ID
void norflash_ex_erase_sector(uint32_t addr); // 根据提供的地址擦除QSPI闪存的扇区
uint8_t norflash_ex_write(uint8_t *pbuf, uint32_t addr, uint16_t datalen); // 向QSPI闪存写入数据
void norflash_ex_read(uint8_t *pbuf, uint32_t addr, uint16_t datalen); // 从QSPI闪存读取数据

#endif // 防止头文件重复包含
这段代码是一个针对STM32微控制器的DCMI（数字相机接口）驱动程序，用于初始化和控制DCMI接口，以便与数字相机进行通信。下面是对代码的概括、关键点分析以及注释建议：
这段代码提供了一套SCCB通信协议的驱动函数，用于初始化SCCB接口，控制SCCB的信号线，以及发送和接收数据。
这段代码是一个STM32微控制器项目中用于SCCB（一种串行通信总线）的驱动实现。SCCB常用于I2C设备之间的通信，但具有不同的信号线定义和协议。以下是对这段代码的概括和关键点分析，以及对每一行代码的注释：
