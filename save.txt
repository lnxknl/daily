#include "led.h"
#include "delay.h"
#include "sys.h"
#include "usart.h"
#include "oled.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "scan.h"
extern u8 hum_set,Is_Ture;
u8 out_state[3];

/*
         1.显示三路超声波的距离
         2.第二屏幕设置 报警距离
*/
void Targ_GPIO()
{
    GPIO_InitTypeDef  GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_10|GPIO_Pin_1;	 //PD3,PD6推挽输出  
 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//速度50MHz
 	GPIO_Init(GPIOB, &GPIO_InitStructure);	  //初始化GPIOD3,6
    
 	GPIO_ResetBits(GPIOB,GPIO_Pin_0|GPIO_Pin_10|GPIO_Pin_1);	//PD3,PD6 输出高
}
extern volatile u8  TIM4_CAPTURE_STA,state;	//输入捕获状态		    				
extern volatile u16 TIM4_CAPTURE_VAL;	//输入捕获值
float distance_circulate(u32 date,u8 state) //计算距离,dis=340m/s*时间/2
{
    float dis;
    if(state>0xc1) //超出范围,不计算
        state=0xc1;
    date+=(state-0xc0)*65535; //计算溢出的时间,超出范围,不计算
    date/=2;
    dis=(date*340)/10000.0;
    return dis;
}
u8 dis_warn(float warn,u8 dis)
{
  if((u8)warn<dis)
  {
    TIM_Cmd(TIM2,ENABLE);
    TIM2->PSC=719;
    
      if((u8)warn+2<dis)
       TIM2->PSC=366;
    if((u8)warn+5<dis)
        TIM2->PSC=71;
    return 1;
  }
  return 0;
}
 int main(void) //主函数
 { 
    u32 distance[3];
    float dis_save[3];
     float dis_temp;
    u8 distance_warning=10;
	volatile u8 Key_vaule,num_pos=0;
    
	u8 buf[20],buf1[20],Is_distance_set=0,Heart_bit; //
	delay_init();	    	 //延时函数初始化	  
	TIM4_Cap_Init(0xffff,71);
    
  //  TIM4_Int_Init(0xffff,71);
    Key_GPIO_Init();  // PA 0-7
     
   // TIM4_Cap_Init(0xffff,71);          //三路超声波初始化 PB 7-9
     OLED_Init();  //oled超舒适化  PB 3,4,5,6
    Targ_GPIO();
	memset(buf,0,16);
    memset(buf1,0,16);
    TIME_INIT(); 
    TIM_Cmd(TIM4,ENABLE ); 	//使能定时器2
	while(1)
	{
      Key_vaule=Key_Scan(); //按键扫描
        
       if(Heart_bit>100) //超声波测距,每100ms测一次
       {
          
 
            state=1;
            PBout(0)=1;
            delay_us(30);
            PBout(0)=0;
            TIM4_CAPTURE_VAL=0;
            while(TIM4_CAPTURE_STA<0xc0);
           out_state[0]=TIM4_CAPTURE_STA;
            distance[0]=TIM4_CAPTURE_VAL;
            TIM4_CAPTURE_STA=0; //重置标志位
            state=2;
            PBout(1)=1;
            delay_us(30);
            PBout(1)=0;
            TIM4_CAPTURE_VAL=0;
            while(TIM4_CAPTURE_STA<0xc0);
           out_state[1]=TIM4_CAPTURE_STA;
            distance[1]=TIM4_CAPTURE_VAL;
            TIM4_CAPTURE_STA=0;  //重置标志位
            state=3;
            PBout(10)=1;
            delay_us(30);
            PBout(10)=0;
            TIM4_CAPTURE_VAL=0;
           while(TIM4_CAPTURE_STA<0xc0);
           out_state[2]=TIM4_CAPTURE_STA;
           distance[2]=TIM4_CAPTURE_VAL;
           TIM4_CAPTURE_STA=0;  //重置标志位
       }
      if(Key_vaule=='A') //按键A,设置距离 
      {
        Is_distance_set=1;
        OLED_Clear();//清屏 显示设置的距离
        OLED_ShowString(5,0,"setting/cm");      
        OLED_Refresh_Gram();	 
          
      }
      if(Key_vaule>='0'&&Key_vaule<='9'&&Is_distance_set==1)
      {
        buf[num_pos++]=Key_vaule;
        OLED_ShowString(5,20,buf);  //显示按键
        OLED_Refresh_Gram();
        if(num_pos>3)
            num_pos=0;
      }
      if(Key_vaule=='#'&&(Is_distance_set==1))  //设置距离
      {
        Is_distance_set=0; //设置完成,跳出
        if(strlen(buf)>0)
            distance_warning=atoi(buf);
        memset(buf,0,10);
        delay_ms(1000);
        OLED_Clear();
        Heart_bit=111;  //为了等下能快速看到距离
      }
     
      
     if(Heart_bit>100&&(Is_distance_set==0)) //超声波测距,每100ms测一次,并显示,并且判断是否报警
     {
        Heart_bit=0;
         sprintf(buf1,"CH1:%.1f cm",dis_save[0]=distance_circulate(distance[0],out_state[0]));               //测量距离
         OLED_ShowString(5,0,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
         sprintf(buf1,"CH2:%.1f cm",dis_save[1]=distance_circulate(distance[1],out_state[1]));               //测量距离
         OLED_ShowString(5,16,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
         sprintf(buf1,"CH3:%.1f cm",dis_save[2]=distance_circulate(distance[2],out_state[2]));               //测量距离
         OLED_ShowString(5,32,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
     }
     /*-----------------三个等级----------------------*/
     if(dis_save[0]<distance_warning||dis_save[1]<distance_warning||dis_save[2]<distance_warning)
     {
        dis_warn(dis_save[0],distance_warning);
        dis_warn(dis_save[1],distance_warning);
        dis_warn(dis_save[2],distance_warning);
     }else{
     TIM_Cmd(TIM2,DISABLE);  //DISABLE
     }
//     dis_temp=0;
//     dis_temp+=dis_save[0];
//     dis_temp+=dis_save[1];
//     dis_temp+=dis_save[2];
//     if((int)dis_temp<distance_warning*3)
//     {
//        TIM_Cmd(TIM2,ENABLE);
//        if((int)dis_temp<(distance_warning*3-20))
//         TIM2->PSC=199;
//        if((int)dis_temp<(distance_warning*3-30))
//         TIM2->PSC=71;
//     }else
//     {
//     
//      TIM_Cmd(TIM2,DISABLE);  //DISABLE
//     }
     Heart_bit++;
     delay_ms(10);   
    }
    
}
//TIM_SetCompare2(TIM1,light_table[pre_t][1]);
#include "delay.h"
#include "sys.h"
#include "usart.h"
#include "timer.h"
#include "led.h"
#include "key.h"

#define LAMP_ON   1
#define LAMP_OFF  0

void bsp_init(void);
int main(void)
{
	bsp_init();
	 
	while(1)
	{
		if(IO_LIGHT == 1) //弱光
		{
			if(IO_MAN  == 1|| IO_SOUND == 1)
			{
				sendMsgTout1 = 5000; //10s
				if(!IO_LAMP)
					IO_LAMP = LAMP_ON;
			}
		}
		else
		{
			if(IO_LAMP)
					IO_LAMP = LAMP_OFF;
		}
		
		if(sendMsgTout1 == 0) 
		{
			if(IO_LAMP)
				IO_LAMP = LAMP_OFF; //关灯
		}
	}
}

void bsp_init(void)
{
	delay_init();	    	 //延时函数初始化	  
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置中断优先级分组为组2：2位抢占优先级，2位响应优先级
	TIM3_Int_Init(9,7199);//10Khz的计数频率，计数到9,1ms进入一次中断
	uart_init(9600);	 	//串口初始化为115200	 	
	IO_Init();
}


#include "stm32f10x.h"
#include "led.h"
#include "delay.h"
#include "key.h"
#include "usart.h"
#include <string.h>
#include <stdio.h>
#include <w25q128.h>
#include <lcd.h>
#include "sd.h" //SD卡
#include "ff.h" //文件系统
#include "vs1053b.h"
#include "exti.h"
#include "rtc.h"
#include "timer.h"
u8 ScanVSFile(const char *path);
/*
按键1 开始录音
按键2 结束录音
按键3 播放音频
*/
FATFS fs;  // 用户定义的文件系统结构体
u8 RecoderPlay(u8 *file_name);
u8 VS1053_PlayOneMusic(u8 *pname);
u8 *VS1053_FileBuff[10];
u32  VS_Cnt=0;
int main()
{
		        //文件数量	
	char clock_buff[1024];	//存放时间字符串
	u8 key;
	u32 sd_size;    //存放SD卡返回的容量
	BeepInit();		  //蜂鸣器初始化
	LedInit();      //LED灯初始化 
	UsartInit(USART1,72,115200);
	KeyInit();     //按键初始化
	W25Q128_Init();
	LcdInit();
	EXTI0_Init();
	TIMx_Init(TIM2,72,20000);//20ms
	RTC_Init();
	LCD_Clear(WHITE);
	
	NT35310_LCD_ShowString(0,0,16,(u8*)"串口工作正常!");
	if(SDCardDeviceInit()) {NT35310_LCD_ShowString(0,16,16,(u8*)"SD卡初始化失败!");}
	else {NT35310_LCD_ShowString(0,16,16,(u8*)"SD卡初始化成功!");}
	sd_size=GetSDCardSectorCount();	//检测SD卡大小，返回值右移11位得到以M为单位的容量
	sprintf(clock_buff,"SD卡容量:%d MB",sd_size>>11);
	NT35310_LCD_ShowString(0,32,16,(u8*)clock_buff);
	
  if(f_mount(&fs,"0:",1)==FR_OK)NT35310_LCD_ShowString(0,48,16,(u8*)"文件系统初始化成功!");  // 注册文件系统工作区，驱动器号 0，初始化后其他函数可使用里面的参数
	else NT35310_LCD_ShowString(0,48,16,(u8*)"文件系统初始化失败!");
	DelayMs(3000);
	LCD_Clear(WHITE);
	VS1053_Init();       					//VS1053初始化
	while(1)
	{	
			
			if(VS_Start)	 // key interrupt for record
			{
				LCD_Clear(WHITE);
				sprintf(clock_buff,"%d%d%d%d.wav",rtc_clock.day,rtc_clock.hour,rtc_clock.minue,rtc_clock.second);
				NT35310_LCD_ShowString(0,0,16,(u8*)"正在录音中............");
				NT35310_LCD_ShowString(0,16,16,(u8*)"录音名称：");
				NT35310_LCD_ShowString(80,16,16, (u8*)clock_buff);
				RecoderPlay((u8*)clock_buff);
				ScanVSFile("0:");
				DelayMs(500);
				LCD_Clear(WHITE);
			}	
		
			key=GetKeyValue(1);
			if(key==1) 
			{
				LCD_Clear(WHITE);
				NT35310_LCD_ShowString(0,0,16,(u8*)"播放录音中............");
				NT35310_LCD_ShowString(0,16,16,(u8*)"录音名称：");
				NT35310_LCD_ShowString(80,16,16,(u8*)VS1053_FileBuff[VS_Cnt]);
				printf("%s\r\n",VS1053_FileBuff[VS_Cnt]);
				VS1053_PlayOneMusic(VS1053_FileBuff[VS_Cnt]);
				if(VS_Cnt == 0)
				{
					NT35310_LCD_ShowString(0,0,32,(u8*)"这是第一首录音............");
					VS_Cnt++;
				}
				VS_Cnt--;
				DelayMs(500);
				LCD_Clear(WHITE);
			}
			else if(key==3)
			{
				LCD_Clear(WHITE);
				NT35310_LCD_ShowString(0,00,16,(u8*)"播放录音中............");
				NT35310_LCD_ShowString(0,16,16,(u8*)"录音名称：");
				NT35310_LCD_ShowString(80,16,16,(u8*)VS1053_FileBuff[VS_Cnt]);
				printf("%s\r\n",VS1053_FileBuff[VS_Cnt]);
				if(VS_Cnt>10)
				{
					NT35310_LCD_ShowString(0,32,16,(u8*)"这是最后一首录音............");
					VS_Cnt--;
				}
				 VS1053_PlayOneMusic(VS1053_FileBuff[VS_Cnt]);
				 VS_Cnt++;
				 DelayMs(500);
				 LCD_Clear(WHITE);
			}	
			
			LED1=!LED1;
			DelayMs(200);
			if(Flag_RX1)
			{
					if(buff[0]=='*')
					{
							rtc_clock.year=(buff[1]-48)*1000+(buff[2]-48)*100+(buff[3]-48)*10+(buff[4]-48)*1;
							rtc_clock.month=(buff[5]-48)*10+(buff[6]-48)*1;
							rtc_clock.day=(buff[7]-48)*10+(buff[8]-48)*1;
							rtc_clock.hour=(buff[9]-48)*10+(buff[10]-48)*1;
							rtc_clock.minue=(buff[11]-48)*10+(buff[12]-48)*1;
							rtc_clock.second=(buff[13]-48)*10+(buff[14]-48)*1;
							time_transfor(rtc_clock.year,rtc_clock.month,rtc_clock.day,rtc_clock.hour,rtc_clock.minue,rtc_clock.second);	
					}
					Flag_RX1=0;
					cnt_RX1=0;
					
			}
			sprintf(clock_buff,"%d年%d月%d日%d时%d分%d秒",rtc_clock.year,rtc_clock.month,rtc_clock.day,rtc_clock.hour,rtc_clock.minue,rtc_clock.second);
			NT35310_LCD_ShowString(0,0,16, (u8*)clock_buff);
		
			

			
	}
}


/*
函数功能：录音
参    数：录音文件的名称
*/
u8 RecoderPlay(u8 *file_name)
{
	u8 recagc=4,res;											//默认增益为4
	u32 cnt;
	u16 w;
	u32 sectorsize=0;
	u8 recbuf[512];													 //数据内存
	u16 idx=0;
	__WaveHeader wavhead;
	FIL f_rec;															  //录音文件
	VS1053_RecoderInit(1024);			            //激活PCM 录音模式
	VS1053_RecoderWavInit(&wavhead);				  //初始化wav数据	
	res=f_open(&f_rec,(const TCHAR*)file_name, FA_CREATE_ALWAYS | FA_WRITE);  //创建存放录音的文件
	if(res){printf("录音文件创建失败!\r\n");return 0;}
	else printf("录音文件 %s 创建成功!\r\n",file_name);
	res=f_write(&f_rec,(const void*)&wavhead,sizeof(__WaveHeader),&cnt);      //写入头数据		 //写入头数据
	while(1)
	{
			//读取数据			  
			w=VS1053_ReadReg(SPI_HDAT1);	
			if((w>=256)&&(w<896))
			{
				idx=0;				   	 
				while(idx<512) 	//一次读取512字节
				{	 
					w=VS1053_ReadReg(SPI_HDAT0);				   	    
					recbuf[idx++]=w&0XFF;
					recbuf[idx++]=w>>8;
				}	  		 
				res=f_write(&f_rec,recbuf,512,&cnt);//写入文件 ,写入512字节
				if(res)
				{
					printf("写入出错.!\r\n");
					break;  
				}
				sectorsize++;//扇区数增加1,约为32ms	 
			}
      if(VS1053_OK)  //结束录音
			{
					wavhead.riff.ChunkSize=sectorsize*512+36;	//整个文件的大小-8;
					wavhead.data.ChunkSize=sectorsize*512;		//数据大小
					f_lseek(&f_rec,0);							//偏移到文件头.
					f_write(&f_rec,(const void*)&wavhead,sizeof(__WaveHeader),&cnt);//写入头数据
					f_close(&f_rec);
					sectorsize=0;
					printf("结束录音!\r\n");
					break;
			}				
		}	
		
		VS1053_OK=0;
		VS_Start=0;
		return res;
		
}


//播放音频				     	   									    	 
//返回值:0,正常播放完成
u8 VS1053_PlayOneMusic(u8 *pname)
{	 
 	FIL fmp3;
  u16 br;
	u8 res,rval;	  
	u8 databuf[4096];	   		   
	u16 i=0;

	printf("VS1053_Reset=%d\r\n",VS1053_Reset());      								//硬复位MP3
	VS1053_SoftReset(); 								//软复位VS10XX
	VS1053_SetVol(250);								  //设置音量
	
	res=f_open(&fmp3,(const TCHAR*)pname,FA_READ);//打开文件	 
	if(res!=0)return 1;  //文件打开失败 
	printf("%s文件打开成功!\r\n",pname);				   
	while(1)
	{
		res=f_read(&fmp3,databuf,4096,(UINT*)&br);//读出4096个字节  
		i=0;
		while(i<4096) //每次播放4096个字节
		{  	
				if(VS1053_SendMusicData(databuf+i)==0)//给VS10XX发送音频数据
				{
					i+=32;
				}
		}
		if(br!=4096||res!=0)
		{
			rval=0;
			break;//读完了.		  
		} 							 
	}
	f_close(&fmp3);	  
	return rval;	  	 		  	    
}

/*
函数功能：扫描录音根目录
函数返回值：0 表示成功 1：表示失败
*/
u8 ScanVSFile(const char *path)
{
		int i=0;
		DIR dp;
		FRESULT res;
		FILINFO fno; 
		char *abs_path=NULL; 
		/*1.打开目录*/
		res=f_opendir(&dp,path);
		if(res!=FR_OK) return 1;
	
		/*循环读取目录*/
		while(f_readdir(&dp,&fno)==FR_OK)
		{
		
			if(fno.fname[0]==0)break;
			printf("文件名称: %s,文件大小: %ld 字节\r\n",fno.fname,fno.fsize);
			/*2.过滤目录*/
			if(strstr(fno.fname,".wav"))
			{
					
					//申请存放文件名称长度的空间
					abs_path=malloc(strlen(fno.fname)+1);
			 
					if(abs_path==NULL)break;
			
					strcpy(abs_path,fno.fname);
					VS1053_FileBuff[i++]=(u8*)abs_path;
					if(i>10)i=0;
				
		   }
	}
				f_closedir(&dp);
				return 0;
}
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "LCD1602.h"
#include "usart2.h"
#include "AS608.h"
#include "timer.h"
#include "beep.h"
#include "rtc.h"
#include "date.h"
#include "stm32f10x.h"
#include "stm32f10x_rtc.h"
#include "AT24CXX.h"
#include "iic.h"

#define usart2_baund  57600//串口2波特率，根据指纹模块波特率更改（注意：指纹模块默认57600）
SysPara AS608Para;//指纹模块AS608参数
u16 ValidN;//模块内有效模板个数
u8** kbd_tbl;

u32 timedata=0;

void Add_FR(u8 a);	//录指纹
void Del_FR(u8 a);	//删除指纹
void press_FR(void);//刷指纹
void ShowErrMessage(u8 ensure);//显示确认码错误信息

int d=0;  //删除指纹时用的ID参数
int get_d=0;  //返回给QT得指纹ID

u8 num = 1; //注册ID
u8 num_24C02 = 0; //保存地址

int KeyVal;	 //keyVal?????????
int key_number = 0; 
struct rtc_time systmtime;	

unsigned char pass[6] = {1,2,3,4,5,6};
unsigned char in_key[6];			//输入密码

u16 nao_hour_start = 0;
u16 nao_min_start = 0;

u16 nao_hour_stop = 0;
u16 nao_min_stop = 0;

u8 number = 0; //指纹编号
void GPIO_Configuration(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;
  	
	SystemInit();

	//GPIO输入配置
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);

	GPIO_InitStructure.GPIO_Pin= GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_9|GPIO_Pin_10;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING;
//	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_Init(GPIOA,&GPIO_InitStructure);
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);	
	GPIO_InitStructure.GPIO_Pin= GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_Init(GPIOA,&GPIO_InitStructure);
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);	
	GPIO_InitStructure.GPIO_Pin= GPIO_Pin_0;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_Init(GPIOB,&GPIO_InitStructure);
}

int key_down(void)  //???????????,??????,???????????
{
	KeyVal = 99;

	GPIO_ResetBits(GPIOA,GPIO_Pin_7); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_6); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_5); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_4); //????? 

	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9)==0)
	{
		 KeyVal = 15;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10)==0)
	{
		 KeyVal = 14;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1)==0)
	{
		 KeyVal = 13;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)==0)
	{
		 KeyVal = 12;
	}

	GPIO_SetBits(GPIOA,GPIO_Pin_7); //????? 
	GPIO_ResetBits(GPIOA,GPIO_Pin_6); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_5); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_4); //????? 

	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9)==0)
	{
		 KeyVal = 11;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10)==0)
	{
		 KeyVal = 10;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1)==0)
	{
		 KeyVal = 9;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)==0)
	{
		 KeyVal = 8;
	}

	GPIO_SetBits(GPIOA,GPIO_Pin_7); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_6); //????? 
	GPIO_ResetBits(GPIOA,GPIO_Pin_5); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_4); //????? 

	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9)==0)
	{
		 KeyVal = 7;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10)==0)
	{
		 KeyVal = 6;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1)==0)
	{
		 KeyVal = 5;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)==0)
	{
		 KeyVal = 4;
	}

	GPIO_SetBits(GPIOA,GPIO_Pin_7); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_6); //????? 
	GPIO_SetBits(GPIOA,GPIO_Pin_5); //????? 
	GPIO_ResetBits(GPIOA,GPIO_Pin_4); //????? 

	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9)==0)
	{
		 KeyVal = 3;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10)==0)
	{
		 KeyVal = 2;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1)==0)
	{
		 KeyVal = 1;
	}
	else if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)==0)
	{
		 KeyVal = 0;
	}
//	GPIO_Write(GPIOA,(GPIOA->ODR & 0xff0f | 0x00f0)); //?PB8?PB11?????,???????????
//	while((GPIOA->IDR & 0x000f) != 0x0000);        //??????????
	if(KeyVal!=99)
	{
		GPIO_SetBits(GPIOB,GPIO_Pin_0); //????? 
		delay_ms(200); 
		GPIO_ResetBits(GPIOB,GPIO_Pin_0); //????? 
		switch(KeyVal)
		{	
			case 0:	 KeyVal = 12;
				break;
			case 1:	 KeyVal = 3;
				break;
			case 2:	 KeyVal = 2;
				break;
			case 3:	 KeyVal = 1;
				break;
			case 4:	 KeyVal = 13;
				break;
			case 5:	 KeyVal = 6;	
				break;		 	
			case 6:	 KeyVal = 5;
				break;
			case 7:	 KeyVal = 4;
				break;
			case 8:	 KeyVal = 14;
				break;
			case 9:	 KeyVal = 9;
				break;		  
			case 10: KeyVal = 8;
				break;
			case 11: KeyVal = 7;
				break;
			case 12: KeyVal = 15;
				break;
			case 13: KeyVal = 11;
				break;
			case 14: KeyVal = 0;
				break;
			case 15: KeyVal = 10;
				break;
		}
	}
	return KeyVal;		
}

//修改时间
void RTC_TimeAdjust(void)
{
  /* Wait until last write operation on RTC registers has finished */
  RTC_WaitForLastTask();

  RTC_SetCounter(mktimev(&systmtime));
  /* Wait until last write operation on RTC registers has finished */
  RTC_WaitForLastTask();
}


void set_time()
{
	int time_flag =0; 			//????????

			//?
					
			LCD_Write_Com(0x80); 
			LCD_Write_Data(systmtime.tm_year/1000+'0');
			LCD_Write_Data((systmtime.tm_year%1000)/100+'0');
			LCD_Write_Data(systmtime.tm_year%100/10+'0');
			LCD_Write_Data(systmtime.tm_year%10+'0');   //?lcd1602????

			time_flag =0; 
			for(;;)
			{				
				LCD_Write_Com(0x80);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_year = time_flag*1000;
					break;
				}	
		   }
			
			for(;;)
			{
				LCD_Write_Com(0x81);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_year += time_flag*100;
					break;
				}	
			}

			for(;;)
			{
				LCD_Write_Com(0x82);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_year += time_flag*10;
					break;
				}	
			}

			for(;;)
			{
				LCD_Write_Com(0x83);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_year += time_flag;

					if(systmtime.tm_year>=2099)	   //?????
						systmtime.tm_year = 2099;
					else if(systmtime.tm_year<=1970)
						systmtime.tm_year = 1970;	
					break;
				}	
			}
			//?
			LCD_Write_Com(0x85);  //????
			LCD_Write_Data(systmtime.tm_mon%100/10+'0');
			LCD_Write_Data(systmtime.tm_mon%10+'0');   //?lcd1602????

			for(;;)
			{
				LCD_Write_Com(0x85);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	

				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_mon = time_flag * 10;
					break;
				}	
			}
			//time_flag = Time_1[4]&0x0f;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0x86);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_mon += time_flag;
					if(systmtime.tm_mon>=12)	   //???
						systmtime.tm_mon = 12;
					break;
				}	
			}

			LCD_Write_Com(0x88);  //????
			LCD_Write_Data(systmtime.tm_mday%100/10+'0');
			LCD_Write_Data(systmtime.tm_mday%10+'0');   //?lcd1602????
			//?
			time_flag = systmtime.tm_mday;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0x88);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	

				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_mday = time_flag * 10;
					break;
				}	
			}


			//time_flag = Time_1[4]&0x0f;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0x89);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(key_number + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_mday += time_flag;
					if(systmtime.tm_mday>=31)	   //???
						systmtime.tm_mday = 31;
					break;
				}	
			}

			//?
			LCD_Write_Com(0xc2);  //????
			LCD_Write_Data(systmtime.tm_hour%100/10+'0');
			LCD_Write_Data(systmtime.tm_hour%10+'0');   //?lcd1602????
			for(;;)
			{
				LCD_Write_Com(0xc2);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	

				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_hour = time_flag * 10;
					break;
				}	
			}
			//time_flag = Time_1[4]&0x0f;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0xc3);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_hour += time_flag;
					if(systmtime.tm_hour>=23)	   //????
						systmtime.tm_hour = 23;
					break;
				}	
			}


			//?
			LCD_Write_Com(0xc5);  //????
			LCD_Write_Data(systmtime.tm_min%100/10+'0');
			LCD_Write_Data(systmtime.tm_min%10+'0');   //?lcd1602????
			for(;;)
			{
				LCD_Write_Com(0xc5);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	

				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_min = time_flag * 10;

					break;
				}	
			}
			//time_flag = Time_1[4]&0x0f;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0xc6);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_min+= time_flag;
					if(systmtime.tm_min>=59)	   //????
						systmtime.tm_min = 59;
					break;
				}	
			}
			//sec
			LCD_Write_Com(0xc8);  //????
			LCD_Write_Data(systmtime.tm_sec%100/10+'0');
			LCD_Write_Data(systmtime.tm_sec%10+'0');   //?lcd1602????
			for(;;)
			{
				LCD_Write_Com(0xc8);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	

				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_sec = time_flag * 10;
					break;
				}	
			}
			//time_flag = Time_1[4]&0x0f;		//??DS1302 ????
			for(;;)
			{
				LCD_Write_Com(0xc9);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_sec+= time_flag;
					if(systmtime.tm_sec>=59)	   //???
						systmtime.tm_sec = 59;
					break;
				}	
			}

			//xing?
			LCD_Write_Com(0xc0);  //????
			LCD_Write_Data(systmtime.tm_wday%10+'0');   //?lcd1602????
			for(;;)
			{
				LCD_Write_Com(0xc0);  //????	 
				LCD_Write_Com(0x0e);  //??
				delay_ms(200);	
				LCD_Write_Com(0x0c);  //??	
				key_number = key_down();	  //????
				
				if(key_number<=9)	
				{
					time_flag = key_number;
					LCD_Write_Data(time_flag + '0');
				}
				else if(key_number==11) //#??
				{
					systmtime.tm_wday = time_flag;
					if(systmtime.tm_wday>=7)	   //????
						systmtime.tm_wday = 7;
					break;
				}	
			}
				
			RTC_TimeAdjust();//????
}
void set_nao()
{

	int time_flag =0; 			//????????

		LCD_Write_Com(0x8b);
		LCD_Write_Data('0'+ nao_hour_start/10);
		LCD_Write_Data('0'+ nao_hour_start%10);
		LCD_Write_Data(':');
		LCD_Write_Data('0'+ nao_min_start/10);
		LCD_Write_Data('0'+ nao_min_start%10);
		delay_ms(200);	

				
		for(;;)		 //???? ??
		{

			key_number = key_down();	  //????
			LCD_Write_Com(0x8b);  //????	 
			LCD_Write_Com(0x0e);  //??
			delay_ms(200);	
			LCD_Write_Com(0x0c);  //??
			if(key_number<=9)
			{
				time_flag =  key_number;
				LCD_Write_Com(0x8b);
				LCD_Write_Data('0'+ time_flag);
			}
			else if(key_number==11) //#?? ??
			{
				nao_hour_start = 	time_flag*10;
				break;
			}
		}

		for(;;)		 //???? ??
		{

			key_number = key_down();	  //????
			LCD_Write_Com(0x8c);  //????	 
			LCD_Write_Com(0x0e);  //??
			delay_ms(200);	
			LCD_Write_Com(0x0c);  //??
			if(key_number<=9)
			{
				time_flag =  key_number;
				LCD_Write_Com(0x8c);
				LCD_Write_Data('0'+ time_flag);
			}
			else if(key_number==11) //#?? ??
			{
				nao_hour_start += time_flag;
				if(nao_hour_start>=23)	   //??????
					nao_hour_start = 23;
				break;
			}
		}

//		for(;;)		 //??miao
//		{

//			key_number = key_down();	  //????
//			LCD_Write_Com(0x8e);  //????	 
//			LCD_Write_Com(0x0e);  //??
//			delay_ms(200);	
//			LCD_Write_Com(0x0c);  //??
//			if(key_number<=9)
//			{					
//				time_flag =  key_number;
//				LCD_Write_Com(0x8e);
//				LCD_Write_Data('0'+ time_flag);
//			}
//			else if(key_number==11) //#?? ??
//			{
//				nao_min_start = 	time_flag*10;
//				break;
//			}
//		}

//		for(;;)		 //??? ??
//		{

//			key_number = key_down();	  //????
//			LCD_Write_Com(0x8f);  //????	 
//			LCD_Write_Com(0x0e);  //??
//			delay_ms(200);	
//			LCD_Write_Com(0x0c);  //??
//			if(key_number<=9)
//			{
//				time_flag =  key_number;
//				LCD_Write_Com(0x8f);
//				LCD_Write_Data('0'+ time_flag);
//			}
//			else if(key_number==11) //#?? ??
//			{
//				nao_min_start += time_flag;
//				if(nao_min_start>=59)	   //??????
//					nao_min_start = 59;
//				break;
//			}
//		}
//		

		LCD_Write_Com(0xcb);
		LCD_Write_Data('0'+ nao_hour_stop/10);
		LCD_Write_Data('0'+ nao_hour_stop%10);
		LCD_Write_Data(':');
		LCD_Write_Data('0'+ nao_min_stop/10);
		LCD_Write_Data('0'+ nao_min_stop%10);
		delay_ms(200);	

				
		for(;;)		 //???? ??
		{

			key_number = key_down();	  //????
			LCD_Write_Com(0xcb);  //????	 
			LCD_Write_Com(0x0e);  //??
			delay_ms(200);	
			LCD_Write_Com(0x0c);  //??
			if(key_number<=9)
			{
				time_flag =  key_number;
				LCD_Write_Com(0xcb);
				LCD_Write_Data('0'+ time_flag);
			}
			else if(key_number==11) //#?? ??
			{
				nao_hour_stop = 	time_flag*10;
				break;
			}
		}

		for(;;)		 //???? ??
		{

			key_number = key_down();	  //????
			LCD_Write_Com(0xcc);  //????	 
			LCD_Write_Com(0x0e);  //??
			delay_ms(200);	
			LCD_Write_Com(0x0c);  //??
			if(key_number<=9)
			{
				time_flag =  key_number;
				LCD_Write_Com(0xcc);
				LCD_Write_Data('0'+ time_flag);
			}
			else if(key_number==11) //#?? ??
			{
				nao_hour_stop += time_flag;
				if(nao_hour_stop>=23)	   //??????
					nao_hour_stop = 23;
				break;
			}
		}

//		for(;;)		 //??miao
//		{

//			key_number = key_down();	  //????
//			LCD_Write_Com(0xce);  //????	 
//			LCD_Write_Com(0x0e);  //??
//			delay_ms(200);	
//			LCD_Write_Com(0x0c);  //??
//			if(key_number<=9)
//			{					
//				time_flag =  key_number;
//				LCD_Write_Com(0xce);
//				LCD_Write_Data('0'+ time_flag);
//			}
//			else if(key_number==11) //#?? ??
//			{
//				nao_min_stop = 	time_flag*10;
//				break;
//			}
//		}

//		for(;;)		 //??? ??
//		{

//			key_number = key_down();	  //????
//			LCD_Write_Com(0xcf);  //????	 
//			LCD_Write_Com(0x0e);  //??
//			delay_ms(200);	
//			LCD_Write_Com(0x0c);  //??
//			if(key_number<=9)
//			{
//				time_flag =  key_number;
//				LCD_Write_Com(0xcf);
//				LCD_Write_Data('0'+ time_flag);
//			}
//			else if(key_number==11) //#?? ??
//			{
//				nao_min_stop += time_flag;
//				if(nao_min_stop>=59)	   //??????
//					nao_min_stop = 59;
//				break;
//			}
//		}
}


//蜂鸣器响一声
void beep()
{
		 GPIO_SetBits(GPIOB,GPIO_Pin_0); //蜂鸣器报警
		 delay_ms(200); 			//延时200ms
		 GPIO_ResetBits(GPIOB,GPIO_Pin_0);
		 delay_ms(200); 			//延时200ms			
}


void set_number()
{
	  char num_flag = 0;
	 	LCD_Write_Com(0xc0);  //??
		LCD_Write_Data('N');
		LCD_Write_Data('u');
		LCD_Write_Data('m');
		LCD_Write_Data('b');
		LCD_Write_Data('e');
		LCD_Write_Data('r');
		LCD_Write_Data(' ');
		LCD_Write_Data('>');
		LCD_Write_Data('0'+number%100/10);
		LCD_Write_Data('0'+number%10);			

	for(;;)
	{
		key_number = key_down();	  //????
		LCD_Write_Com(0xc8);  //????	 
		LCD_Write_Com(0x0e);  //??
		delay_ms(100); 
		LCD_Write_Com(0x0c);  //??	
     delay_ms(100); 		
		if(key_number <= 9)   //????????
		{  
			 num_flag =  key_number;
			 LCD_Write_Com(0xc8);  //????
			 LCD_Write_Data('0'+key_number);
		}
		if(key_number==11) //#??
		{
			 number = num_flag*10;
			 break;
		}
	}

	for(;;)
	{
			key_number = key_down();	  //????
			LCD_Write_Com(0xc9);  //????	 
			LCD_Write_Com(0x0e);  //??
			delay_ms(100); 
			LCD_Write_Com(0x0c);  //??	
			delay_ms(100); 		
		
			if(key_number <= 9)   //????????
			{  
				 num_flag =  key_number;
				 LCD_Write_Com(0xc9);  //????
				 LCD_Write_Data('0'+key_number);
			}
			if(key_number==11) //#??
			{
				 number += num_flag;
				 break;
			}
	}

	LCD_Write_Com(0x01); 
}

void set_zhuce(u8 a)
{
		if(a==0)
		{
				
			LCD_Write_Com(0x80);  
			LCD_Write_Data('z');
			LCD_Write_Data('h');
			LCD_Write_Data('u');
			LCD_Write_Data(' ');
			LCD_Write_Data('c');
			LCD_Write_Data('e');
			
		}
		else if(a==1)
		{
			LCD_Write_Com(0x80);  
			LCD_Write_Data('D');
			LCD_Write_Data('e');
			LCD_Write_Data('l');
			LCD_Write_Data('e');
			LCD_Write_Data('t');
			LCD_Write_Data('e');
		}	
		set_number();
}


void time_display()
{

	LCD_Write_Com(0x80);  //LCD1602??????
	LCD_Write_Data('0' + (systmtime.tm_year%10000)/1000);
	LCD_Write_Data('0' + (systmtime.tm_year%1000)/100);
	LCD_Write_Data('0'+(systmtime.tm_year%100)/10);
	LCD_Write_Data('0'+systmtime.tm_year%10);
	LCD_Write_Data('-');
	LCD_Write_Data('0'+systmtime.tm_mon/10);
	LCD_Write_Data('0'+systmtime.tm_mon%10);
	LCD_Write_Data('-');
	LCD_Write_Data('0'+systmtime.tm_mday/10);
	LCD_Write_Data('0'+systmtime.tm_mday%10);
	LCD_Write_Data(' ');	

							
	LCD_Write_Com(0xC0);	//LCD1602
	if(systmtime.tm_wday==0)
	{
			LCD_Write_Data('7');
	}
	else
	{
			LCD_Write_Data('0'+ systmtime.tm_wday);
	}
	LCD_Write_Data(' ');
	LCD_Write_Data('0'+systmtime.tm_hour/10);
	LCD_Write_Data('0'+systmtime.tm_hour%10);
	LCD_Write_Data(':');
	LCD_Write_Data('0'+systmtime.tm_min/10);
	LCD_Write_Data('0'+systmtime.tm_min%10);
	LCD_Write_Data(':');
	LCD_Write_Data('0'+systmtime.tm_sec/10);
	LCD_Write_Data('0'+systmtime.tm_sec%10);
	LCD_Write_Data(' ');

}


void RTC_IRQHandler()	//RTC实时时钟
{
	if(RTC_GetITStatus((RTC_IT_SEC))!=RESET)
	{
		RTC_ClearITPendingBit(RTC_IT_SEC);
		timebz=1;	
	}
}

//读取24c02存储信息
void read_24C02()				 //??24C02????
{
	u8 i = 0; //??for循环
	u8 read_num = 0;
	for(i=0;i<10;i++)
	{
	 	systmtime.tm_year = At24c02Read(0 + 8*i)+1970;	delay_ms(1);	
		systmtime.tm_wday = At24c02Read(1 + 8*i);	delay_ms(1);	
		systmtime.tm_mon = At24c02Read(2 + 8*i);		delay_ms(1);	
		systmtime.tm_mday= At24c02Read(3 + 8*i);	delay_ms(1);	
		systmtime.tm_hour = At24c02Read(4 + 8*i);	delay_ms(1);		
		systmtime.tm_min = At24c02Read(5 + 8*i);	delay_ms(1);	
		systmtime.tm_sec = At24c02Read(6 + 8*i);	delay_ms(1);	
		read_num = At24c02Read(7 + 8*i);	delay_ms(1);		
		time_display();
	 	LCD_Write_Com(0x8c);
		LCD_Write_Data('0'+i%10);
		LCD_Write_Data(' ');
	 	LCD_Write_Data(' ');
	 	LCD_Write_Com(0xcc);
		LCD_Write_Data('0'+ read_num/10);
		LCD_Write_Data('0'+ read_num%10);
		if(systmtime.tm_hour<nao_hour_start)
		{
			LCD_Write_Com(0x8F);	//LCD1602
			LCD_Write_Data('A');						
		}
		else if((systmtime.tm_hour>=nao_hour_start)&&(systmtime.tm_hour<12))
		{
			LCD_Write_Com(0x8F);	//LCD1602
			LCD_Write_Data('B');						
		}
		else if((systmtime.tm_hour<nao_hour_stop)&&(systmtime.tm_hour>=12))
		{
			LCD_Write_Com(0x8F);	//LCD1602
			LCD_Write_Data('C');						
		}		
		else
		{
			LCD_Write_Com(0x8F);	//LCD1602
			LCD_Write_Data('D');						
		}
		delay_ms(1000);
		delay_ms(1000);
	}
	LCD_1602Clear(); //清屏
}

void Save_24C02(u8 a)
{
	 At24c02Write(0 + 8*num_24C02,(systmtime.tm_year-1970));
	 delay_ms(1);	
	 At24c02Write(1 + 8*num_24C02,systmtime.tm_wday);delay_ms(1);	
	 At24c02Write(2 + 8*num_24C02,systmtime.tm_mon);delay_ms(1);	
	 At24c02Write(3 + 8*num_24C02,systmtime.tm_mday);delay_ms(1);	
	 At24c02Write(4 + 8*num_24C02,systmtime.tm_hour);delay_ms(1);	
	 At24c02Write(5 + 8*num_24C02,systmtime.tm_min);delay_ms(1);	
	 At24c02Write(6 + 8*num_24C02,systmtime.tm_sec);delay_ms(1);	
	 At24c02Write(7 + 8*num_24C02,a);delay_ms(1);	

	 num_24C02++;
	 if(num_24C02>=10)
	 	num_24C02 = 0;
}

//ems????
void ems_diaplay()
{
	LCD_1602Clear();  //??

	LCD_Write_Com(0xc0);
	LCD_Write_Data('I'); 
	LCD_Write_Data('N');  
	LCD_Write_Data('P');
	LCD_Write_Data('U');  
	LCD_Write_Data('T');
	LCD_Write_Data(':'); 
}

void input_pass()
{
	 unsigned char x=0,z=0,y=0;
	 
	 ems_diaplay();
	 for(;;)
	 {

		key_number = key_down();  //????

		if(key_number <= 9)   //????????
		{  			
			LCD_Write_Com(0xc6 + z);
			LCD_Write_Data('*'); 	//acsii??*?	 
		  	in_key[z] = key_number;		//????
			z++;
		}
		
		if(key_number == 11)			 //????
		{
			for(x=0;x<6;x++)
			{
				if(pass[x] == in_key[x])
					y++;
			}
			break;	//??????
		}
	 }
	 if(y>=6)  	//????????;
	 {	 
			LCD_1602Clear();
			for(;;)
		  {
				LCD_Write_Com(0xc0);
				LCD_Write_Data('V'); 
				LCD_Write_Data('I');  
				LCD_Write_Data('P');
				LCD_Write_Data(':');  
				LCD_Write_Data(' ');
				LCD_Write_Data(' '); 
					key_number = key_down();  //读取按键
					if(key_number==10)
					{
							break;
					}
					else if(key_number==11)
					{
							time_display(); //显示时间
							set_time(); //设置系统时间
						  LCD_1602Clear();
					}
					else if(key_number==12) //注册指纹
					{	    
							LCD_1602Clear();	//清屏
							set_zhuce(0);
							Add_FR(number);		//录指纹	
							LCD_1602Clear();
					}
					else if(key_number==13)  //删除指纹
					{
						LCD_1602Clear();	//清屏
						set_zhuce(1);
						Del_FR(number);	 //删除指纹
						LCD_1602Clear();
					}
					else if(key_number==14) 
					{
							read_24C02();
						  LCD_1602Clear();
					}
					else if(key_number==15) 
					{
							set_nao();   //设置定时
							LCD_1602Clear();
					}
			}	

	 }

}



int main(void)
{		
 
	u8 ensure;
	delay_init();

	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置系统中断优先级分组2

	//uart_init(115200);	//初始化串口1波特率为115200，用于支持USMART

	usart2_init(usart2_baund);//初始化串口2,用于与指纹模块通讯
	
	clockinit_RTC();  //初始化RTC时钟
	
	LCD_1602Init();  //初始化lcd1602
	
	PS_StaGPIO_Init();	//初始化FR读状态引脚
	
	GPIO_Configuration(); //初始化GPIO
	
	I2C_INIT();		 //IIC初始化
	
	while(PS_HandShake(&AS608Addr))//与AS608模块握手
	{
//		printf("Cannot connect with AS608!"); 
		delay_ms(200);
	//  printf("Try to connect again....");		
		delay_ms(200);	  
	}
	
  // printf("\n通讯成功\n");

	ensure=PS_ValidTempleteNum(&ValidN);//读库指纹个数
	
//	if(ensure!=0x00)
//		 printf("错误");
		  
	ensure=PS_ReadSysPara(&AS608Para);  //读AS608模块参数 

//	d = 1;			
//	printf("当前输入的id为 %d\n",d);

	//Del_FR();						
	while(1)
	{			
			
			key_number = key_down();  //读取按键

			if(key_number==10)  
			{
					input_pass();  
				  LCD_1602Clear();	//清屏
			}

			if(timebz==1)	   //时钟秒中断
			{
					timebz=0;	  //清零

					timedata=RTC_GetCounter();//获取RTC计数器的值

					to_tm(timedata, &systmtime); //时间转换
					
					time_display(); //显示时间
			}

			if(PS_Sta)	 //检测PS_Sta状态，如果有手指按下
			{
					press_FR();//刷指纹		
			}		
				
			delay_ms(100);	

		}		 
	} 	


//显示确认码错误信息
void ShowErrMessage(u8 ensure)
{  	
//	printf("错误信息 ");

}

//录指纹
void Add_FR(u8 a)
{
	u8 i=0,ensure ,processnum=0;
	u16 ID;
	
	while(1)
	{  
			delay_ms(50);	
		switch (processnum)
		{
			case 0:
				i++;
		   //	printf("请按手指\n");
			 
			  delay_ms(50);
				ensure=PS_GetImage();
				if(ensure==0x00) 
				{	delay_ms(50);	
					ensure=PS_GenChar(CharBuffer1);//生成特征
					if(ensure==0x00)
					{ delay_ms(50);
						//printf("指纹正确\n");
						beep();
						i=0;
						delay_ms(50);
						processnum=1;//跳到第二步						
					}else ShowErrMessage(ensure);	
	      delay_ms(50);						
				}else ShowErrMessage(ensure);		
	      delay_ms(50);					
				break;
			
			case 1:
				i++;
				//printf("再按一次手指\n");//
			  
			 delay_ms(50);
				ensure=PS_GetImage();
				if(ensure==0x00) 
				{   	delay_ms(50);	
					ensure=PS_GenChar(CharBuffer2);//生成特征			
					if(ensure==0x00)
					{ 	delay_ms(50);	
					//	printf("指纹正确\n");
	        
						i=0;
						processnum=2;//跳到第三步
					}else ShowErrMessage(ensure);	
						delay_ms(50);	
				}else ShowErrMessage(ensure);		
					delay_ms(50);	
				break;

			case 2:
				//printf("对比两次指纹\n");//
					  
				ensure=PS_Match();
				if(ensure==0x00) 
				{	delay_ms(50);	
					//printf("两次指纹是一样的\n");//
					beep();beep();  
					processnum=3;//跳到第四步
				}
				else 
				{  
  					delay_ms(50);	
				//	 printf("对比失败，请重新按手指\n");//
					
					ShowErrMessage(ensure);
					i=0;
					processnum=0;//跳回第一步		
				}
				delay_ms(1000);
				break;

			case 3:
				//printf("产生一个指纹模板\n");//
			
				ensure=PS_RegModel();
				if(ensure==0x00) 
				{	delay_ms(50);	 
			//		printf("生成指纹模板成功\n");//
									
					processnum=4;//跳到第五步
				}else {processnum=0;ShowErrMessage(ensure);}
				delay_ms(500);
				break;
				
			case 4:	
		
				do
				{	
					PS_ValidTempleteNum(&ValidN);//读库指纹个数
					ID = a;
					delay_ms(50);
				}
				while(!(ID<300));//输入DI必须小于300
				ensure=PS_StoreChar(CharBuffer2,ID);//储存模板
				delay_ms(50);
				if(ensure==0x00) 
				{			
					delay_ms(50);
			//		printf("添加指纹成功\n");//
					PS_ValidTempleteNum(&ValidN);//读库指纹个数
					d=0;
					delay_ms(50);
				//	printf("剩余指纹个数  %d  \n",AS608Para.PS_max-ValidN);				
					 delay_ms(500);			
					beep();beep();beep();
					return ;
				}else {processnum=0;ShowErrMessage(ensure);}					
				break;				
		}
		delay_ms(800);
		if(i==5)//超过5次没有按手指则退出
		{
      // printf("添加指纹失败\n");
			break;	
		}				
	}
}
//刷指纹
void press_FR(void)
{
	SearchResult seach;
	u8 ensure;

	ensure=PS_GetImage();
	if(ensure==0x00)//获取图像成功 
	{	
		
		ensure=PS_GenChar(CharBuffer1);
		//printf("获取图像成功 \n");
		if(ensure==0x00) //生成特征成功
		{	
			
			//printf("获取图像成功 \n");
			ensure=PS_HighSpeedSearch(CharBuffer1,0,300,&seach);
			if(ensure==0x00)//搜索成功
			{			
			//	printf("搜索指纹成功\n ");//搜索指纹成功	

				get_d = seach.pageID;	
			//	printf(" 匹配指纹的ID%d\n",get_d);
				LCD_Write_Com(0x8C);	//LCD1602
				LCD_Write_Data('O');
				LCD_Write_Data('K');				
				
				if(systmtime.tm_hour<nao_hour_start)
				{
					LCD_Write_Com(0x8F);	//LCD1602
					LCD_Write_Data('A');						
				}
				else if((systmtime.tm_hour>=nao_hour_start)&&(systmtime.tm_hour<12))
				{
					LCD_Write_Com(0x8F);	//LCD1602
					LCD_Write_Data('B');						
				}
				else if((systmtime.tm_hour<nao_hour_stop)&&(systmtime.tm_hour>=12))
				{
					LCD_Write_Com(0x8F);	//LCD1602
					LCD_Write_Data('C');						
				}		
				else
				{
					LCD_Write_Com(0x8F);	//LCD1602
					LCD_Write_Data('D');						
				}
				
				LCD_Write_Com(0xCC);	//LCD1602
				LCD_Write_Data('0'+ get_d/10);
				LCD_Write_Data('0'+ get_d%10);
				Save_24C02(get_d); //保存地址
				beep();
				delay_ms(1000);
				delay_ms(1000);
				LCD_Write_Com(0xCC);	//LCD1602
				LCD_Write_Data(' ');
				LCD_Write_Data(' ');
				LCD_Write_Com(0x8C);	//LCD1602
				LCD_Write_Data(' ');
				LCD_Write_Data(' ');
				LCD_Write_Data(' ');
				LCD_Write_Data(' ');
			}
			else 
			{				
					LCD_Write_Com(0x8b);	//LCD1602
					LCD_Write_Data('E');
					LCD_Write_Data('R');	
				  LCD_Write_Data('R');
				  LCD_Write_Data('O');
				  LCD_Write_Data('R');
					beep();beep();beep();//蜂鸣器响3下
					LCD_Write_Com(0x8b);	//LCD1602
					LCD_Write_Data(' ');
					LCD_Write_Data(' ');	
				  LCD_Write_Data(' ');
				  LCD_Write_Data(' ');
				  LCD_Write_Data(' ');
			}
			//	printf("失败AA\n ");		
	   delay_ms(50);			
	  }
		else
			//printf("失败BB\n ");	
			delay_ms(50);

	}
		
}

//删除指纹
void Del_FR(u8 a)
{
	u8  ensure;
  int v;
   PS_ValidTempleteNum(&ValidN);//读库指纹个数
			v=ValidN;		 
		ensure=PS_DeletChar(a,1);//删除单个指纹 
	  PS_ValidTempleteNum(&ValidN);//读库指纹个数
	if(ensure==0&&v==ValidN+1)
	{
		     // printf("删除成功"); 
	}
  else
	{	
		ShowErrMessage(ensure);	
   // printf("删除失败"); 

	}       
}



/**
  ******************************************************************************
  * @file    main.c
  * @author  pcf
  * @version V4.0
  * @date    2018-4-23
  * @brief   智能手环
  ******************************************************************************
  */ 

#include "stm32f10x.h"
#include "led.h"
#include "bsp_exti.h"
#include "delay.h"
#include "GY-MCU90615.h"
#include "OLED_I2C.h"
#include "bsp_adc.h"
#include "bsp_TiMbase.h" 
#include "Step_Num.h"
#include "./mpu6050/mpu6050.h"
#include "bsp_GeneralTim.h" 

extern int LED_SIGN;							//功能切换标志	
float ADC_ConvertedValueLocal; 			// 局部变量，用于保存转换计算后的电压值 	 
extern __IO unsigned char QS;       	// 当发现一个节拍时，变为真
int sign1=0, sign2=0;
/**
  * @brief  主函数
  * @param  无
  * @retval 无
  */ 
int main(void)
{
	int i = 0;
	/*系统时钟设置*/
	delay_init(72);
	
	/* LED 端口初始化 */
	LED_Init();

	/*初始化串口一，用于温度检测（接收数据）*/ 	
	Usart1_Int(115200);

	/*配置IIC1，用于OLED显示屏*/
	I2C_Configuration();	

	/*初始化OLED*/
	OLED_Init();											
	
	MPU6050_Init();
	
	/*等待模块初始化完成*/
	delay_ms(1);

	/*开机显示*/
	LED_ON;
	for(i=0;i<4;i++)
	{
		OLED_ShowCN(22+i*16,3,i);									//测试显示"智能手环"
	}
	delay_ms(3000);
	OLED_Fill(0x00);	//全屏灭
	
	
	/*外部中断初始化，用于功能切换*/
	EXTI_Key_Config(); 
	
	/*ADC 初始化*/ 
	ADCx_Init();
	
	/*定时器初始化*/
	BASIC_TIM_Init();
	
	GENERAL_TIM_Init();	

	LED_OFF;
	/* 等待中断，由于使用中断方式，CPU不用轮询按键 */
	while(1)                            
	{
		switch(LED_SIGN%4)
		{
			/*初始状态*/
			case 0 :
				LED_OFF;
				OLED_Fill(0x00);	//全屏灭
				break;
			/*功能1：测量体表温度*/
			case 1 :
				send_com(0x15);				//发送命令
				delay_ms(1000); 				//等待命令接收完毕
				temp_float();					//数据转换
				OLED_Display_Temp();			//显示读取的温度
				break;
			/*功能2：测量心率*/
			case 2 :
				if (sign1 ==0)
				{
					OLED_Fill(0x00);	//全屏灭
//					delay_ms(100); 
				}
				if (QS == 1)
				{
					sign1 = 1;
					
					OLED_Display_HeareRate();
					delay_ms(1000); 				//等待命令接收完毕
					QS = 0;                    // 下次重新设置量化的自我标志
				}
				break;
			/*功能3：计步*/
			case 3 :
				
				if (sign2 == 0)
				{
					OLED_Fill(0x00);	//全屏灭
//					delay_ms(100); 
				}
				sign2 = 1;
				OLED_Display_StepNumber();
				delay_ms(1000);
				break;
		}
		
	}
}
/*********************************************END OF FILE**********************/
#include "led.h"
#include "delay.h"
#include "sys.h"
#include "usart.h"
#include "oled.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "adc.h"
#include "DHT11.h"
extern u8 hum_set;


 int main(void)
 { 
	volatile u16 adcx;
	u8 temp,hum,buf[20],buf1[20],times;
	delay_init();	    	 //延时函数初始化	  
	uart_init(9600);	 	//串口初始化为9600
    OLED_Init();  //oled超舒适化  PB 3,4,5,6
    DHT11_Init();  //PB 0
    Adc_Init();  //PA1
    Relay_Init();// PB 12,13
	memset(buf,0,16);
    memset(buf1,0,16);
    Relay_Init(); 
	while(1)
	{
    
           // Relay=1;
     	adcx=Get_Adc_Average(ADC_Channel_3,10);
	    if(times>3)
        {
            times=0;
            DHT11_Read_Data(&temp,&hum);
            sprintf( buf,"T %d -- H %d",temp,hum-30);
            OLED_ShowString(5,0,buf); 
            sprintf(buf,"ADC %d ",adcx);
            OLED_ShowString(5,20,buf);
            memset(buf,0,16);            
            OLED_Refresh_Gram();	 
                    //显示数据
        }
        if(hum_set>0)
        {
             if(adcx>1800+((100-hum_set)*23))  //1800  说明实测一般adc 在1800 水分充足
            {
                Relay=0; 
                Beep=1;       //蜂鸣器 和继电器共用一个IO
            }else
            {
                Relay=1;
                Beep=0;
              
            }
        }
        delay_ms(1000);
        
        times++;
	}						
 
}
					    
#include "led.h"
#include "delay.h"
#include "sys.h"
#include "usart.h"
#include "oled.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "scan.h"
extern u8 hum_set,Is_Ture;
u8 out_state[3];

/*
         1.显示三路超声波的距离
         2.第二屏幕设置 报警距离
*/
void Targ_GPIO()
{
    GPIO_InitTypeDef  GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_10|GPIO_Pin_1;	 //PD3,PD6推挽输出  
 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//速度50MHz
 	GPIO_Init(GPIOB, &GPIO_InitStructure);	  //初始化GPIOD3,6
    
 	GPIO_ResetBits(GPIOB,GPIO_Pin_0|GPIO_Pin_10|GPIO_Pin_1);	//PD3,PD6 输出高
}
extern volatile u8  TIM4_CAPTURE_STA,state;	//输入捕获状态		    				
extern volatile u16 TIM4_CAPTURE_VAL;	//输入捕获值
float distance_circulate(u32 date,u8 state)
{
    float dis;
    if(state>0xc1)
        state=0xc1;
    date+=(state-0xc0)*65535;
    date/=2;
    dis=(date*340)/10000.0;
    return dis;
}
u8 dis_warn(float warn,u8 dis)
{
  if((u8)warn<dis)
  {
    TIM_Cmd(TIM2,ENABLE);
    TIM2->PSC=719;
    
      if((u8)warn+2<dis)
       TIM2->PSC=366;
    if((u8)warn+5<dis)
        TIM2->PSC=71;
    return 1;
  }
  return 0;
}
 int main(void)
 { 
    u32 distance[3];
    float dis_save[3];
     float dis_temp;
    u8 distance_warning=10;
	volatile u8 Key_vaule,num_pos=0;
    
	u8 buf[20],buf1[20],Is_distance_set=0,Heart_bit;
	delay_init();	    	 //延时函数初始化	  
	TIM4_Cap_Init(0xffff,71);
    
  //  TIM4_Int_Init(0xffff,71);
    Key_GPIO_Init();  // PA 0-7
     
   // TIM4_Cap_Init(0xffff,71);          //三路超声波初始化 PB 7-9
     OLED_Init();  //oled超舒适化  PB 3,4,5,6
    Targ_GPIO();
	memset(buf,0,16);
    memset(buf1,0,16);
    TIME_INIT(); 
    TIM_Cmd(TIM4,ENABLE ); 	//使能定时器2
	while(1)
	{
      Key_vaule=Key_Scan();
        
       if(Heart_bit>100)
       {
          
 
            state=1;
            PBout(0)=1;
            delay_us(30);
            PBout(0)=0;
            TIM4_CAPTURE_VAL=0;
            while(TIM4_CAPTURE_STA<0xc0);
           out_state[0]=TIM4_CAPTURE_STA;
            distance[0]=TIM4_CAPTURE_VAL;
            TIM4_CAPTURE_STA=0; //重置标志位
            state=2;
            PBout(1)=1;
            delay_us(30);
            PBout(1)=0;
            TIM4_CAPTURE_VAL=0;
            while(TIM4_CAPTURE_STA<0xc0);
           out_state[1]=TIM4_CAPTURE_STA;
            distance[1]=TIM4_CAPTURE_VAL;
            TIM4_CAPTURE_STA=0;  //重置标志位
            state=3;
            PBout(10)=1;
            delay_us(30);
            PBout(10)=0;
            TIM4_CAPTURE_VAL=0;
           while(TIM4_CAPTURE_STA<0xc0);
           out_state[2]=TIM4_CAPTURE_STA;
           distance[2]=TIM4_CAPTURE_VAL;
           TIM4_CAPTURE_STA=0;  //重置标志位
       }
      if(Key_vaule=='A')  
      {
        Is_distance_set=1;
        OLED_Clear();//清屏 显示设置的距离
        OLED_ShowString(5,0,"setting/cm");      
        OLED_Refresh_Gram();	 
          
      }
      if(Key_vaule>='0'&&Key_vaule<='9'&&Is_distance_set==1)
      {
        buf[num_pos++]=Key_vaule;
        OLED_ShowString(5,20,buf);  //显示按键
        OLED_Refresh_Gram();
        if(num_pos>3)
            num_pos=0;
      }
      if(Key_vaule=='#'&&(Is_distance_set==1))  //设置距离
      {
        Is_distance_set=0;
        if(strlen(buf)>0)
            distance_warning=atoi(buf);
        memset(buf,0,10);
        delay_ms(1000);
        OLED_Clear();
        Heart_bit=111;  //为了等下能快速看到距离
      }
     
      
     if(Heart_bit>100&&(Is_distance_set==0))
     {
        Heart_bit=0;
         sprintf(buf1,"CH1:%.1f cm",dis_save[0]=distance_circulate(distance[0],out_state[0]));               //测量距离
         OLED_ShowString(5,0,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
         sprintf(buf1,"CH2:%.1f cm",dis_save[1]=distance_circulate(distance[1],out_state[1]));               //测量距离
         OLED_ShowString(5,16,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
         sprintf(buf1,"CH3:%.1f cm",dis_save[2]=distance_circulate(distance[2],out_state[2]));               //测量距离
         OLED_ShowString(5,32,buf1);      
         OLED_Refresh_Gram();	
         memset(buf1,0,strlen(buf1)+1);
     }
     /*-----------------三个等级----------------------*/
     if(dis_save[0]<distance_warning||dis_save[1]<distance_warning||dis_save[2]<distance_warning)
     {
        dis_warn(dis_save[0],distance_warning);
        dis_warn(dis_save[1],distance_warning);
        dis_warn(dis_save[2],distance_warning);
     }else{
     TIM_Cmd(TIM2,DISABLE);  //DISABLE
     }
//     dis_temp=0;
//     dis_temp+=dis_save[0];
//     dis_temp+=dis_save[1];
//     dis_temp+=dis_save[2];
//     if((int)dis_temp<distance_warning*3)
//     {
//        TIM_Cmd(TIM2,ENABLE);
//        if((int)dis_temp<(distance_warning*3-20))
//         TIM2->PSC=199;
//        if((int)dis_temp<(distance_warning*3-30))
//         TIM2->PSC=71;
//     }else
//     {
//     
//      TIM_Cmd(TIM2,DISABLE);  //DISABLE
//     }
     Heart_bit++;
     delay_ms(10);   
    }
    
}
//TIM_SetCompare2(TIM1,light_table[pre_t][1]);
#include "stm32f10x.h"
#include "led.h"
#include "key.h"
#include "sys.h"
#include "exti.h"
#include "usart.h"
#include "timer.h"
#include "delay.h"
#include <string.h>
#include "adc.h"
#include "oled.h"
#include "oledshow.h"
#include "temperature.h"
#include "mpu6050.h"
#include "step.h"

extern int BPM;          //心率值        

int main()
{
	Led_Init();		//初始化LED灯
	OLED_Init();	//初始化OLED
	Usart_X_Init(USART1,72,115200);	//初始化串口1
	ADC1_Init();	//ADC初始化
	TimerX_Init(TIM3,72,2000);  //定时周期2ms 用于心率检测
	
	OLED_Clear();//oled清屏
	while(1)
	{
		OLEDPag1();
	}
}


惰存瀵逛ヨ诧浣跨ㄤ澶灏瀛锛灏卞ㄥ灏╃椤甸锛杩涓ヨ叉涓涓风
涓澶娓妤涓轰涔浼杩涔璁捐★娴芥涓ゆ归㈢锛
1 纭瀹娌℃浜浠舵ヨЕ娈靛瀛躲
2 Linux 娈佃界跺ㄥ芥伴烘朵浼琚撅浣ㄤ娆¤ュ芥版跺浠ュ锛姝ゅ
璁や负 Linux 娈靛瀛鹃棰瀵逛翠釜杩绋瀛浣跨ㄥ奖涓澶с
瀵规浠ヨ诧ㄩ褰芥板ㄥ芥板澶у瀛锛涓洪ｆ浠ｄ环
璇存璇ュ绗浣浜娈碉绋搴板ㄦ椤堕ㄦ娉淇瀛扮澧锛朵究ㄥ娈电宠蜂
涓娈靛瀛ㄦヤ瀛澧
2 澧瀛绗涓叉扮板浠 0xbefffeac 涓 0x11050
涓虹澧瀛绗涓叉扮澶浜涓涓锛ョ椤堕ㄥ氨娌℃绌洪翠瀛浜锛
浠ヨ绋ㄥ娈靛宠蜂涓娈靛瀛锛ㄦヤ瀛澧
姝ゅ杩绋板涓涓澧锛绯荤灏娑瀛=4绯荤澧绘+板澧
垮害+1
浠浠ラ杩 glibc 婧锛ヨ峰稿崇淇℃锛璇缁浠ュ瑙/glibc/sysdeps/generic/setenv.c
__add_to_environ 芥般
褰浠存颁涓澧讹libc 骞朵浼诲ゆ瀵瑰澧淇瀛ㄥ涓锛跺昏
鹃惧锛存ュ澶涓瀛锛ヤ瀛扮澧硷杩朵涓圭瀛娉
婕锛濂藉ㄥ苟涓涓ラ
瀹灏 ELF 浠朵腑瑕淇瀛淇℃т俊绫诲煎涓锛淇瀛ㄦ浠剁涓
哄杩浜哄锛涓浠瀹锛辨绉颁涓衡section涓轰璁块杩浜猴 ELF
浠朵腑浜涓涓杩浜轰缃绱㈠锛哄ごㄨ〃 section headers
涓绉涓昏㈠绋搴杞藉杩琛锛绉颁涓烘ц瑙俱
ㄦц瑙句腑锛瀹浼瀵瑰㈡扮 section锛ц琛剁瑕锛涓轰缁锛涓
绉颁涓衡娈碘锛辨绉颁涓衡segment涓轰璇存娈碉segment锛涓锛section锛崇郴锛
ELF 浠朵腑寮ヤ绋搴澶撮ㄨ〃 program headers
ㄦ浠跺濮澶涓涓 ELF 澶撮锛ELF Header锛
浠ョ颁ョ 9172 涓瀛锛缂╁ 3628锛寰撅涓
4 浠浣跨 readelf ユョ淇瑰 ELF 浠剁点

浠灏 section 伴浠 39 涓灏 29 涓
5 浠杩浠ユ.comment 浠 ELF 浠朵腑ゃ
>strip --remove-section=.comment hello
.bss锛
涓昏ㄦヤ瀛濮濮涓涓 0 ㄥ
.data锛
涓昏ㄦヤ瀛濮涓涓 0 ㄥ
涓轰涔兼涓 0锛寰濡姝ゅ抽锛
杩涓昏涓 loader 浠ュ瑰间负 0 涓瀹浼姐
 g++涓锛const 澹版璇绗锛灏锋ㄩ炬ュэ杩涓 gcc 涓杩峰ㄧ璇
a1.c 讹ㄥ m  a1.c 涓锛朵缂璇锛涓拌ュㄥ m锛ㄧ璇
a2.c 讹缂璇ㄥ涓涓ㄥ m锛跺 a2.c 涓
浠ワ浠浼板ㄧ璇烘ョ hello 涓锛涓や釜藉 m 绗
00008540 r m
00008544 r m
瀹浠涓板
涓哄煎规版荤嚎瀹藉害涓 16 浣搴ㄧ郴缁锛 ARM 浣绯荤やц寰楂 32
浣 ARM 浠ら浠ュ锛舵 16 浣 Thumb 浠ら Thumb 浠ら ARM 浠
涓涓瀛锛璁告浠ょ涓 16 浣垮害涓绛浠风 32 浣浠ｇ告杈锛 Thumb 浠
ㄤ 32 浠ｇ浼跨讹澶уぇ浜绯荤瀛ㄧ┖淬
 Thumb 浠ら芥瀵瑰 ARM 浠わ涓 Thumb 缂绋妯″涔瀵瑰浜 ARM 
缂绋妯″锛ㄥㄧ搴缂杩绋涓锛瑕靛惊涓瀹璋ㄧ瑙锛 Thumb 瀛绋搴 ARM
瀛绋搴灏卞浠ヤ歌ㄣ褰澶ㄥㄦц ARM 绋搴娈垫讹绉 ARM 澶ㄥ浜 ARM 宸
浣舵锛褰澶ㄥㄦц Thumb 绋搴娈垫讹绉 ARM 澶ㄥ浜 Thumb 宸ヤ舵
涓 ARM 浠ら告杈锛 Thumb 浠ら涓版澶浠ょ浣颁舵 32 浣锛浠
板涔涓 32 浣锛浣 Thumb 浠ら涓哄 16 浣浠ら垮害锛寮浜 ARM 浠ら涓浜
规э濡澶у扮 Thumb 浠ゆ′欢ц锛涔 ARM 浠ら芥′欢ц
锛澶у扮 Thumb 版澶浠ょ瀵瀛ㄤ朵腑涓涓婧瀵瀛ㄧ稿
Thumb 浠ょ缂璇

hello.c
#include <stdlib.h>
#include <stdio.h>
int main()
{
printf("hello world!\n");
return 0;
}
缂璇锛
#gcc -o hello -mthumb a.c
浠灏 a1.c 缂璇 thumb 浠:
#gcc -o a1.o -c -mthumb a1.c
灏 a2.c 缂璇 ARM 浠わ
#gcc -o a2.o -c a2.c'
灏堕炬ユ涓涓ц浠
#gcc -o hello a1.o a2.o
浠涓杞藉拌惧涓锛杩琛
# ./hello

浠涓㈡浠浠ョ帮涓轰 funca 涓 Thumb 浠わfuncb  main 涓 ARM 浠わ涓轰
ARM 浠ゅ Thumb 浠ょ璋锛GCC 瀹浜 3 涓芥__funcb_from_thumb
__funcb_change_to_arm __funca_from_arm
ㄦ搴涓ょ跺杞芥瑰锛
1杞
ㄧ搴缂璇跺涓-l椤癸瀹舵渚璧ㄦ搴锛杩涓搴瀛灏璁板 ELF 
浠剁.dynamic ㄧ搴杩琛讹loader 浼棰灏绋搴渚璧ㄦ搴藉杞藉ㄨ绋绌
翠腑
杞界浼癸
ㄦ搴ュｈㄧ锛浠ョ存ヨㄣ
缂虹癸
ㄦ搴瀛ㄦ绛浜杩绋瀛ㄦ锛跺杞芥舵轰垫椿
2ㄦ杞
浠杩浠ュㄧ搴涓缂ユ瀹杞藉ㄦ搴舵猴缁甯镐娇ㄧ芥 dlopen dlclose
ㄦ杞界浼癸
ㄦ搴杞界舵洪甯哥垫椿锛浠ラ甯哥寸瀹涔ㄦ搴瀛ㄦ
ㄦ杞界缂虹:
ㄦ搴ュｈㄨ捣ユ杈楹荤锛惰瑕虫敞ㄦ搴瀛ㄦ
>gcc L./ -la hello.c o hello
>gcc shared fPIC

a.c o liba.so
界舵浠娌℃浣跨 bss 版锛浣绯荤杩ㄤ╃椤甸锛杩戒杩绋澶跺变韩搴版
娈垫
姝わ涓瑕ㄨ绋涓杩 extern 瑰寮ㄥ变韩搴涓ㄥ锛涓寮锛涓璁哄舵浣
锛藉浼ㄧ╃瀛惰浼澧绯荤ㄦ讹瀛澶剁浠ｄ环锛浼瀵艰存ц界涓
浠涔娉ㄦ帮版娈电板涓娈电板杩锛杩涔灏辨璇达褰涓荤搴炬ヤ涓涓
变韩搴ㄥ讹瀹浼涓鸿ュ瀹涔涓涓板锛浣瀹涓浼褰卞版娈电澶у锛灏璇ュ兼
璐拌涓板涓濡板娈典澶锛瀹灏ㄥ娈碉绯荤灏璋 brk ユ╁娈点
浠杩 strace 浠ユラ璇杩涓瑙癸
姝わ浠浠ラ杩杩绋.rel.dyn .rel.pltsection 变韩搴涓绗凤惧鸿绋涓变韩搴涔
寸璋ㄥ崇郴
1 濡ㄥ澹版ㄨ绋涓锛ㄥ变韩搴涓浣跨锛璇ュ浣浜杩绋版娈点
2 濡ㄥ澹版ㄥ变韩搴涓锛ㄨ绋涓浣跨锛璇ュ琚澶跺拌绋版娈碉
淇逛娇ㄨュ变韩搴
3 濡璇ュㄥ变韩搴涓澹版锛ㄥ变韩搴涓浣跨锛璇ュ浣浜澹版瀹变韩搴版娈
涓
PIC 浣.so 浠剁浠ｇ娈靛涓虹姝ｆ涔涓变韩
濡涓-fPIC,杞.so 浠剁浠ｇ娈垫,浠ｇ娈靛ㄧ版瀵硅薄瑕瀹浣, 瀹浣浼淇
浠ｇ娈电瀹,杩灏遍姣涓浣跨ㄨ涓.so 浠朵唬娈电杩绋ㄥ搁戒杩涓.so 浠
浠ｇ娈电 copy.姣涓 copy 戒涓,充杩涓.so 浠朵唬娈靛版娈靛瀛灏浣缃.
浠浠ヤ娇 ulimit 戒护锛ユョ璁剧疆涓涓杩绋绌洪寸澶у锛
涓典锛涓涓杩绋ユ绾跨伴寰灏锛澶ф 10 涓浠ュ锛濡姣涓绾跨浣跨 20K
瀛璇锛ｄ诲辨 200K 瀛锛瀵圭郴缁褰卞杩寰灏
娉锛姣涓涓变韩瀛洪芥涓涓у剁 struct shmid_kernel锛shmid_kernel 变韩瀛哄
涓甯搁瑕涓涓版缁锛瀹瀛ㄧ＄浠剁郴缁缁璧锋ョ妗ユ锛瀹涔濡涓锛
姝ｅ娑淇″风涓凤搁杩版缁 struct ipc_ids shm_ids 缁存ょ郴缁涓
浜瀛哄涓句腑 shm_ids.entries 涓涓 ipc_id 缁扮锛姣涓 ipc_id 缁
涓轰涔绋搴浣跨ㄤ杩涔澶瀛锛
锋娴瀛娉婕锛
1 ュご浠<mcheck.h>
2 ㄩ瑕瀛娉婕妫ョ浠ｇ寮濮璋 void mtrace()锛ㄩ瑕瀛娉婕妫ヤ唬缁
璋 void muntrace()
涓典涓瑕璋 muntrace锛璁╃搴剁锛涓哄芥浜瀛句唬瑕
muntrace 涔杩琛
3  debug 妯″缂璇妫ヤ唬锛-g -ggdb锛
4 ㄨ琛绋搴憋璁剧疆澧 MALLOC_TRACE 涓轰浠跺锛杩涓浠跺瀛瀛
淇℃
5 杩琛绋搴锛瀛 log 灏杈哄 MALLOC_TRACE 浠朵腑
 glibc 涓锛渚浜 mallocfreereallocmemalign ╁芥般
浣浠ユч╁芥扮锛瀹涔宸辩芥帮骞跺 glibc 涓璁剧疆稿╁芥帮杩 glibc
ㄥ芥版讹浼璋ㄤ╁芥帮浠峰稿淇℃
#! /usr/bin/perl
my $log = shift (@ARGV);
open flog ,"<$log" or die "cannot open $log:$!";
while(<flog>)
{
if(/^@@@/)
{
@items = split/\s+/;
if($items[2] eq '+')
{
$size=hex(substr($items[4],2));
$memory{$items[3]}=$size;
}
if($items[2] eq '-')
{
delete $memory{$items[3]};
}
}
}
foreach $key(sort keys %memory)
{
print "$key $memory{$key}\n";
}
4.1. gcc 涓 g++涓
gcc  g++芥 GNU 涓涓缂璇ㄣ
寰澶浜洪借や负 gcc 界璇 C 绋搴锛 g++界璇 C++浠ｇ瀹涓杩藉浠ャ
1.缂涓.c 锛gcc 瀹褰浣 C 绋搴锛 g++褰浣 c++绋搴锛缂涓.cpp 锛涓よ戒
璁や负 c++绋搴锛娉ㄦ锛界 c++ c 瓒锛浣涓よ瀵硅娉瑕姹哄C++
璇娉瑙村涓ヨ皑涓浜
2.缂璇舵碉g++浼璋 gcc锛瀵逛 c++浠ｇ锛涓よ绛浠风锛浣涓 gcc 戒护涓借ㄥ
C锛锛绋搴浣跨ㄧ搴ワ浠ラ甯哥 g++ュ炬ワ涓轰缁涓璧疯锛骞茶缂璇/炬ョ缁
 g++浜锛杩灏辩浜轰绉瑙锛濂藉 cpp 绋搴界 g++浼肩
ㄨ涓绡绔浜璇缁杩般
http://blog.chinaunix.net/u/30686/showart.php?id=519752
杩瑕璇存锛ㄤ娇 g++缂璇跺锛璁鸿涓绋搴浣跨ㄤ绫伙藉浼灏渚
璧浜 C++ㄦ搴锛libstdc++.so锛
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
pause();
return 0;
}
缂璇锛
gcc o hello hello.c
杩琛
# ./hello
# cat maps

浠浼 hello 渚璧搴澧浜 3 涓 libstdc++.so libm.so libgcc_s.so,朵腑 libm.so 
libgcc_s.so  libstdc++.so 寮ョ涓瑕灏杩涓涓搴锛杩绋姣杞戒涓搴锛灏辫涓哄跺
稿版娈碉涓浜瀹宸ヤ绛锛姣涓搴版娈垫灏瑕 4K ╃瀛锛涔灏
璇翠娇 g++缂璇虹 hello锛瑕姣浣跨 gcc 缂璇烘ョ锛灏瀛澶浜 12K
/proc/sys/vm/pagecache
璇ユ浠朵 /proc/sys/vm/buffermem 宸ヤ瀹逛凤浣瀹瀵规浠剁瀛灏涓楂
瀹颁涓stm32h750 ADC杩锋妯℃ㄧ斤璁哥簿纭扮娴涓涓澶涓妯℃靛锛褰妯℃靛瓒哄缂绋兼朵浜х涓涓涓
告瑷锛Android磋涓姝ワ瀹澶涓搴ㄥュｇ癸寮ヤ翠赴瀵哄躲Android绯荤涓瀹锛绯荤浼ㄤ版瑰ㄥ浠锛杩充ㄦ峰姝ｅㄥ浠ュㄦ锋ヤユ冲浠涔
ㄥ朵腑涓涓借薄灞锛Android搴ㄧ璧锋ュWeb搴ㄥ镐技娲诲ㄧ被浼间Web搴ㄤ腑servlet璁捐¤濂界娲诲ㄨ璐ｇ＄涓UI椤甸锛姣涓UI芥宸卞涓绉般ㄦ锋规杩浜炬ワ浠Web椤甸㈢涓涓椤甸㈣烦杞板涓涓椤甸锛Android搴ㄤ腑锛ㄦ蜂氦浜杩intent璋ㄧ伴〉㈠浠ラ杩炬ュ艰拌椤甸姝ｅWeb搴ㄤ涓锛浜servlet渚UI斤朵渚＄API姝わAndroid涓涓锛娲诲ㄦ渚UI锛ServiceContentProvider绫伙寰蹇浼浠缁锛渚瀵硅浜＄璁块姐瑙ｈ绉舵涓镐技ф╀╃Android妗惰捐Android搴ㄣ
Android搴ㄨ涓浜朵缁浠讹蜂锛Service锛★Content Provider锛瀹规渚锛Broadcast Receiver锛骞挎ユ跺锛Service绫昏璐ｄ负板芥渚锛ContentProvider绫绘澶涓搴ㄤ娇ㄦ版瀛ㄧ璁块瑰锛Broadcast Receiver澶规ユ跺ㄦ骞挎句俊
版浠剁璇诲锛ｄ涓寰涓版浠剁郴缁杩涓浣绯荤涓涓洪瑕缁ㄥ涔涓浠剁郴缁绠＄纾涓浠剁瀛ㄦ瑰锛姣濡浠Linux绯荤涓涓涓浠垛/home/user/test.dat锛垮害涓8 000涓瀛ｄ浠ㄥ寤鸿涓浠剁跺锛Linuxext3浠剁郴缁藉杩涓浠舵ц风瑰瀛ㄥㄧ涓锛浠剁4 096瀛瀛ㄥㄧ1000锋哄1007锋猴姣涓512瀛锛8涓哄濂4 096瀛锛浠剁绗4 097涓瀛扮8 000瀛3 904涓瀛锛瀛ㄥㄧ2000锋哄2007锋猴8涓轰4 096瀛锛涓杩瀛ㄤ3 904涓瀛锛╀192涓瀛濡杩涓浠剁瀛ㄦ瑰浣涓涓剧剁缁锛瀹缁濡1-4绀恒
杩浠绌挎涓涓充纭缁浠缁锛充纭缁藉澶璇昏宸茬涓涓澶ф浜瑙ｏｅ氨纭烘瀛ㄥ浣涓烘猴Sector锛锛姣涓轰涓512瀛涓涓纭寰寰澶涓锛姣涓涓ら锛姣㈡у蹇涓鸿ュ共涓纾锛姣涓纾涓鸿ュ共涓恒姣濡涓涓纭2涓锛姣涓㈠65 536纾锛姣涓纾1 024涓猴ｄ纭瀹归灏辨2 * 2 * 65 536 * 1 024 * 512 = 137 438 953 472瀛锛128GB锛浣浠浠ユ宠薄锛姣涓涓蹇ㄩ夸涓凤濡ф涓纾芥ユ稿伴猴ｄ杩㈠寸纾瀵搴瀹姣村绋锛杩锋姣杈娴璐圭┖寸浣濡涓纾烘板涓锛璁＄璧锋ュ氨楹荤涓轰灞借浜澶纭浠剁锛颁唬纭浣跨ㄤ绉LBA锛Logical Block Address锛瑰锛虫翠釜纭涓轰0寮濮缂凤涓村版涓涓猴杩涓虹峰昏哄枫昏哄锋寮浜澶纾涔绫荤姒蹇点褰浠缁轰涓昏哄锋讹纭靛璁惧浼灏惰浆㈡瀹纾绛杩浜浣缃
杩浠绌挎涓涓充纭缁浠缁锛充纭缁藉澶璇昏宸茬涓涓澶ф浜瑙ｏｅ氨纭烘瀛ㄥ浣涓烘猴Sector锛锛姣涓轰涓512瀛涓涓纭寰寰澶涓锛姣涓涓ら锛姣㈡у蹇涓鸿ュ共涓纾锛姣涓纾涓鸿ュ共涓恒姣濡涓涓纭2涓锛姣涓㈠65 536纾锛姣涓纾1 024涓猴ｄ纭瀹归灏辨2 * 2 * 65 536 * 1 024 * 512 = 137 438 953 472瀛锛128GB锛浣浠浠ユ宠薄锛姣涓涓蹇ㄩ夸涓凤濡ф涓纾芥ユ稿伴猴ｄ杩㈠寸纾瀵搴瀹姣村绋锛杩锋姣杈娴璐圭┖寸浣濡涓纾烘板涓锛璁＄璧锋ュ氨楹荤涓轰灞借浜澶纭浠剁锛颁唬纭浣跨ㄤ绉LBA锛Logical Block Address锛瑰锛虫翠釜纭涓轰0寮濮缂凤涓村版涓涓猴杩涓虹峰昏哄枫昏哄锋寮浜澶纾涔绫荤姒蹇点褰浠缁轰涓昏哄锋讹纭靛璁惧浼灏惰浆㈡瀹纾绛杩浜浣缃

浠剁郴缁淇瀛浜杩浜浠剁瀛ㄧ锛璐璐ｇ淮よ浜版缁骞朵淇璇纾涓鸿藉扮缁╃ㄣｄ褰浠Linux浣绯荤涓锛瑕璇诲杩涓浠剁4 096涓瀛讹浠浼浣跨ㄤ涓read绯荤璋ㄦュ般浠剁郴缁跺read璇锋涔锛ゆ烘浠剁4 096涓瀛浣浜纾1000烽昏哄1007烽昏恒跺浠剁郴缁灏卞纭椹卞ㄥ轰涓璇诲昏轰负1000峰濮8涓虹璇锋锛纾椹卞ㄧ搴跺拌涓璇锋浠ュ灏卞纭虹‖浠跺戒护纭浠跺I/O戒护瑰寰澶绉锛朵腑涓哄父瑙涓绉灏辨杩璇诲I/O绔ｅ瀛ㄦュ般x86骞冲颁锛辨65 536涓纭浠剁ｅ瀛锛涓纭浠惰颁涓I/O绔ｅ板CPU渚浜涓ゆ′ㄧ浠もinoutュ板圭‖浠剁ｇ璇诲
? 绗0x1F3锝0x1F6 4涓瀛绔ｅ板ㄦュLBA板锛ｄ1000烽昏虹LBA板涓0x000003E8锛浠ユ浠瑕寰0x1F30x1F40x00锛寰0x1F50x03锛寰0x1F60xE8
? 0x1F2杩涓板ㄦュュ戒护瑕璇诲烘般姣濡璇诲8涓哄冲8

? 0x1F7杩涓板ㄦュヨц浣戒护锛瀵逛璇诲浣ヨ达戒护瀛涓0x20
浠ユ浠瑕ц浠や负锛

out 0x1F3, 0x00

out 0x1F4, 0x00

out 0x1F5, 0x03

out 0x1F6, 0xE8

out 0x1F2, 0x08

out 0x1F7, 0x20
? 板绌洪翠绂 绋搴界存ヨ块╃板锛绋搴浣跨ㄧ瀛绌洪翠镐绂荤舵绋搴浠ュ瀹规瑰朵绋搴瀛版锛浠ヨ揪扮村锛浜舵浣绋搴戒灏蹇淇逛朵绋搴版锛灏变浣垮朵绋搴涔宕╂锛杩瀵逛瑕瀹ㄧǔ瀹璁＄澧ㄦ锋ヨ存涓藉瑰ㄦ峰浠ㄤ娇ㄨ＄虹跺锛朵腑涓涓浠诲″け璐ヤ锛冲涓浼褰卞朵浠诲°

? 瀛浣跨ㄦ浣 变娌℃瀛绠＄哄讹甯搁瑕涓涓绋搴ц讹х搴灏卞翠釜绋搴瑁ュ瀛涓跺寮濮ц濡浠蹇界堕瑕杩琛绋搴C锛ｄ杩跺瀛绌洪村跺宸茬涓澶浜锛杩跺浠浠ョㄧ涓涓娉灏朵绋搴版跺扮锛绛伴瑕ㄥ扮跺璇诲ャ变绋搴瑕绌洪存杩缁锛ｄ杩涓渚瀛锛濡浠灏绋搴A㈠哄扮剧瀛绌洪存涓澶锛浠ュ藉B㈠哄扮锛跺灏C璇诲ュ板瀛寮濮杩琛浠ョ版翠釜杩绋涓澶ч版ㄦ㈠ユ㈠猴瀵艰存浣涓

? 绋搴杩琛板涓纭瀹 涓虹搴姣娆￠瑕瑁ヨ琛讹浠介瑕缁瀹浠瀛涓涓瓒冲澶х绌洪插哄锛杩涓绌洪插哄浣缃涓纭瀹杩缁绋搴缂浜涓瀹楹荤锛涓虹搴ㄧ讹瀹璁块版浠よ烦杞剁板寰澶芥哄锛杩娑绋搴瀹浣棰锛浠ㄧ2ㄥ绗3ㄥ杩浼璇缁㈣ㄩ瀹浣棰

瑙ｅ宠涓棰璺灏辨浣跨ㄦ浠拌娉瀹锛澧涓村锛充娇ㄤ绉存ョ板璁块规翠釜虫杩风锛浠绋搴缁虹板浣涓绉板锛Virtual Address锛锛跺杩浜灏规锛灏杩涓板杞㈡瀹╃板杩凤瑕浠藉濡ュ版у惰涓板扮╃板灏杩绋锛灏卞浠ヤ璇浠绘涓涓绋搴藉璁块╃瀛哄璺澶涓涓绋搴镐涓锛浠ヨ揪板板绌洪撮绂荤

write a stm32f103 example to explain 

璁炬浠璁＄烘128 MB瀛锛绋搴A杩琛瑕10 MB锛绋搴B瑕100 MB锛绋搴C瑕20 MB濡浠瑕惰琛绋搴AB锛ｄ姣杈存ョ娉灏瀛10 MB缁绋搴A锛10 MB锝110 MB缁B杩峰氨藉瀹AB涓や釜绋搴惰琛锛浣杩绉绠瀛绛ラ棰寰澶

? 板绌洪翠绂 绋搴界存ヨ块╃板锛绋搴浣跨ㄧ瀛绌洪翠镐绂荤舵绋搴浠ュ瀹规瑰朵绋搴瀛版锛浠ヨ揪扮村锛浜舵浣绋搴戒灏蹇淇逛朵绋搴版锛灏变浣垮朵绋搴涔宕╂锛杩瀵逛瑕瀹ㄧǔ瀹璁＄澧ㄦ锋ヨ存涓藉瑰ㄦ峰浠ㄤ娇ㄨ＄虹跺锛朵腑涓涓浠诲″け璐ヤ锛冲涓浼褰卞朵浠诲°

寮濮浜轰滑浣跨ㄧ涓绉娈碉Segmentation锛规锛烘璺涓娈典绋搴瑕瀛绌洪村ぇ灏绌洪存灏版涓板绌洪淬姣濡绋搴A瑕10 MB瀛锛ｄ浠璁炬涓涓板浠0x000000000x00A0000010MB澶у涓涓璞＄绌洪达涔灏辨绌洪达跺浠浠瀹╃瀛涓涓涓稿澶у╃板锛璁炬╃板0x00100000寮濮0x00B00000缁涓绌洪淬跺浠杩涓ゅ稿澶у板绌洪翠涓灏锛宠绌洪翠腑姣涓瀛稿瑰浜╃绌洪翠腑姣涓瀛杩涓灏杩绋辫蒋浠舵ヨ剧疆锛姣濡浣绯荤ヨ剧疆杩涓灏芥帮瀹板杞㈢辩‖浠跺姣濡褰绋搴A涓璁块板0x00001000讹CPU浼灏杩涓板杞㈡瀹╃板0x00101000ｄ姣濡绋搴A绋搴Bㄨ琛讹瀹浠绌洪村╃绌洪存灏崇郴藉1-5绀恒
椤电烘规板绌洪翠汉涓哄扮哄澶у椤碉姣涓椤电澶у辩‖浠跺冲锛纭浠舵澶绉澶у椤碉辨浣绯荤╁冲椤电澶у姣濡Intel Pentium绯诲澶ㄦ4KB4MB椤靛ぇ灏锛ｄ浣绯荤浠ラ╂椤靛ぇ灏涓4KB锛涔浠ラ╂椤靛ぇ灏涓4MB锛浣ㄥ涓跺诲介╀绉澶у锛浠ュ规翠釜绯荤ヨ达椤靛氨哄澶у涔PC涓浣绯荤戒娇4KB澶у椤点浠浣跨ㄧPC烘32浣板绌洪达涔灏辨4GB锛ｄ4KB姣椤靛璇锛诲辨1 048 576涓椤点╃绌洪翠风娉
绾跨锛Thread锛锛惰绉颁负杞婚绾ц绋锛Lightweight Process, LWP锛锛绋搴ц娴灏涓涓绾跨辩嚎绋ID褰浠ゆ锛PC锛瀵瀛ㄩ缁甯告涔涓锛涓涓杩绋变涓板涓绾跨缁锛涓绾跨涔村变韩绋搴瀛绌洪达浠ｇ娈点版娈点绛锛涓浜杩绋绾х璧婧锛濡寮浠跺淇″凤涓涓缁哥绾跨涓杩绋崇郴濡1-8绀恒
涓浣戒峰ラ挎堕寸寰锛绛寰绾跨浼杩ョ＄舵锛娉缁х画ц澶绾跨ц浠ユ╃ㄧ寰堕淬稿渚瀛绛寰缃缁搴锛杩借辫垂扮虫板绉

涓浣锛甯稿父璁＄锛浼娑澶ч堕达濡涓涓绾跨锛绋搴ㄦ蜂寸浜や浼涓澶绾跨浠ヨ╀涓绾跨璐璐ｄ氦浜锛涓涓绾跨璐璐ｈ＄

绋搴昏韬灏辫姹骞跺浣锛渚濡涓涓澶绔涓杞借蒋浠讹渚濡Bittorrent锛

澶CPU澶歌＄猴烘灏辨ョ涓绘璁＄猴锛韬峰舵ц澶涓绾跨藉锛姝ゅ绾跨绋搴娉ㄩ㈠板ヨ＄虹ㄩㄨ＄藉

稿逛澶杩绋搴锛澶绾跨ㄦ版变韩归㈡瑕楂寰澶
绾跨璋搴涓浼绾

涓璁烘ㄥ澶ㄧ璁＄轰杩ㄥ澶ㄧ璁＄轰锛绾跨绘骞跺ц褰绾跨伴灏浜绛浜澶ㄦ伴讹骞朵浣绯荤澶澶锛锛绾跨骞跺姝ｇ骞跺锛涓绾跨杩琛ㄤ澶ㄤ锛褰兼や翠涓稿共浣瀵逛绾跨伴澶т澶ㄦ伴碉绾跨骞跺浼颁浜荤锛涓烘ゆ惰冲涓涓澶ㄤ杩琛澶涓绾跨

ㄥ澶ㄥ瑰澶绾跨典锛骞跺涓绉妯℃烘ョ舵浣绯荤浼璁╄浜澶绾跨绋搴杞娴ц锛姣娆′ц涓灏娈垫堕达甯告板炬绉锛锛杩锋涓绾跨灏扁璧锋モㄥ舵ц杩风涓涓涓ㄥㄤ涓绾跨琛涓虹О涔涓虹嚎绋璋搴锛Thread Schedule锛ㄧ嚎绋璋搴涓锛绾跨甯告ユ冲涓绉舵锛锛

杩琛锛Running锛锛姝ゆ剁嚎绋姝ｅㄦц

灏辩华锛Ready锛锛姝ゆ剁嚎绋浠ョ昏琛锛浣CPU宸茬琚ㄣ

绛寰锛Waiting锛锛姝ゆ剁嚎绋姝ｅㄧ寰涓浜浠讹甯告I/O姝ワ锛娉ц
璇ョ褰涓浠舵扮寰澶锛浣浠涓昏虫敞 in_voltage3_rawin_voltage_scale 杩涓や釜浠跺冲锛
涓 in_voltage3_raw 涓鸿诲 adc 版濮板硷in_voltage_scale 涓 adc 版涓靛兼㈢姣渚锛
灏浠杩涓や釜璇诲扮版镐冲寰版浠宠胯浇典ㄤ靛笺
变璇诲靛肩稿圭锛ヤユ浠灏缂绠 shell 峰靛笺
	pthread_detach(id);
    queue_init(&bindReqQueue, sizeof(bindReq_t), 1);
    queue_init(&bindRespQueue, sizeof(bindReq_t), 1);
    queue_init(&secondaryBufferQueue, sizeof(secondaryBufferItem_t), NUM_SECONDARY_BUFFERS);
	c := http.Cookie{
		Name:    flashName,
		Value:   base64.URLEncoding.EncodeToString(value),
		Path:    "/",
		Expires: expire,
		MaxAge:  3,
	}
	http.SetCookie(w, &c)
func GetMessage(w http.ResponseWriter, r *http.Request) ([]byte, error) {
	log.Info("[flash] begin get message...")
	c, err := r.Cookie(flashName)
	if err != nil {
		switch err {
		case http.ErrNoCookie:
			return nil, nil
		default:
			return nil, err
		}
	}

	// delete cookie
	dc := http.Cookie{
		Name:    flashName,
		Path:    "/",
		MaxAge:  -1,
		Expires: time.Unix(1, 0),
	}
	http.SetCookie(w, &dc)

	value, err := base64.URLEncoding.DecodeString(c.Value)
	if err != nil {
		return nil, err
	}

	return value, nil
}
   │1823    void init_cgroup_root(struct cgroup_root *root, struct cgroup_sb_opts *opts)                                              │
   │1824    {                                                                                                                         │
   │1825            struct cgroup *cgrp = &root->cgrp;                                                                                │
   │1826                                                                                                                              │
  >│1827            INIT_LIST_HEAD(&root->root_list);                                                                                 │
   │1828            atomic_set(&root->nr_cgrps, 1);                                                                                   │
   │1829            cgrp->root = root;                                                                                                │
   │1830            init_cgroup_housekeeping(cgrp);                                                                                   │
   │1831            idr_init(&root->cgroup_idr);                                                                                      │
   │1832                                                                                                                              │
   │1833            root->flags = opts->flags;                                                                                        │
   │1834            if (opts->release_agent)                                                                                          │
   │1835                    strcpy(root->release_agent_path, opts->release_agent);                                                    │
   │1836            if (opts->name)                                                                                                   │
   │1837                    strcpy(root->name, opts->name);                                                                           │
   │1838            if (opts->cpuset_clone_children)                                                                                  │
   │300     static __always_inline void __write_once_size(volatile void *p, void *res, int size)                                      │
   │301     {                                                                                                                         │
   │302             switch (size) {                                                                                                   │
   │303             case 1: *(volatile __u8 *)p = *(__u8 *)res; break;                                                                │
   │304             case 2: *(volatile __u16 *)p = *(__u16 *)res; break;                                                              │
  >│305             case 4: *(volatile __u32 *)p = *(__u32 *)res; break;                                                              │
   │306             case 8: *(volatile __u64 *)p = *(__u64 *)res; break;                                                              │
   │307             default:                                                                                                          │
   │308                     barrier();                                                                                                │
   │309                     __builtin_memcpy((void *)p, (const void *)res, size);                                                     │
   │310                     barrier();                                                                                                │
   │311             }                                                                                                                 │
   │312     }                                                                                                                         │
   │1800    static void init_cgroup_housekeeping(struct cgroup *cgrp)                                                                 │
   │1801    {                                                                                                                         │
   │1802            struct cgroup_subsys *ss;                                                                                         │
   │1803            int ssid;                                                                                                         │
   │1804                                                                                                                              │
   │1805            INIT_LIST_HEAD(&cgrp->self.sibling);                                                                              │
   │1806            INIT_LIST_HEAD(&cgrp->self.children);                                                                             │
   │1807            INIT_LIST_HEAD(&cgrp->cset_links);                                                                                │
   │1808            INIT_LIST_HEAD(&cgrp->pidlists);                                                                                  │
  >│1809            mutex_init(&cgrp->pidlist_mutex);                                                                                 │
   │1810            cgrp->self.cgroup = cgrp;                                                                                         │
   │1811            cgrp->self.flags |= CSS_ONLINE;                                                                                   │
   │1812            cgrp->dom_cgrp = cgrp;                                                                                            │
   │1813            cgrp->max_descendants = INT_MAX;                                                                                  │
   │1814            cgrp->max_depth = INT_MAX;                                                                                        │
   │1815                                                                                                                              │
   │1816            for_each_subsys(ss, ssid)                                                                                         │
   │1817                    INIT_LIST_HEAD(&cgrp->e_csets[ssid]);                                                                     │
   │1818                                                                                                                              │
   │1819            init_waitqueue_head(&cgrp->offline_waitq);                                                                        │
   │1820            INIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);                                                      │
   │1821    }                                                                                                                         │
   │152     static inline void idr_init(struct idr *idr)                                                                              │
   │153     {                                                                                                                         │
  >│154             INIT_RADIX_TREE(&idr->idr_rt, IDR_RT_MARKER);                                                                     │
   │155             idr->idr_next = 0;                                                                                                │
   │156     }                                                                                                                         │
   │47      static inline void arch_local_irq_disable(void)                                                                           │
   │48      {                                                                                                                         │
  >│49              asm volatile(                                                                                                     │
   │50                      "       cpsid i                 @ arch_local_irq_disable"                                                 │
   │51                      :                                                                                                         │
   │52                      :                                                                                                         │
   │53                      : "memory", "cc");                                                                                        │
   │54      }                                                                                                                         │
   │2007    void __init boot_cpu_init(void)                                                                                           │
   │2008    {                                                                                                                         │
  >│2009            int cpu = smp_processor_id();                                                                                     │
   │2010                                                                                                                              │
   │2011            /* Mark the boot cpu "present", "online" etc for SMP and UP case */                                               │
   │2012            set_cpu_online(cpu, true);                                                                                        │
   │2013            set_cpu_active(cpu, true);                                                                                        │
   │2014            set_cpu_present(cpu, true);                                                                                       │
   │2015            set_cpu_possible(cpu, true);                                                                                      │
   │2016                                                                                                                              │
   │2017    #ifdef CONFIG_SMP                                                                                                         │
   │2018            __boot_cpu_id = cpu;                                                                                              │
   │2019    #endif                                                                                                                    │
   │2020    }                                                                                                                         │
   │372     static void __init setup_command_line(char *command_line)                                                                 │
   │373     {                                                                                                                         │
  >│374             saved_command_line =                                                                                              │
   │375                     memblock_virt_alloc(strlen(boot_command_line) + 1, 0);                                                    │
   │376             initcall_command_line =                                                                                           │
   │377                     memblock_virt_alloc(strlen(boot_command_line) + 1, 0);                                                    │
   │378             static_command_line = memblock_virt_alloc(strlen(command_line) + 1, 0);                                           │
   │379             strcpy(saved_command_line, boot_command_line);                                                                    │
   │380             strcpy(static_command_line, command_line);                                                                        │
   │381     }                                                                                                                         │
   │382                                                                                                                               │
   │169     __lookup_processor_type:                                                                                                  │
B+>│170             adr     r3, __lookup_processor_type_data                                                                          │
   │171             ldmia   r3, {r4 - r6}                                                                                             │
   │172             sub     r3, r3, r4                      @ get offset between virt&phys                                            │
   │173             add     r5, r5, r3                      @ convert virt addresses to                                               │
   │174             add     r6, r6, r3                      @ physical address space                                                  │
   │175     1:      ldmia   r5, {r3, r4}                    @ value, mask                                                             │
   │176             and     r4, r4, r9                      @ mask wanted bits                                                        │
   │177             teq     r3, r4                                                                                                    │
   │178             beq     2f                                                                                                        │
   │179             add     r5, r5, #PROC_INFO_SZ           @ sizeof(proc_info_list)                                                  │
   │180             cmp     r5, r6                                                                                                    │
   │181             blo     1b                                                                                                        │
   │243     static int __get_cpu_architecture(void)                                                                                   │
   │244     {                                                                                                                         │
   │245             int cpu_arch;                                                                                                     │
   │246                                                                                                                               │
  >│247             if ((read_cpuid_id() & 0x0008f000) == 0) {                                                                        │
   │248                     cpu_arch = CPU_ARCH_UNKNOWN;                                                                              │
   │249             } else if ((read_cpuid_id() & 0x0008f000) == 0x00007000) {                                                        │
   │250                     cpu_arch = (read_cpuid_id() & (1 << 23)) ? CPU_ARCH_ARMv4T : CPU_ARCH_ARMv3;                              │
   │251             } else if ((read_cpuid_id() & 0x00080000) == 0x00000000) {                                                        │
   │252                     cpu_arch = (read_cpuid_id() >> 16) & 7;                                                                   │
   │253                     if (cpu_arch)                                                                                             │
   │254                             cpu_arch += CPU_ARCH_ARMv3;                                                                       │
   │255             } else if ((read_cpuid_id() & 0x000f0000) == 0x000f0000) {                                                        │
   │256                     /* Revised CPUID format. Read the Memory Model Feature                                                    │
   │257                      * Register 0 and check for VMSAv7 or PMSAv7 */                                                           │
   │258                     unsigned int mmfr0 = read_cpuid_ext(CPUID_EXT_MMFR0);                                                     │
   │259                     if ((mmfr0 & 0x0000000f) >= 0x00000003 ||                                                                 │
   │690     #ifdef MULTI_CPU                                                                                                          │
  >│691             processor = *list->proc;                                                                                          │
   │692     #endif                                                                                                                    │
   │693     #ifdef MULTI_TLB                                                                                                          │
   │694             cpu_tlb = *list->tlb;                                                                                             │
   │695     #endif                                                                                                                    │
   │696     #ifdef MULTI_USER                                                                                                         │
   │697             cpu_user = *list->user;                                                                                           │
   │698     #endif                                                                                                                    │
   │699     #ifdef MULTI_CACHE                                                                                                        │
$12 = (struct proc_info_list *) 0x806714e4 <__v7_ca9mp_proc_info>
(gdb) p *list
$13 = {cpu_val = 1091551376, cpu_mask = 4279238640, __cpu_mm_mmu_flags = 3086, __cpu_io_mmu_flags = 3074, __cpu_flush = 4289359672,
  arch_name = 0x807015a8 <cpu_arch_name> "armv7", elf_name = 0x807015ae <cpu_elf_name> "v7", elf_hwcap = 32919,
  cpu_name = 0x80118340 <cpu_v7_name> "ARMv7 Processor", proc = 0x80955094 <ca9mp_processor_functions>,
  tlb = 0x80907810 <v7wbi_tlb_fns>, user = 0x8095502c <v6_user_fns>, cache = 0x80955000 <v7_cache_fns>}
   │702                                                                                                                               │
  >│703             pr_info("CPU: %s [%08x] revision %d (ARMv%s), cr=%08lx\n",                                                        │
   │704                     cpu_name, read_cpuid_id(), read_cpuid_id() & 15,                                                          │
   │705                     proc_arch[cpu_architecture()], get_cr());                                                                 │
   │706                                                                                                                               │
   │707             snprintf(init_utsname()->machine, __NEW_UTS_LEN + 1, "%s%c",                                                      │
   │708                      list->arch_name, ENDIANNESS);                                                                            │
   │709             snprintf(elf_platform, ELF_PLATFORM_SIZE, "%s%c",                                                                 │
   │710                      list->elf_name, ENDIANNESS);                                                                             │
   │711             elf_hwcap = list->elf_hwcap;                                                                                      │
   │712                                                                                                                               │
   │713             cpuid_init_hwcaps();                                                                                              │
   │714             patch_aeabi_idiv();                                                                                               │
   │136     void __init init_default_cache_policy(unsigned long pmd)                                                                  │
   │137     {                                                                                                                         │
   │138             int i;                                                                                                            │
   │139                                                                                                                               │
  >│140             initial_pmd_value = pmd;                                                                                          │
   │141                                                                                                                               │
   │142             pmd &= PMD_SECT_CACHE_MASK;                                                                                       │
   │143                                                                                                                               │
   │144             for (i = 0; i < ARRAY_SIZE(cache_policies); i++)                                                                  │
   │145                     if (cache_policies[i].pmd == pmd) {                                                                       │
   │146                             cachepolicy = i;                                                                                  │
   │147                             break;                                                                                            │
   │148                     }                                                                                                         │
   │149                                                                                                                               │
   │150             if (i == ARRAY_SIZE(cache_policies))                                                                              │
   │151                     pr_err("ERROR: could not find cache policy\n");                                                           │
   │152     }                                                                                                                         │
  >│345             pr_info("CPU: %s data cache, %s instruction cache\n",                                                             │
   │346                     cache_is_vivt() ? "VIVT" :                                                                                │
   │347                     cache_is_vipt_aliasing() ? "VIPT aliasing" :                                                              │
   │348                     cache_is_vipt_nonaliasing() ? "PIPT / VIPT nonaliasing" : "unknown",                                      │
   │349                     cache_is_vivt() ? "VIVT" :                                                                                │
   │350                     icache_is_vivt_asid_tagged() ? "VIVT ASID tagged" :                                                       │
   │351                     icache_is_vipt_aliasing() ? "VIPT aliasing" :                                                             │
   │352                     icache_is_pipt() ? "PIPT" :                                                                               │
   │353                     cache_is_vipt_nonaliasing() ? "VIPT nonaliasing" : "unknown");                                            │
  >│553             __asm__ (                                                                                                         │
   │554             "msr    cpsr_c, %1\n\t"                                                                                           │
   │555             "add    r14, %0, %2\n\t"                                                                                          │
   │556             "mov    sp, r14\n\t"                                                                                              │
   │557             "msr    cpsr_c, %3\n\t"                                                                                           │
   │558             "add    r14, %0, %4\n\t"                                                                                          │
   │559             "mov    sp, r14\n\t"                                                                                              │
   │560             "msr    cpsr_c, %5\n\t"                                                                                           │
   │561             "add    r14, %0, %6\n\t"                                                                                          │
   │562             "mov    sp, r14\n\t"                                                                                              │
   │563             "msr    cpsr_c, %7\n\t"                                                                                           │
   │564             "add    r14, %0, %8\n\t"                                                                                          │
   │565             "mov    sp, r14\n\t"                                                                                              │
   │566             "msr    cpsr_c, %9"                                                                                               │
   │567                 :                                                                                                             │
   │568                 : "r" (stk),                                                                                                  │
   │569                   PLC (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),                                                                     │
   │570                   "I" (offsetof(struct stack, irq[0])),                                                                       │
   │571                   PLC (PSR_F_BIT | PSR_I_BIT | ABT_MODE),                                                                     │
   │572                   "I" (offsetof(struct stack, abt[0])),                                                                       │
   │573                   PLC (PSR_F_BIT | PSR_I_BIT | UND_MODE),                                                                     │
   │574                   "I" (offsetof(struct stack, und[0])),                                                                       │
   │220             const struct machine_desc *mdesc, *mdesc_best = NULL;                                                             │
   │221                                                                                                                               │
   │222     #if defined(CONFIG_ARCH_MULTIPLATFORM) || defined(CONFIG_ARM_SINGLE_ARMV7M)                                               │
   │223             DT_MACHINE_START(GENERIC_DT, "Generic DT based system")                                                           │
   │224                     .l2c_aux_val = 0x0,                                                                                       │
   │225                     .l2c_aux_mask = ~0x0,                                                                                     │
   │226             MACHINE_END                                                                                                       │
   │227                                                                                                                               │
   │228             mdesc_best = &__mach_desc_GENERIC_DT;                                                                             │
   │229     #endif                                                                                                                    │
   │230                                                                                                                               │
   │231             if (!dt_phys || !early_init_dt_verify(phys_to_virt(dt_phys)))                                                     │
   │232                     return NULL;                                                                                              │
   │233                                                                                                                               │
   │234             mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);                                                 │
   │235                                                                                                                               │
   │236             if (!mdesc) {                                                                                                     │
   │237                     const char *prop;                                                                                         │
   │238                     int size;                                                                                                 │
   │239                     unsigned long dt_root;                                                                                    │
   │240                                                                                                                               │
   │244     static inline unsigned long __phys_to_virt(phys_addr_t x) //__phys_to_virt                                                │
   │245     {                                                                                                                         │
   │246             unsigned long t;                                                                                                  │
   │247                                                                                                                               │
   │248             /*                                                                                                                │
   │249              * 'unsigned long' cast discard upper word when                                                                   │
   │250              * phys_addr_t is 64 bit, and makes sure that inline                                                              │
   │251              * assembler expression receives 32 bit argument                                                                  │
   │252              * in place where 'r' 32 bit operand is expected.                                                                 │
   │253              */                                                                                                               │
  >│254             __pv_stub((unsigned long) x, t, "sub", __PV_BITS_31_24);                                                          │
   │255             return t;                                                                                                         │
   │256     }                                                                                                                         │
   │1251    bool __init early_init_dt_verify(void *params)                                                                            │
   │1252    {                                                                                                                         │
   │1253            if (!params)                                                                                                      │
   │1254                    return false;                                                                                             │
   │1255                                                                                                                              │
   │1256            /* check device tree validity */                                                                                  │
   │1257            if (fdt_check_header(params))                                                                                     │
   │1258                    return false;                                                                                             │
   │1259                                                                                                                              │
   │1260            /* Setup flat device-tree pointer */                                                                              │
   │1261            initial_boot_params = params;                                                                                     │
  >│1262            of_fdt_crc32 = crc32_be(~0, initial_boot_params,                                                                  │
   │1263                                    fdt_totalsize(initial_boot_params));                                                      │
   │1264            return true;                                                                                                      │
   │1265    }                                                                                                                         │
   │737     int __init of_scan_flat_dt(int (*it)(unsigned long node,                                                                  │
   │738                                          const char *uname, int depth,                                                        │
   │739                                          void *data),                                                                         │
   │740                                void *data)                                                                                    │
   │741     {                                                                                                                         │
  >│742             const void *blob = initial_boot_params;                                                                           │
   │743             const char *pathp;                                                                                                │
   │744             int offset, rc = 0, depth = -1;                                                                                   │
   │745                                                                                                                               │
   │746             if (!blob)                                                                                                        │
   │747                     return 0;                                                                                                 │
   │748                                                                                                                               │
   │749             for (offset = fdt_next_node(blob, -1, &depth);                                                                    │
   │750                  offset >= 0 && depth >= 0 && !rc;                                                                            │
   │751                  offset = fdt_next_node(blob, offset, &depth)) {                                                              │
   │752                                                                                                                               │
   │753                     pathp = fdt_get_name(blob, offset, NULL);                                                                 │
   │754                     if (*pathp == '/')                                                                                        │
   │755                             pathp = kbasename(pathp);                                                                         │
   │756                     rc = it(offset, pathp, depth, data);                                                                      │
   │757             }                                                                                                                 │
   │758             return rc;                                                                                                        │
   │759     }                                                                                                                         │
(gdb) p mdesc
$17 = (const struct machine_desc *) 0x809435a0 <__mach_desc_VEXPRESS_DT>
(gdb) p *mdesc
$18 = {nr = 4294967295, name = 0x807bbed0 "ARM-Versatile Express", atag_offset = 0, dt_compat = 0x8095b6c8 <v2m_dt_match>, 
  nr_irqs = 0, video_start = 0, video_end = 0, reserve_lp0 = 0 '\000', reserve_lp1 = 0 '\000', reserve_lp2 = 0 '\000',
  reboot_mode = REBOOT_COLD, l2c_aux_val = 4194304, l2c_aux_mask = 4262461439, l2c_write_sec = 0x0,
  smp = 0x8095b91c <vexpress_smp_dt_ops>, smp_init = 0x80909374 <vexpress_smp_init_ops>, fixup = 0x0, dt_fixup = 0x0, pv_fixup = 0x0,
  reserve = 0x0, map_io = 0x0, init_early = 0x0, init_irq = 0x0, init_time = 0x0, init_machine = 0x0, init_late = 0x0,
  handle_irq = 0x0, restart = 0x0}
type = const struct machine_desc {
    unsigned int nr;
    const char *name;
    unsigned long atag_offset;
    const char * const *dt_compat;
    unsigned int nr_irqs;
    unsigned int video_start;
    unsigned int video_end;
    unsigned char reserve_lp0 : 1;
    unsigned char reserve_lp1 : 1;
    unsigned char reserve_lp2 : 1;
   │1106            if (mdesc->reboot_mode != REBOOT_HARD)                                                                            │
   │1107                    reboot_mode = mdesc->reboot_mode;                                                                         │
   │1108                                                                                                                              │
  >│1109            init_mm.start_code = (unsigned long) _text;                                                                       │
   │1110            init_mm.end_code   = (unsigned long) _etext;                                                                      │
   │1111            init_mm.end_data   = (unsigned long) _edata;                                                                      │
   │1112            init_mm.brk        = (unsigned long) _end;                                                                        │
   │1113                                                                                                                              │
   │1114            /* populate cmd_line too for later use, preserving boot_command_line */                                           │
   │1115            strlcpy(cmd_line, boot_command_line, COMMAND_LINE_SIZE);                                                          │
   │1116            *cmdline_p = cmd_line;                                                                                            │
   │1117                                                                                                                              │
   │1118            early_fixmap_init();                                                                                              │
   │1119            early_ioremap_init();                                                                                             │
   │1120                                                                                                                              │
   │1121            parse_early_param();                                                                                              │
   │611     void __init parse_early_param(void)                                                                                       │
   │612     {                                                                                                                         │
   │613             static int done __initdata;                                                                                       │
   │614             static char tmp_cmdline[COMMAND_LINE_SIZE] __initdata;                                                            │
   │615                                                                                                                               │
  >│616             if (done)                                                                                                         │
   │617                     return;                                                                                                   │
   │618                                                                                                                               │
   │619             /* All fall through to do_early_param. */                                                                         │
   │620             strlcpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE);                                                       │
   │621             parse_early_options(tmp_cmdline);                                                                                 │
   │622             done = 1;                                                                                                         │
   │623     }                                                                                                                         │
   │164     char *parse_args(const char *doing,                                                                                       │
   │165                      char *args,                                                                                              │
   │166                      const struct kernel_param *params,                                                                       │
   │167                      unsigned num,                                                                                            │
   │168                      s16 min_level,                                                                                           │
   │169                      s16 max_level,                                                                                           │
   │170                      void *arg,                                                                                               │
   │171                      int (*unknown)(char *param, char *val,                                                                   │
   │172                                     const char *doing, void *arg))                                                            │
   │173     {                                                                                                                         │
  >│174             char *param, *val, *err = NULL;                                                                                   │
   │175                                                                                                                               │
   │176             /* Chew leading spaces */                                                                                         │
   │177             args = skip_spaces(args);                                                                                         │
   │178                                                                                                                               │
   │179             if (*args)                                                                                                        │
   │180                     pr_debug("doing %s, parsing ARGS: '%s'\n", doing, args);                                                  │
   │181                                                                                                                               │
   │182             while (*args) {                                                                                                   │
   │183                     int ret;                                                                                                  │
   │184                     int irq_was_disabled;                                                                                     │
   │185                                                                                                                               │
   │186                     args = next_arg(args, &param, &val);                                                                      │
   │182             while (*args) {                                                                                                   │
   │183                     int ret;                                                                                                  │
   │184                     int irq_was_disabled;                                                                                     │
   │185                                                                                                                               │
   │186                     args = next_arg(args, &param, &val);                                                                      │
   │187                     /* Stop at -- */                                                                                          │
   │188                     if (!val && strcmp(param, "--") == 0)                                                                     │
   │189                             return err ?: args;                                                                               │
   │190                     irq_was_disabled = irqs_disabled();                                                                       │
   │191                     ret = parse_one(param, val, doing, params, num,                                                           │
   │192                                     min_level, max_level, arg, unknown);                                                      │
   │193                     if (irq_was_disabled && !irqs_disabled())                                                                 │
   │194                             pr_warn("%s: option '%s' enabled irq's!\n",                                                       │
   │195                                     doing, param);                                                                            │
   │196                                                                                                                               │
   │197                     switch (ret) {                                                                                            │
   │198                     case 0:                                                                                                   │
   │199                             continue;                                                                                         │
   │200                     case -ENOENT:                                                                                             │
   │201                             pr_err("%s: Unknown parameter `%s'\n", doing, param);                                             │
   │202                             break;                                                                                            │
   │203                     case -ENOSPC:                                                                                             │
   │518                     if (cpu_arch >= CPU_ARCH_ARMv7 && (cr & CR_TRE)) {                                                        │
   │519                             /*                                                                                                │
   │520                              * For ARMv7 with TEX remapping,                                                                  │
   │521                              * - shared device is SXCB=1100                                                                   │
   │522                              * - nonshared device is SXCB=0100                                                                │
   │523                              * - write combine device mem is SXCB=0001                                                        │
   │524                              * (Uncached Normal memory)                                                                       │
   │525                              */                                                                                               │
   │526                             mem_types[MT_DEVICE].prot_sect |= PMD_SECT_TEX(1);                                                │
   │527                             mem_types[MT_DEVICE_NONSHARED].prot_sect |= PMD_SECT_TEX(1);                                      │
   │528                             mem_types[MT_DEVICE_WC].prot_sect |= PMD_SECT_BUFFERABLE;                                         │
   │692                     mem_types[MT_CACHECLEAN].prot_sect |= PMD_SECT_WB;                                                        │
   │693                     break;                                                                                                    │
   │694             }                                                                                                                 │
   │695             pr_info("Memory policy: %sData cache %s\n",                                                                       │
   │696                     ecc_mask ? "ECC enabled, " : "", cp->policy);                                                             │
   │697                                                                                                                               │
   │698             for (i = 0; i < ARRAY_SIZE(mem_types); i++) {                                                                     │
   │699                     struct mem_type *t = &mem_types[i];                                                                       │
   │700                     if (t->prot_l1)                                                                                           │
   │701                             t->prot_l1 |= PMD_DOMAIN(t->domain);                                                              │
   │702                     if (t->prot_sect)                                                                                         │
   │703                             t->prot_sect |= PMD_DOMAIN(t->domain);                                                            │
   │704             }                                                                                                                 │
   │705     }                                                                                                                         │
  >│1180            vmalloc_limit = (u64)(uintptr_t)vmalloc_min - PAGE_OFFSET + PHYS_OFFSET;                                          │
   │1181                                                                                                                              │
   │1182            for_each_memblock(memory, reg) {                                                                                  │
   │1183                    phys_addr_t block_start = reg->base;                                                                      │
   │1184                    phys_addr_t block_end = reg->base + reg->size;                                                            │
   │1185                                                                                                                              │
   │1186                    if (reg->base < vmalloc_limit) {                                                                          │
   │1187                            if (block_end > lowmem_limit)                                                                     │
   │1188                                    /*                                                                                        │
   │1189                                     * Compare as u64 to ensure vmalloc_limit does                                            │
   │1190                                     * not get truncated. block_end should always                                             │
   │1191                                     * fit in phys_addr_t so there should be no                                               │
   │1192                                     * issue with assignment.                                                                 │
   │1193                                     */                                                                                       │
   │1194                                    lowmem_limit = min_t(u64,                                                                 │
   │1195                                                             vmalloc_limit,                                                   │
   │1196                                                             block_end);                                                      │
   │1197                                                                                                                              │
(gdb) n
build_all_zonelists (pgdat=<optimized out>) at mm/page_alloc.c:5259
(gdb) p vm_total_pages 
$37 = 0
(gdb) s
(gdb) p vm_total_pages 
$38 = 130048
   │5272            pr_info("Built %i zonelists, mobility grouping %s.  Total pages: %ld\n",                                                                            │
   │5273                    nr_online_nodes,                                                                                                                            │
   │5274                    page_group_by_mobility_disabled ? "off" : "on",                                                                                             │
   │5275                    vm_total_pages);                                                                                                                            │
   │5276    #ifdef CONFIG_NUMA                                                                                                                                          │
   │5277            pr_info("Policy zone: %s\n", zone_names[policy_zone]);                                                                                              │
  virtual void SetRowAddress(GPIO *io, int row) {
    if (row == last_row_) return;
    io->SetBits(bk_);  // Enable serial input for the shifter
    for (int r = 7; r >= 0; r--) {
      if (row % 8 == r) {
        io->SetBits(din_);
      } else {
        io->ClearBits(din_);
      }
      io->SetBits(dck_);
      io->SetBits(dck_);  // Longer clock time; tested with Pi3
      io->ClearBits(dck_);
    }
    io->ClearBits(bk_);  // Disable serial input to keep unwanted bits out of the shifters
    last_row_ = row;
    // Set bits D and E to enable the proper shifter to display the selected
    // row.
    io->WriteMaskedBits(row_lookup_[row], row_mask_);
  }
// The DirectABCDRowAddressSetter sets the address by one of
// row pin ABCD for 3216 matrix 1:4 multiplexing. The matrix has
// 4 addressable rows. Row is selected by a low level on the
// corresponding row address pin. Other row address pins must be in high level.
//
// Row addr| 0 | 1 | 2 | 3
// --------+---+---+---+---
// Line A  | 0 | 1 | 1 | 1
// Line B  | 1 | 0 | 1 | 1
// Line C  | 1 | 1 | 0 | 1
// Line D  | 1 | 1 | 1 | 0
      tos_barrier.c                                                                                                                                                                         │ 
      tos_binary_heap.c                                                                                                                                                                     │ 
      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_bitmap.c                                                                                                                                                                          │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_char_fifo.c                                                                                                                                                                       │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_completion.c                                                                                                                                                                      │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_completion.c                                                                                                                                                                      │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_countdownlatch.c                                                                                                                                                                  │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_event.c                                                                                                                                                                           │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_global.c                                                                                                                                                                          │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_mail_queue.c                                                                                                                                                                      │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_message_queue.c                                                                                                                                                                   │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_mmblk.c                                                                                                                                                                           │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_mmheap.c                                                                                                                                                                          │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_mutex.c                                                                                                                                                                           │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_pend.c                                                                                                                                                                            │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_priority_mail_queue.c                                                                                                                                                             │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_priority_message_queue.c                                                                                                                                                          │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_priority_queue.c                                                                                                                                                                  │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_ring_queue.c                                                                                                                                                                      │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_robin.c                                                                                                                                                                           │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_rwlock.c                                                                                                                                                                          │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_sched.c                                                                                                                                                                           │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_sem.c                                                                                                                                                                             │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_stopwatch.c                                                                                                                                                                       │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_sys.c                                                                                                                                                                             │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_task.c                                                                                                                                                                            │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_tick.c                                                                                                                                                                            │>

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_time.c                                                                                                                                                                            │ 

      // this is tencentos-tiny source file,can you write a usage exmaple for this file?                                                                                                
      tos_timer.c                                                                                                                                                                           │ 
[tong@free ~/06_files/Download]$ cd ~/02_nvme              
绗涓绔 ョ涓浼锛浣涓轰涔杩瑕锛

绗浜绔 惧惧

绗涓绔 辩诲绉缁

绗绔 瑰绘惧藉

绗浜绔 绠＄浣冲缁

绗绔 充蹇㈡

绗涓绔 濡浣瑙浣浜虹锛

绗绔 璁╁浣浣惧姝

绗涔绔 缃浣浜虹
一旦不使用 Make 中那些用来生成构建流程的特性，Ninja 这种功能更少，解决问题更明确的工具就更合适。
 
Ninjia 的设计原则就是构建脚本易于人阅读（方便调试），但不易于人直接书写（方便机器解析）。同时，构建流程可以获得更高的效率。减少构建时间能直接提高开发效率。
有时候回答不好问题，是因为题没读明白。 有时候修不了 bug，是因为 log 没读明白。
上周被同事报了一个卡顿 bug，看了一阵发现，真机上没有，模拟器上有，就认为是模拟器的 bug，不重要，然后就没在深入，就不管了。
如果要我给年轻人建议，那么我的建议就是选择时，要慎之又慎，尤其对你不可把控的事情。很多时候，再来一次的成本，真的是太大了。
去年利用业余时间，开发了一款屏幕测量应用 ―― PixelsMeasure[1]，这篇文章总结一下这段时间的经历和感悟。
最近客户遇到一个线上的性能问题，看了两天没解决，最后被我们同事一个小时给发现问题，并提供了一个两行代码的修复方案，缓解了问题，上线后得到了用户的认可。但是客户在回顾的时候，硬说是没有发
现主要原因，只是修复了一个代码坏味道的问题，让人倍感无奈！
最近尝试用了 Debug Memory Graph 和 Xcode Instruments，不用不知道，一用吓一跳。我发现 PixelsMeasure[1] 第一次测量后，创建了 30 
多万个对象，然后驻留在内存中。导致即使不测量时，内存也占用过大。一翻研究发现，是自己自定义了一个第三方库出的问题 
半年来，ChatGPT (基于 GPT 架构开发的大型语言模型) 彻底颠覆了人们对人工智能的认识，给很多行业都带来了前所未有的冲击。尤其在编码方面，能轻而易举地写出俄罗斯方块、贪吃蛇、1024 等小游戏，能
写出电影推荐等可上线的应用程序。在出色完成编码任务的同时，编码质量和效率都让人震撼。以至于很多人开始焦虑，觉得程序员离下岗不远了。为了了解其能力，我深入体验了一回。惊奇地发现，GPT 
十分利好程序员，尤其利好程序员。
最近看了很多视频，房车旅行、摩旅、骑行和夫妻骑行，这个行业越来越卷了。但是我又很羡慕他们，能乘着年轻的时候，做这些事情，拍这些视频，这就是他们人生的记录，是他们的作品。
刚炫耀了一波自己的睡眠质量，结果这周就遇到了问题。不知道是喝了咖啡，还是焦虑，总之，晚上睡不着了。
~
最近被 Keyboardshortcuts 卡了三周，这种终于找到了方案，柳暗花明。做一件事情，真的是不能太难，太难了容易放弃，或者拖延。也不能太简单，太简单会觉得无聊。Keyboardshortcuts 
的方案虽然不完美，但是也勉强能用，能达到正确的使用它，就会发现它能用。如果你玩的花一点，它可能不正常工作。为了大部分人能用，先这样吧。
四周前发现，自己对管理知识一无所知。接着报了网课，学了几节课，最大的收获就是开阔了眼界，并知道了有一本久负盛名的管理学书籍《卓有成效的管理者》，随即买了。
从后端转行 iOS 开发一年了，一直没有研究过网络请求的 API（项目上有现成的封装）。之前手写项目的时候，总感觉对 URLSession 
一知半解，犹豫了很多次。这次利用假期，终于有机会能完整的读了一遍官方文档，总结了一下，于是有了这篇文章《URL 加载系统（URL Loading System）》[1]。练习了一把，于是有了这个 repo 
zddhub/url-loading-system[2]。完成后网上搜了一把，发现大都是照搬官方文档，或者是几年前的老文章，还是有满满的成就感。它至少是达到了我写文章的目的 ―― 对自己有用。
主动学习需要很强的自制力，我很难做到，回头看看自己的成长，被动学习占了重要的一块。
uint16_t u16AverageFilter(uint16_t Value[])
{
  uint16_t val, average;
  uint8_t min;
  uint32_t sum;
  if (Value[0] < Value[1])
  {
    val = Value[0];
    min = 0;
  }
  else
  {
    val = Value[1];
    min = 1;
  }
  if (Value[2] < val)
  {
    val = Value[2];
    min = 2;
  }
  sum = (uint32_t)Value[0] + Value[1] + Value[2];
  average = sum / 3;
  if ((average - Value[min]) > 10)
  {
    average = (sum - Value[min]) / 2;
  }
  return average;
}
/* 锋扮瀛 6涓 CGRAM涓 */
void Write6CGRAM(unsigned char x)
{
	unsigned char i,j;

    j = x + 40;
	gpio_set_level(PIN_NUM_CS,0);//CS浣
	usleep(1);
	VFDWriteData(0x40 + 0);//板瀵瀛ㄨ捣濮浣缃	
	for (i = x; i < j; i++)
	{
		VFDWriteData(refreshData[i]);
	}
	gpio_set_level(PIN_NUM_CS,1);//CS楂
    usleep(2);
}
void BootAnimation()
{
	unsigned char cnt,i;
	unsigned char G1Temp[5][5] = {
   {0x03, 0x0b, 0x0b, 0x03, 0x03},// 
   {0x03, 0x07, 0x0b, 0x01, 0x05},//
   {0x03, 0x03, 0x0f, 0x07, 0x01},//
   {0x0f, 0x03, 0x0b, 0x01, 0x01},//
   {0x00, 0x00, 0x00, 0x00, 0x00},//
};

	i = 0;
	memset(ADbuff,0xff,13);
	//涓剧ず
	ADbuff[6] &= 0xfe;
	ADbuff[7] &= 0xfe;
	ADbuff[8] &= 0xfe;
	ADbuff[9] &= 0xfe;
	ADbuff[10] &= 0xfe;
	ADbuff[11] &= 0xfe;
	VFDWriteAllADRAMAndShow(ADbuff);
	//BootSound();
	for (cnt = 1; cnt < 13; cnt++)
	{
		VFDWriteStrAndShow(cnt, ">");
		WriteCGRAM(6,&G1Temp[0][0],i);
		VFDWriteOneDIYCharAndShow(0,6);//CGRAM 6缂瀛剧ずG1涓
		i++;
		if(i >= 4) i = 0;
		vTaskDelay(50 / portTICK_PERIOD_MS);
	}
	//DDiDi();

	vTaskDelay(200 / portTICK_PERIOD_MS);
	DisappearingAnimation();//剧ず娑澶卞ㄧ

	/*
	VFDWriteStrAndShow(0, " ");
	//WriteCGRAM(6,&G1AnimationTemp[0][0],4);//抽G1剧ず
	//VFDWriteOneDIYCharAndShow(0,6);//CGRAM 6缂瀛剧ずG1涓
	vTaskDelay(20 / portTICK_PERIOD_MS);

	//抽AD剧ず
	memset(ADbuff,0x00,13);
	for (cnt = 0; cnt < 13; cnt++)
	{
		VFDWriteOneADRAMAndShow(cnt,ADbuff[cnt]);
		vTaskDelay(20 / portTICK_PERIOD_MS);
	}
	*/
}
A

The Application profile defines an architecture aimed at high performance
processors, supporting a virtual memory system using a Memory Management
Unit (MMU) and therefore capable of running fully featured operating systems.
Support for the ARM and Thumb instruction sets is provided.
ARMv7-A, the Application profile, is implemented by all Cortex-A series
processors, and by processors developed by companies who have licensed the
ARM architecture. At the beginning of 2014, just under three billion Cortex-A
Series chips had been shipped.
The ARMv8-A architecture, which is not described in this book, supports the
AArch32 state, a 32-bit implementation of the architecture that is backwards
compatible with ARMv7-A.

ARM DEN0013D
ID012214

R

The Real-time profile defines an architecture aimed at systems that require
deterministic timing and low interrupt latency. There is no support for a virtual
memory system, but memory regions can be protected using a simple Memory
Protection Unit (MPU).

M

The Microcontroller profile defines an architecture aimed at low cost systems,
where low-latency interrupt processing is vital. It uses a different exception
handling model to the other profiles and supports only a variant of the Thumb
instruction set.

Copyright 漏 2011  2013 ARM. All rights reserved.
Non-Confidential
The Cortex-A8 processor
The ARM Cortex-A8 processor, has the ability to scale in speed from 600MHz to greater than
1GHz. The Cortex-A8 processor can meet the requirements for power-optimized mobile
devices needing operation in less than 300mW; and performance-optimized consumer
applications requiring 2000 Dhrystone MIPS. It is available in a number of different devices,
including the S5PC100 from Samsung, the OMAP3530 from Texas Instruments and the
The Cortex-A9 processor
The ARM Cortex-A9 processor is a power-efficient and popular high performance choice in low
power or thermally constrained cost-sensitive devices.
It is currently shipping in large volumes for smartphones, digital TV, consumer and enterprise
applications. The Cortex-A9 processor provides an increase in performance of greater than 50%
compared to the Cortex-A8 processor. The Cortex-A9 processor can be configured with up to
four cores delivering peak performance when required. Configurability and flexibility makes
the Cortex-A9 processor suitable for wide variety of markets and applications.
